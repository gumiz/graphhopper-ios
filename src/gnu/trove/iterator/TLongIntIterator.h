//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: dependencies/trove/src/gnu/trove/iterator/TLongIntIterator.java
//

#ifndef _GnuTroveIteratorTLongIntIterator_H_
#define _GnuTroveIteratorTLongIntIterator_H_

#include "J2ObjC_header.h"
#include "gnu/trove/iterator/TAdvancingIterator.h"

/**
 @brief Iterator for maps of type long and int.
 <p>The iterator semantics for Trove's primitive maps is slightly different from those defined in <tt>java.util.Iterator</tt>, but still well within the scope of the pattern, as defined by Gamma, et al.</p> <p>This iterator does <b>not</b> implicitly advance to the next entry when the value at the current position is retrieved.  Rather, you must explicitly ask the iterator to <tt>advance()</tt> and then retrieve either the <tt>key()</tt>, the <tt>value()</tt> or both.  This is done so that you have the option, but not the obligation, to retrieve keys and/or values as your application requires, and without introducing wrapper objects that would carry both.  As the iteration is stateful, access to the key/value parts of the current map entry happens in constant time.</p> <p>In practice, the iterator is akin to a "search finger" that you move from position to position.  Read or write operations affect the current entry only and do not assume responsibility for moving the finger.</p> <p>Here are some sample scenarios for this class of iterator:</p> <pre> // accessing keys/values through an iterator: for ( TLongIntIterator it = map.iterator(); it.hasNext(); ) { it.advance(); if ( satisfiesCondition( it.key() ) { doSomethingWithValue( it.value() ); } } </pre> <pre> // modifying values in-place through iteration: for ( TLongIntIterator it = map.iterator(); it.hasNext(); ) { it.advance(); if ( satisfiesCondition( it.key() ) { it.setValue( newValueForKey( it.key() ) ); } } </pre> <pre> // deleting entries during iteration: for ( TLongIntIterator it = map.iterator(); it.hasNext(); ) { it.advance(); if ( satisfiesCondition( it.key() ) { it.remove(); } } </pre> <pre> // faster iteration by avoiding hasNext(): TLongIntIterator iterator = map.iterator(); for ( int i = map.size(); i-- > 0; ) { iterator.advance(); doSomethingWithKeyAndValue( iterator.key(), iterator.value() ); } </pre>
 */
@protocol GnuTroveIteratorTLongIntIterator < GnuTroveIteratorTAdvancingIterator, NSObject, JavaObject >
/**
 @brief Provides access to the key of the mapping at the iterator's position.
 Note that you must <tt>advance()</tt> the iterator at least once before invoking this method.
 @return the key of the entry at the iterator's current position.
 */
- (jlong)key;

/**
 @brief Provides access to the value of the mapping at the iterator's position.
 Note that you must <tt>advance()</tt> the iterator at least once before invoking this method.
 @return the value of the entry at the iterator's current position.
 */
- (jint)value;

/**
 @brief Replace the value of the mapping at the iterator's position with the specified value.
 Note that you must <tt>advance()</tt> the iterator at least once before invoking this method.
 @param val the value to set in the current entry
 @return the old value of the entry.
 */
- (jint)setValueWithInt:(jint)val;

@end

J2OBJC_EMPTY_STATIC_INIT(GnuTroveIteratorTLongIntIterator)

J2OBJC_TYPE_LITERAL_HEADER(GnuTroveIteratorTLongIntIterator)

#endif // _GnuTroveIteratorTLongIntIterator_H_
