//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: dependencies/trove/src/gnu/trove/list/array/TLongArrayList.java
//

#ifndef _GnuTroveListArrayTLongArrayList_H_
#define _GnuTroveListArrayTLongArrayList_H_

@class GnuTroveListArrayTLongArrayList;
@class IOSLongArray;
@class JavaUtilRandom;
@protocol GnuTroveFunctionTLongFunction;
@protocol GnuTroveProcedureTLongProcedure;
@protocol GnuTroveTLongCollection;
@protocol JavaIoObjectInput;
@protocol JavaIoObjectOutput;
@protocol JavaUtilCollection;

#include "J2ObjC_header.h"
#include "gnu/trove/iterator/TLongIterator.h"
#include "gnu/trove/list/TLongList.h"
#include "java/io/Externalizable.h"

/**
 @brief TLongArrayList iterator
 */
@interface GnuTroveListArrayTLongArrayList_TLongArrayIterator : NSObject < GnuTroveIteratorTLongIterator > {
 @public
  /**
   @brief Index of element returned by most recent call to next or previous.
   Reset to -1 if this element is deleted by a call to remove.
   */
  jint lastRet_;
}

- (instancetype)initWithGnuTroveListArrayTLongArrayList:(GnuTroveListArrayTLongArrayList *)outer$
                                                withInt:(jint)index;

/**
 
 */
- (jboolean)hasNext;

/**
 
 */
- (jlong)next;

/**
 
 */
- (void)remove;

@end

J2OBJC_EMPTY_STATIC_INIT(GnuTroveListArrayTLongArrayList_TLongArrayIterator)

CF_EXTERN_C_BEGIN
CF_EXTERN_C_END

J2OBJC_TYPE_LITERAL_HEADER(GnuTroveListArrayTLongArrayList_TLongArrayIterator)

#define GnuTroveListArrayTLongArrayList_DEFAULT_CAPACITY 10
#define GnuTroveListArrayTLongArrayList_serialVersionUID 1LL

/**
 @brief A resizable, array-backed list of long primitives.
 */
@interface GnuTroveListArrayTLongArrayList : NSObject < GnuTroveListTLongList, JavaIoExternalizable > {
 @public
  /**
   @brief the data of the list
   */
  IOSLongArray *_data_;
  /**
   @brief the index after the last entry in the list
   */
  jint _pos_;
  /**
   @brief the long value that represents null
   */
  jlong no_entry_value_;
}

/**
 @brief Creates a new <code>TLongArrayList</code> instance with the default capacity.
 */
- (instancetype)init;

/**
 @brief Creates a new <code>TLongArrayList</code> instance with the specified capacity.
 @param capacity an <code>int</code> value
 */
- (instancetype)initWithInt:(jint)capacity;

/**
 @brief Creates a new <code>TLongArrayList</code> instance with the specified capacity.
 @param capacity an <code>int</code> value
 @param no_entry_value an <code>long</code> value that represents null.
 */
- (instancetype)initWithInt:(jint)capacity
                   withLong:(jlong)no_entry_value;

/**
 @brief Creates a new <code>TLongArrayList</code> instance that contains a copy of the collection passed to us.
 @param collection the collection to copy
 */
- (instancetype)initWithGnuTroveTLongCollection:(id<GnuTroveTLongCollection>)collection;

/**
 @brief Creates a new <code>TLongArrayList</code> instance whose capacity is the length of <tt>values</tt> array and whose initial contents are the specified values.
 <p> A defensive copy of the given values is held by the new instance.
 @param values an <code>long[]</code> value
 */
- (instancetype)initWithLongArray:(IOSLongArray *)values;

- (instancetype)initWithLongArray:(IOSLongArray *)values
                         withLong:(jlong)no_entry_value
                      withBoolean:(jboolean)wrap;

/**
 @brief Returns a primitive List implementation that wraps around the given primitive array.
 <p/> NOTE: mutating operation are allowed as long as the List does not grow. In that case an IllegalStateException will be thrown
 @param values
 @return 
 */
+ (GnuTroveListArrayTLongArrayList *)wrapWithLongArray:(IOSLongArray *)values;

/**
 @brief Returns a primitive List implementation that wraps around the given primitive array.
 <p/> NOTE: mutating operation are allowed as long as the List does not grow. In that case an IllegalStateException will be thrown
 @param values
 @param no_entry_value
 @return 
 */
+ (GnuTroveListArrayTLongArrayList *)wrapWithLongArray:(IOSLongArray *)values
                                              withLong:(jlong)no_entry_value;

/**
 
 */
- (jlong)getNoEntryValue;

/**
 @brief Grow the internal array as needed to accommodate the specified number of elements.
 The size of the array bytes on each resize unless capacity requires more than twice the current capacity.
 */
- (void)ensureCapacityWithInt:(jint)capacity;

/**
 
 */
- (jint)size;

/**
 
 */
- (jboolean)isEmpty;

/**
 @brief Sheds any excess capacity above and beyond the current size of the list.
 */
- (void)trimToSize;

/**
 
 */
- (jboolean)addWithLong:(jlong)val;

/**
 
 */
- (void)addWithLongArray:(IOSLongArray *)vals;

/**
 
 */
- (void)addWithLongArray:(IOSLongArray *)vals
                 withInt:(jint)offset
                 withInt:(jint)length;

/**
 
 */
- (void)insertWithInt:(jint)offset
             withLong:(jlong)value;

/**
 
 */
- (void)insertWithInt:(jint)offset
        withLongArray:(IOSLongArray *)values;

/**
 
 */
- (void)insertWithInt:(jint)offset
        withLongArray:(IOSLongArray *)values
              withInt:(jint)valOffset
              withInt:(jint)len;

/**
 
 */
- (jlong)getWithInt:(jint)offset;

/**
 @brief Returns the value at the specified offset without doing any bounds checking.
 */
- (jlong)getQuickWithInt:(jint)offset;

/**
 
 */
- (jlong)setWithInt:(jint)offset
           withLong:(jlong)val;

/**
 
 */
- (jlong)replaceWithInt:(jint)offset
               withLong:(jlong)val;

/**
 
 */
- (void)setWithInt:(jint)offset
     withLongArray:(IOSLongArray *)values;

/**
 
 */
- (void)setWithInt:(jint)offset
     withLongArray:(IOSLongArray *)values
           withInt:(jint)valOffset
           withInt:(jint)length;

/**
 @brief Sets the value at the specified offset without doing any bounds checking.
 */
- (void)setQuickWithInt:(jint)offset
               withLong:(jlong)val;

/**
 
 */
- (void)clear;

/**
 @brief Flushes the internal state of the list, setting the capacity of the empty list to <tt>capacity</tt>.
 */
- (void)clearWithInt:(jint)capacity;

/**
 @brief Sets the size of the list to 0, but does not change its capacity.
 This method can be used as an alternative to the #clear() method if you want to recycle a list without allocating new backing arrays.
 */
- (void)reset;

/**
 @brief Sets the size of the list to 0, but does not change its capacity.
 This method can be used as an alternative to the #clear() method if you want to recycle a list without allocating new backing arrays. This method differs from #reset() in that it does not clear the old values in the backing array. Thus, it is possible for getQuick to return stale data if this method is used and the caller is careless about bounds checking.
 */
- (void)resetQuick;

/**
 
 */
- (jboolean)removeWithLong:(jlong)value;

/**
 
 */
- (jlong)removeAtWithInt:(jint)offset;

/**
 
 */
- (void)removeWithInt:(jint)offset
              withInt:(jint)length;

/**
 
 */
- (id<GnuTroveIteratorTLongIterator>)iterator;

/**
 
 */
- (jboolean)containsAllWithJavaUtilCollection:(id<JavaUtilCollection>)collection;

/**
 
 */
- (jboolean)containsAllWithGnuTroveTLongCollection:(id<GnuTroveTLongCollection>)collection;

/**
 
 */
- (jboolean)containsAllWithLongArray:(IOSLongArray *)array;

/**
 
 */
- (jboolean)addAllWithJavaUtilCollection:(id<JavaUtilCollection>)collection;

/**
 
 */
- (jboolean)addAllWithGnuTroveTLongCollection:(id<GnuTroveTLongCollection>)collection;

/**
 
 */
- (jboolean)addAllWithLongArray:(IOSLongArray *)array;

/**
 
 */
- (jboolean)retainAllWithJavaUtilCollection:(id<JavaUtilCollection>)collection;

/**
 
 */
- (jboolean)retainAllWithGnuTroveTLongCollection:(id<GnuTroveTLongCollection>)collection;

/**
 
 */
- (jboolean)retainAllWithLongArray:(IOSLongArray *)array;

/**
 
 */
- (jboolean)removeAllWithJavaUtilCollection:(id<JavaUtilCollection>)collection;

/**
 
 */
- (jboolean)removeAllWithGnuTroveTLongCollection:(id<GnuTroveTLongCollection>)collection;

/**
 
 */
- (jboolean)removeAllWithLongArray:(IOSLongArray *)array;

/**
 
 */
- (void)transformValuesWithGnuTroveFunctionTLongFunction:(id<GnuTroveFunctionTLongFunction>)function;

/**
 
 */
- (void)reverse;

/**
 
 */
- (void)reverseWithInt:(jint)from
               withInt:(jint)to;

/**
 
 */
- (void)shuffleWithJavaUtilRandom:(JavaUtilRandom *)rand;

/**
 
 */
- (id<GnuTroveListTLongList>)subListWithInt:(jint)begin
                                    withInt:(jint)end;

/**
 
 */
- (IOSLongArray *)toArray;

/**
 
 */
- (IOSLongArray *)toArrayWithInt:(jint)offset
                         withInt:(jint)len;

/**
 
 */
- (IOSLongArray *)toArrayWithLongArray:(IOSLongArray *)dest;

/**
 
 */
- (IOSLongArray *)toArrayWithLongArray:(IOSLongArray *)dest
                               withInt:(jint)offset
                               withInt:(jint)len;

/**
 
 */
- (IOSLongArray *)toArrayWithLongArray:(IOSLongArray *)dest
                               withInt:(jint)source_pos
                               withInt:(jint)dest_pos
                               withInt:(jint)len;

/**
 
 */
- (jboolean)isEqual:(id)other;

/**
 
 */
- (NSUInteger)hash;

/**
 
 */
- (jboolean)forEachWithGnuTroveProcedureTLongProcedure:(id<GnuTroveProcedureTLongProcedure>)procedure;

/**
 
 */
- (jboolean)forEachDescendingWithGnuTroveProcedureTLongProcedure:(id<GnuTroveProcedureTLongProcedure>)procedure;

/**
 
 */
- (void)sort;

/**
 
 */
- (void)sortWithInt:(jint)fromIndex
            withInt:(jint)toIndex;

/**
 
 */
- (void)fillWithLong:(jlong)val;

/**
 
 */
- (void)fillWithInt:(jint)fromIndex
            withInt:(jint)toIndex
           withLong:(jlong)val;

/**
 
 */
- (jint)binarySearchWithLong:(jlong)value;

/**
 
 */
- (jint)binarySearchWithLong:(jlong)value
                     withInt:(jint)fromIndex
                     withInt:(jint)toIndex;

/**
 
 */
- (jint)indexOfWithLong:(jlong)value;

/**
 
 */
- (jint)indexOfWithInt:(jint)offset
              withLong:(jlong)value;

/**
 
 */
- (jint)lastIndexOfWithLong:(jlong)value;

/**
 
 */
- (jint)lastIndexOfWithInt:(jint)offset
                  withLong:(jlong)value;

/**
 
 */
- (jboolean)containsWithLong:(jlong)value;

/**
 
 */
- (id<GnuTroveListTLongList>)grepWithGnuTroveProcedureTLongProcedure:(id<GnuTroveProcedureTLongProcedure>)condition;

/**
 
 */
- (id<GnuTroveListTLongList>)inverseGrepWithGnuTroveProcedureTLongProcedure:(id<GnuTroveProcedureTLongProcedure>)condition;

/**
 
 */
- (jlong)max;

/**
 
 */
- (jlong)min;

/**
 
 */
- (jlong)sum;

/**
 
 */
- (NSString *)description;

- (void)writeExternalWithJavaIoObjectOutput:(id<JavaIoObjectOutput>)outArg;

- (void)readExternalWithJavaIoObjectInput:(id<JavaIoObjectInput>)inArg;

@end

J2OBJC_EMPTY_STATIC_INIT(GnuTroveListArrayTLongArrayList)

J2OBJC_FIELD_SETTER(GnuTroveListArrayTLongArrayList, _data_, IOSLongArray *)

CF_EXTERN_C_BEGIN

FOUNDATION_EXPORT GnuTroveListArrayTLongArrayList *GnuTroveListArrayTLongArrayList_wrapWithLongArray_(IOSLongArray *values);

FOUNDATION_EXPORT GnuTroveListArrayTLongArrayList *GnuTroveListArrayTLongArrayList_wrapWithLongArray_withLong_(IOSLongArray *values, jlong no_entry_value);

J2OBJC_STATIC_FIELD_GETTER(GnuTroveListArrayTLongArrayList, serialVersionUID, jlong)

J2OBJC_STATIC_FIELD_GETTER(GnuTroveListArrayTLongArrayList, DEFAULT_CAPACITY, jint)
CF_EXTERN_C_END

J2OBJC_TYPE_LITERAL_HEADER(GnuTroveListArrayTLongArrayList)

@interface GnuTroveListArrayTLongArrayList_$1 : GnuTroveListArrayTLongArrayList {
}

/**
 @brief Growing the wrapped external array is not allow
 */
- (void)ensureCapacityWithInt:(jint)capacity;

- (instancetype)initWithLongArray:(IOSLongArray *)arg$0
                         withLong:(jlong)arg$1
                      withBoolean:(jboolean)arg$2;

@end

J2OBJC_EMPTY_STATIC_INIT(GnuTroveListArrayTLongArrayList_$1)

CF_EXTERN_C_BEGIN
CF_EXTERN_C_END

J2OBJC_TYPE_LITERAL_HEADER(GnuTroveListArrayTLongArrayList_$1)

#endif // _GnuTroveListArrayTLongArrayList_H_
