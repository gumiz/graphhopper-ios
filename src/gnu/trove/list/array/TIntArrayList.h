//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: dependencies/trove/src/gnu/trove/list/array/TIntArrayList.java
//

#ifndef _GnuTroveListArrayTIntArrayList_H_
#define _GnuTroveListArrayTIntArrayList_H_

@class GnuTroveListArrayTIntArrayList;
@class IOSIntArray;
@class JavaUtilRandom;
@protocol GnuTroveFunctionTIntFunction;
@protocol GnuTroveProcedureTIntProcedure;
@protocol GnuTroveTIntCollection;
@protocol JavaIoObjectInput;
@protocol JavaIoObjectOutput;
@protocol JavaUtilCollection;

#include "J2ObjC_header.h"
#include "gnu/trove/iterator/TIntIterator.h"
#include "gnu/trove/list/TIntList.h"
#include "java/io/Externalizable.h"

/**
 @brief TIntArrayList iterator
 */
@interface GnuTroveListArrayTIntArrayList_TIntArrayIterator : NSObject < GnuTroveIteratorTIntIterator > {
 @public
  /**
   @brief Index of element returned by most recent call to next or previous.
   Reset to -1 if this element is deleted by a call to remove.
   */
  jint lastRet_;
}

- (instancetype)initWithGnuTroveListArrayTIntArrayList:(GnuTroveListArrayTIntArrayList *)outer$
                                               withInt:(jint)index;

/**
 
 */
- (jboolean)hasNext;

/**
 
 */
- (jint)next;

/**
 
 */
- (void)remove;

@end

J2OBJC_EMPTY_STATIC_INIT(GnuTroveListArrayTIntArrayList_TIntArrayIterator)

CF_EXTERN_C_BEGIN
CF_EXTERN_C_END

J2OBJC_TYPE_LITERAL_HEADER(GnuTroveListArrayTIntArrayList_TIntArrayIterator)

#define GnuTroveListArrayTIntArrayList_DEFAULT_CAPACITY 10
#define GnuTroveListArrayTIntArrayList_serialVersionUID 1LL

/**
 @brief A resizable, array-backed list of int primitives.
 */
@interface GnuTroveListArrayTIntArrayList : NSObject < GnuTroveListTIntList, JavaIoExternalizable > {
 @public
  /**
   @brief the data of the list
   */
  IOSIntArray *_data_;
  /**
   @brief the index after the last entry in the list
   */
  jint _pos_;
  /**
   @brief the int value that represents null
   */
  jint no_entry_value_;
}

/**
 @brief Creates a new <code>TIntArrayList</code> instance with the default capacity.
 */
- (instancetype)init;

/**
 @brief Creates a new <code>TIntArrayList</code> instance with the specified capacity.
 @param capacity an <code>int</code> value
 */
- (instancetype)initWithInt:(jint)capacity;

/**
 @brief Creates a new <code>TIntArrayList</code> instance with the specified capacity.
 @param capacity an <code>int</code> value
 @param no_entry_value an <code>int</code> value that represents null.
 */
- (instancetype)initWithInt:(jint)capacity
                    withInt:(jint)no_entry_value;

/**
 @brief Creates a new <code>TIntArrayList</code> instance that contains a copy of the collection passed to us.
 @param collection the collection to copy
 */
- (instancetype)initWithGnuTroveTIntCollection:(id<GnuTroveTIntCollection>)collection;

/**
 @brief Creates a new <code>TIntArrayList</code> instance whose capacity is the length of <tt>values</tt> array and whose initial contents are the specified values.
 <p> A defensive copy of the given values is held by the new instance.
 @param values an <code>int[]</code> value
 */
- (instancetype)initWithIntArray:(IOSIntArray *)values;

- (instancetype)initWithIntArray:(IOSIntArray *)values
                         withInt:(jint)no_entry_value
                     withBoolean:(jboolean)wrap;

/**
 @brief Returns a primitive List implementation that wraps around the given primitive array.
 <p/> NOTE: mutating operation are allowed as long as the List does not grow. In that case an IllegalStateException will be thrown
 @param values
 @return 
 */
+ (GnuTroveListArrayTIntArrayList *)wrapWithIntArray:(IOSIntArray *)values;

/**
 @brief Returns a primitive List implementation that wraps around the given primitive array.
 <p/> NOTE: mutating operation are allowed as long as the List does not grow. In that case an IllegalStateException will be thrown
 @param values
 @param no_entry_value
 @return 
 */
+ (GnuTroveListArrayTIntArrayList *)wrapWithIntArray:(IOSIntArray *)values
                                             withInt:(jint)no_entry_value;

/**
 
 */
- (jint)getNoEntryValue;

/**
 @brief Grow the internal array as needed to accommodate the specified number of elements.
 The size of the array bytes on each resize unless capacity requires more than twice the current capacity.
 */
- (void)ensureCapacityWithInt:(jint)capacity;

/**
 
 */
- (jint)size;

/**
 
 */
- (jboolean)isEmpty;

/**
 @brief Sheds any excess capacity above and beyond the current size of the list.
 */
- (void)trimToSize;

/**
 
 */
- (jboolean)addWithInt:(jint)val;

/**
 
 */
- (void)addWithIntArray:(IOSIntArray *)vals;

/**
 
 */
- (void)addWithIntArray:(IOSIntArray *)vals
                withInt:(jint)offset
                withInt:(jint)length;

/**
 
 */
- (void)insertWithInt:(jint)offset
              withInt:(jint)value;

/**
 
 */
- (void)insertWithInt:(jint)offset
         withIntArray:(IOSIntArray *)values;

/**
 
 */
- (void)insertWithInt:(jint)offset
         withIntArray:(IOSIntArray *)values
              withInt:(jint)valOffset
              withInt:(jint)len;

/**
 
 */
- (jint)getWithInt:(jint)offset;

/**
 @brief Returns the value at the specified offset without doing any bounds checking.
 */
- (jint)getQuickWithInt:(jint)offset;

/**
 
 */
- (jint)setWithInt:(jint)offset
           withInt:(jint)val;

/**
 
 */
- (jint)replaceWithInt:(jint)offset
               withInt:(jint)val;

/**
 
 */
- (void)setWithInt:(jint)offset
      withIntArray:(IOSIntArray *)values;

/**
 
 */
- (void)setWithInt:(jint)offset
      withIntArray:(IOSIntArray *)values
           withInt:(jint)valOffset
           withInt:(jint)length;

/**
 @brief Sets the value at the specified offset without doing any bounds checking.
 */
- (void)setQuickWithInt:(jint)offset
                withInt:(jint)val;

/**
 
 */
- (void)clear;

/**
 @brief Flushes the internal state of the list, setting the capacity of the empty list to <tt>capacity</tt>.
 */
- (void)clearWithInt:(jint)capacity;

/**
 @brief Sets the size of the list to 0, but does not change its capacity.
 This method can be used as an alternative to the #clear() method if you want to recycle a list without allocating new backing arrays.
 */
- (void)reset;

/**
 @brief Sets the size of the list to 0, but does not change its capacity.
 This method can be used as an alternative to the #clear() method if you want to recycle a list without allocating new backing arrays. This method differs from #reset() in that it does not clear the old values in the backing array. Thus, it is possible for getQuick to return stale data if this method is used and the caller is careless about bounds checking.
 */
- (void)resetQuick;

/**
 
 */
- (jboolean)removeWithInt:(jint)value;

/**
 
 */
- (jint)removeAtWithInt:(jint)offset;

/**
 
 */
- (void)removeWithInt:(jint)offset
              withInt:(jint)length;

/**
 
 */
- (id<GnuTroveIteratorTIntIterator>)iterator;

/**
 
 */
- (jboolean)containsAllWithJavaUtilCollection:(id<JavaUtilCollection>)collection;

/**
 
 */
- (jboolean)containsAllWithGnuTroveTIntCollection:(id<GnuTroveTIntCollection>)collection;

/**
 
 */
- (jboolean)containsAllWithIntArray:(IOSIntArray *)array;

/**
 
 */
- (jboolean)addAllWithJavaUtilCollection:(id<JavaUtilCollection>)collection;

/**
 
 */
- (jboolean)addAllWithGnuTroveTIntCollection:(id<GnuTroveTIntCollection>)collection;

/**
 
 */
- (jboolean)addAllWithIntArray:(IOSIntArray *)array;

/**
 
 */
- (jboolean)retainAllWithJavaUtilCollection:(id<JavaUtilCollection>)collection;

/**
 
 */
- (jboolean)retainAllWithGnuTroveTIntCollection:(id<GnuTroveTIntCollection>)collection;

/**
 
 */
- (jboolean)retainAllWithIntArray:(IOSIntArray *)array;

/**
 
 */
- (jboolean)removeAllWithJavaUtilCollection:(id<JavaUtilCollection>)collection;

/**
 
 */
- (jboolean)removeAllWithGnuTroveTIntCollection:(id<GnuTroveTIntCollection>)collection;

/**
 
 */
- (jboolean)removeAllWithIntArray:(IOSIntArray *)array;

/**
 
 */
- (void)transformValuesWithGnuTroveFunctionTIntFunction:(id<GnuTroveFunctionTIntFunction>)function;

/**
 
 */
- (void)reverse;

/**
 
 */
- (void)reverseWithInt:(jint)from
               withInt:(jint)to;

/**
 
 */
- (void)shuffleWithJavaUtilRandom:(JavaUtilRandom *)rand;

/**
 
 */
- (id<GnuTroveListTIntList>)subListWithInt:(jint)begin
                                   withInt:(jint)end;

/**
 
 */
- (IOSIntArray *)toArray;

/**
 
 */
- (IOSIntArray *)toArrayWithInt:(jint)offset
                        withInt:(jint)len;

/**
 
 */
- (IOSIntArray *)toArrayWithIntArray:(IOSIntArray *)dest;

/**
 
 */
- (IOSIntArray *)toArrayWithIntArray:(IOSIntArray *)dest
                             withInt:(jint)offset
                             withInt:(jint)len;

/**
 
 */
- (IOSIntArray *)toArrayWithIntArray:(IOSIntArray *)dest
                             withInt:(jint)source_pos
                             withInt:(jint)dest_pos
                             withInt:(jint)len;

/**
 
 */
- (jboolean)isEqual:(id)other;

/**
 
 */
- (NSUInteger)hash;

/**
 
 */
- (jboolean)forEachWithGnuTroveProcedureTIntProcedure:(id<GnuTroveProcedureTIntProcedure>)procedure;

/**
 
 */
- (jboolean)forEachDescendingWithGnuTroveProcedureTIntProcedure:(id<GnuTroveProcedureTIntProcedure>)procedure;

/**
 
 */
- (void)sort;

/**
 
 */
- (void)sortWithInt:(jint)fromIndex
            withInt:(jint)toIndex;

/**
 
 */
- (void)fillWithInt:(jint)val;

/**
 
 */
- (void)fillWithInt:(jint)fromIndex
            withInt:(jint)toIndex
            withInt:(jint)val;

/**
 
 */
- (jint)binarySearchWithInt:(jint)value;

/**
 
 */
- (jint)binarySearchWithInt:(jint)value
                    withInt:(jint)fromIndex
                    withInt:(jint)toIndex;

/**
 
 */
- (jint)indexOfWithInt:(jint)value;

/**
 
 */
- (jint)indexOfWithInt:(jint)offset
               withInt:(jint)value;

/**
 
 */
- (jint)lastIndexOfWithInt:(jint)value;

/**
 
 */
- (jint)lastIndexOfWithInt:(jint)offset
                   withInt:(jint)value;

/**
 
 */
- (jboolean)containsWithInt:(jint)value;

/**
 
 */
- (id<GnuTroveListTIntList>)grepWithGnuTroveProcedureTIntProcedure:(id<GnuTroveProcedureTIntProcedure>)condition;

/**
 
 */
- (id<GnuTroveListTIntList>)inverseGrepWithGnuTroveProcedureTIntProcedure:(id<GnuTroveProcedureTIntProcedure>)condition;

/**
 
 */
- (jint)max;

/**
 
 */
- (jint)min;

/**
 
 */
- (jint)sum;

/**
 
 */
- (NSString *)description;

- (void)writeExternalWithJavaIoObjectOutput:(id<JavaIoObjectOutput>)outArg;

- (void)readExternalWithJavaIoObjectInput:(id<JavaIoObjectInput>)inArg;

@end

J2OBJC_EMPTY_STATIC_INIT(GnuTroveListArrayTIntArrayList)

J2OBJC_FIELD_SETTER(GnuTroveListArrayTIntArrayList, _data_, IOSIntArray *)

CF_EXTERN_C_BEGIN

FOUNDATION_EXPORT GnuTroveListArrayTIntArrayList *GnuTroveListArrayTIntArrayList_wrapWithIntArray_(IOSIntArray *values);

FOUNDATION_EXPORT GnuTroveListArrayTIntArrayList *GnuTroveListArrayTIntArrayList_wrapWithIntArray_withInt_(IOSIntArray *values, jint no_entry_value);

J2OBJC_STATIC_FIELD_GETTER(GnuTroveListArrayTIntArrayList, serialVersionUID, jlong)

J2OBJC_STATIC_FIELD_GETTER(GnuTroveListArrayTIntArrayList, DEFAULT_CAPACITY, jint)
CF_EXTERN_C_END

J2OBJC_TYPE_LITERAL_HEADER(GnuTroveListArrayTIntArrayList)

@interface GnuTroveListArrayTIntArrayList_$1 : GnuTroveListArrayTIntArrayList {
}

/**
 @brief Growing the wrapped external array is not allow
 */
- (void)ensureCapacityWithInt:(jint)capacity;

- (instancetype)initWithIntArray:(IOSIntArray *)arg$0
                         withInt:(jint)arg$1
                     withBoolean:(jboolean)arg$2;

@end

J2OBJC_EMPTY_STATIC_INIT(GnuTroveListArrayTIntArrayList_$1)

CF_EXTERN_C_BEGIN
CF_EXTERN_C_END

J2OBJC_TYPE_LITERAL_HEADER(GnuTroveListArrayTIntArrayList_$1)

#endif // _GnuTroveListArrayTIntArrayList_H_
