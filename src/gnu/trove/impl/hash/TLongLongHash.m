//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: dependencies/trove/src/gnu/trove/impl/hash/TLongLongHash.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "gnu/trove/impl/HashFunctions.h"
#include "gnu/trove/impl/hash/TLongLongHash.h"
#include "gnu/trove/impl/hash/TPrimitiveHash.h"
#include "gnu/trove/procedure/TLongProcedure.h"
#include "java/io/IOException.h"
#include "java/io/ObjectInput.h"
#include "java/io/ObjectOutput.h"
#include "java/lang/ClassNotFoundException.h"
#include "java/lang/IllegalStateException.h"

@implementation GnuTroveImplHashTLongLongHash

- (instancetype)init {
  if (self = [super init]) {
    no_entry_key_ = (jlong) 0;
    no_entry_value_ = (jlong) 0;
  }
  return self;
}

- (instancetype)initWithInt:(jint)initialCapacity {
  if (self = [super initWithInt:initialCapacity]) {
    no_entry_key_ = (jlong) 0;
    no_entry_value_ = (jlong) 0;
  }
  return self;
}

- (instancetype)initWithInt:(jint)initialCapacity
                  withFloat:(jfloat)loadFactor {
  if (self = [super initWithInt:initialCapacity withFloat:loadFactor]) {
    no_entry_key_ = (jlong) 0;
    no_entry_value_ = (jlong) 0;
  }
  return self;
}

- (instancetype)initWithInt:(jint)initialCapacity
                  withFloat:(jfloat)loadFactor
                   withLong:(jlong)no_entry_key
                   withLong:(jlong)no_entry_value {
  if (self = [super initWithInt:initialCapacity withFloat:loadFactor]) {
    self->no_entry_key_ = no_entry_key;
    self->no_entry_value_ = no_entry_value;
  }
  return self;
}

- (jlong)getNoEntryKey {
  return no_entry_key_;
}

- (jlong)getNoEntryValue {
  return no_entry_value_;
}

- (jint)setUpWithInt:(jint)initialCapacity {
  jint capacity;
  capacity = [super setUpWithInt:initialCapacity];
  GnuTroveImplHashTLongLongHash_setAndConsume__set_(self, [IOSLongArray newArrayWithLength:capacity]);
  return capacity;
}

- (jboolean)containsWithLong:(jlong)val {
  return [self indexWithLong:val] >= 0;
}

- (jboolean)forEachWithGnuTroveProcedureTLongProcedure:(id<GnuTroveProcedureTLongProcedure>)procedure {
  IOSByteArray *states = _states_;
  IOSLongArray *set = _set_;
  for (jint i = ((IOSLongArray *) nil_chk(set))->size_; i-- > 0; ) {
    if (IOSByteArray_Get(nil_chk(states), i) == GnuTroveImplHashTPrimitiveHash_FULL && ![((id<GnuTroveProcedureTLongProcedure>) nil_chk(procedure)) executeWithLong:IOSLongArray_Get(set, i)]) {
      return NO;
    }
  }
  return YES;
}

- (void)removeAtWithInt:(jint)index {
  *IOSLongArray_GetRef(nil_chk(_set_), index) = no_entry_key_;
  [super removeAtWithInt:index];
}

- (jint)indexWithLong:(jlong)key {
  jint hash_, probe, index, length;
  IOSByteArray *states = _states_;
  IOSLongArray *set = _set_;
  length = ((IOSByteArray *) nil_chk(states))->size_;
  hash_ = GnuTroveImplHashFunctions_hash__WithLong_(key) & (jint) 0x7fffffff;
  index = hash_ % length;
  jbyte state = IOSByteArray_Get(states, index);
  if (state == GnuTroveImplHashTPrimitiveHash_FREE) return -1;
  if (state == GnuTroveImplHashTPrimitiveHash_FULL && IOSLongArray_Get(nil_chk(set), index) == key) return index;
  return [self indexRehashedWithLong:key withInt:index withInt:hash_ withByte:state];
}

- (jint)indexRehashedWithLong:(jlong)key
                      withInt:(jint)index
                      withInt:(jint)hash_
                     withByte:(jbyte)state {
  jint length = ((IOSLongArray *) nil_chk(_set_))->size_;
  jint probe = 1 + (hash_ % (length - 2));
  jint loopIndex = index;
  do {
    index -= probe;
    if (index < 0) {
      index += length;
    }
    state = IOSByteArray_Get(nil_chk(_states_), index);
    if (state == GnuTroveImplHashTPrimitiveHash_FREE) return -1;
    if (key == IOSLongArray_Get(_set_, index) && state != GnuTroveImplHashTPrimitiveHash_REMOVED) return index;
  }
  while (index != loopIndex);
  return -1;
}

- (jint)insertKeyWithLong:(jlong)val {
  jint hash_, index;
  hash_ = GnuTroveImplHashFunctions_hash__WithLong_(val) & (jint) 0x7fffffff;
  index = hash_ % ((IOSByteArray *) nil_chk(_states_))->size_;
  jbyte state = IOSByteArray_Get(_states_, index);
  consumeFreeSlot_ = NO;
  if (state == GnuTroveImplHashTPrimitiveHash_FREE) {
    consumeFreeSlot_ = YES;
    [self insertKeyAtWithInt:index withLong:val];
    return index;
  }
  if (state == GnuTroveImplHashTPrimitiveHash_FULL && IOSLongArray_Get(nil_chk(_set_), index) == val) {
    return -index - 1;
  }
  return [self insertKeyRehashWithLong:val withInt:index withInt:hash_ withByte:state];
}

- (jint)insertKeyRehashWithLong:(jlong)val
                        withInt:(jint)index
                        withInt:(jint)hash_
                       withByte:(jbyte)state {
  jint length = ((IOSLongArray *) nil_chk(_set_))->size_;
  jint probe = 1 + (hash_ % (length - 2));
  jint loopIndex = index;
  jint firstRemoved = -1;
  do {
    if (state == GnuTroveImplHashTPrimitiveHash_REMOVED && firstRemoved == -1) firstRemoved = index;
    index -= probe;
    if (index < 0) {
      index += length;
    }
    state = IOSByteArray_Get(nil_chk(_states_), index);
    if (state == GnuTroveImplHashTPrimitiveHash_FREE) {
      if (firstRemoved != -1) {
        [self insertKeyAtWithInt:firstRemoved withLong:val];
        return firstRemoved;
      }
      else {
        consumeFreeSlot_ = YES;
        [self insertKeyAtWithInt:index withLong:val];
        return index;
      }
    }
    if (state == GnuTroveImplHashTPrimitiveHash_FULL && IOSLongArray_Get(_set_, index) == val) {
      return -index - 1;
    }
  }
  while (index != loopIndex);
  if (firstRemoved != -1) {
    [self insertKeyAtWithInt:firstRemoved withLong:val];
    return firstRemoved;
  }
  @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"No free or removed slots available. Key set full?!!"] autorelease];
}

- (void)insertKeyAtWithInt:(jint)index
                  withLong:(jlong)val {
  *IOSLongArray_GetRef(nil_chk(_set_), index) = val;
  *IOSByteArray_GetRef(nil_chk(_states_), index) = GnuTroveImplHashTPrimitiveHash_FULL;
}

- (jint)XinsertKeyWithLong:(jlong)key {
  jint hash_, probe, index, length;
  IOSByteArray *states = _states_;
  IOSLongArray *set = _set_;
  length = ((IOSByteArray *) nil_chk(states))->size_;
  hash_ = GnuTroveImplHashFunctions_hash__WithLong_(key) & (jint) 0x7fffffff;
  index = hash_ % length;
  jbyte state = IOSByteArray_Get(states, index);
  consumeFreeSlot_ = NO;
  if (state == GnuTroveImplHashTPrimitiveHash_FREE) {
    consumeFreeSlot_ = YES;
    *IOSLongArray_GetRef(nil_chk(set), index) = key;
    *IOSByteArray_GetRef(states, index) = GnuTroveImplHashTPrimitiveHash_FULL;
    return index;
  }
  else if (state == GnuTroveImplHashTPrimitiveHash_FULL && IOSLongArray_Get(nil_chk(set), index) == key) {
    return -index - 1;
  }
  else {
    probe = 1 + (hash_ % (length - 2));
    if (state != GnuTroveImplHashTPrimitiveHash_REMOVED) {
      do {
        index -= probe;
        if (index < 0) {
          index += length;
        }
        state = IOSByteArray_Get(states, index);
      }
      while (state == GnuTroveImplHashTPrimitiveHash_FULL && IOSLongArray_Get(nil_chk(set), index) != key);
    }
    if (state == GnuTroveImplHashTPrimitiveHash_REMOVED) {
      jint firstRemoved = index;
      while (state != GnuTroveImplHashTPrimitiveHash_FREE && (state == GnuTroveImplHashTPrimitiveHash_REMOVED || IOSLongArray_Get(nil_chk(set), index) != key)) {
        index -= probe;
        if (index < 0) {
          index += length;
        }
        state = IOSByteArray_Get(states, index);
      }
      if (state == GnuTroveImplHashTPrimitiveHash_FULL) {
        return -index - 1;
      }
      else {
        *IOSLongArray_GetRef(nil_chk(set), index) = key;
        *IOSByteArray_GetRef(states, index) = GnuTroveImplHashTPrimitiveHash_FULL;
        return firstRemoved;
      }
    }
    if (state == GnuTroveImplHashTPrimitiveHash_FULL) {
      return -index - 1;
    }
    else {
      consumeFreeSlot_ = YES;
      *IOSLongArray_GetRef(nil_chk(set), index) = key;
      *IOSByteArray_GetRef(states, index) = GnuTroveImplHashTPrimitiveHash_FULL;
      return index;
    }
  }
}

- (void)writeExternalWithJavaIoObjectOutput:(id<JavaIoObjectOutput>)outArg {
  [((id<JavaIoObjectOutput>) nil_chk(outArg)) writeByteWithInt:0];
  [super writeExternalWithJavaIoObjectOutput:outArg];
  [outArg writeLongWithLong:no_entry_key_];
  [outArg writeLongWithLong:no_entry_value_];
}

- (void)readExternalWithJavaIoObjectInput:(id<JavaIoObjectInput>)inArg {
  [((id<JavaIoObjectInput>) nil_chk(inArg)) readByte];
  [super readExternalWithJavaIoObjectInput:inArg];
  no_entry_key_ = [inArg readLong];
  no_entry_value_ = [inArg readLong];
}

- (void)dealloc {
  RELEASE_(_set_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(GnuTroveImplHashTLongLongHash *)other {
  [super copyAllFieldsTo:other];
  GnuTroveImplHashTLongLongHash_set__set_(other, _set_);
  other->no_entry_key_ = no_entry_key_;
  other->no_entry_value_ = no_entry_value_;
  other->consumeFreeSlot_ = consumeFreeSlot_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "TLongLongHash", NULL, 0x1, NULL },
    { "initWithInt:", "TLongLongHash", NULL, 0x1, NULL },
    { "initWithInt:withFloat:", "TLongLongHash", NULL, 0x1, NULL },
    { "initWithInt:withFloat:withLong:withLong:", "TLongLongHash", NULL, 0x1, NULL },
    { "getNoEntryKey", NULL, "J", 0x1, NULL },
    { "getNoEntryValue", NULL, "J", 0x1, NULL },
    { "setUpWithInt:", "setUp", "I", 0x4, NULL },
    { "containsWithLong:", "contains", "Z", 0x1, NULL },
    { "forEachWithGnuTroveProcedureTLongProcedure:", "forEach", "Z", 0x1, NULL },
    { "removeAtWithInt:", "removeAt", "V", 0x4, NULL },
    { "indexWithLong:", "index", "I", 0x4, NULL },
    { "indexRehashedWithLong:withInt:withInt:withByte:", "indexRehashed", "I", 0x0, NULL },
    { "insertKeyWithLong:", "insertKey", "I", 0x4, NULL },
    { "insertKeyRehashWithLong:withInt:withInt:withByte:", "insertKeyRehash", "I", 0x0, NULL },
    { "insertKeyAtWithInt:withLong:", "insertKeyAt", "V", 0x0, NULL },
    { "XinsertKeyWithLong:", "XinsertKey", "I", 0x4, NULL },
    { "writeExternalWithJavaIoObjectOutput:", "writeExternal", "V", 0x1, "Ljava.io.IOException;" },
    { "readExternalWithJavaIoObjectInput:", "readExternal", "V", 0x1, "Ljava.io.IOException;Ljava.lang.ClassNotFoundException;" },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID_", NULL, 0x18, "J", NULL, .constantValue.asLong = GnuTroveImplHashTLongLongHash_serialVersionUID },
    { "_set_", NULL, 0x81, "[J", NULL,  },
    { "no_entry_key_", NULL, 0x4, "J", NULL,  },
    { "no_entry_value_", NULL, 0x4, "J", NULL,  },
    { "consumeFreeSlot_", NULL, 0x4, "Z", NULL,  },
  };
  static const J2ObjcClassInfo _GnuTroveImplHashTLongLongHash = { 1, "TLongLongHash", "gnu.trove.impl.hash", NULL, 0x401, 18, methods, 5, fields, 0, NULL};
  return &_GnuTroveImplHashTLongLongHash;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GnuTroveImplHashTLongLongHash)
