//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: dependencies/trove/src/gnu/trove/impl/hash/TIntIntHash.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "gnu/trove/impl/HashFunctions.h"
#include "gnu/trove/impl/hash/TIntIntHash.h"
#include "gnu/trove/impl/hash/TPrimitiveHash.h"
#include "gnu/trove/procedure/TIntProcedure.h"
#include "java/io/IOException.h"
#include "java/io/ObjectInput.h"
#include "java/io/ObjectOutput.h"
#include "java/lang/ClassNotFoundException.h"
#include "java/lang/IllegalStateException.h"

@implementation GnuTroveImplHashTIntIntHash

- (instancetype)init {
  if (self = [super init]) {
    no_entry_key_ = (jint) 0;
    no_entry_value_ = (jint) 0;
  }
  return self;
}

- (instancetype)initWithInt:(jint)initialCapacity {
  if (self = [super initWithInt:initialCapacity]) {
    no_entry_key_ = (jint) 0;
    no_entry_value_ = (jint) 0;
  }
  return self;
}

- (instancetype)initWithInt:(jint)initialCapacity
                  withFloat:(jfloat)loadFactor {
  if (self = [super initWithInt:initialCapacity withFloat:loadFactor]) {
    no_entry_key_ = (jint) 0;
    no_entry_value_ = (jint) 0;
  }
  return self;
}

- (instancetype)initWithInt:(jint)initialCapacity
                  withFloat:(jfloat)loadFactor
                    withInt:(jint)no_entry_key
                    withInt:(jint)no_entry_value {
  if (self = [super initWithInt:initialCapacity withFloat:loadFactor]) {
    self->no_entry_key_ = no_entry_key;
    self->no_entry_value_ = no_entry_value;
  }
  return self;
}

- (jint)getNoEntryKey {
  return no_entry_key_;
}

- (jint)getNoEntryValue {
  return no_entry_value_;
}

- (jint)setUpWithInt:(jint)initialCapacity {
  jint capacity;
  capacity = [super setUpWithInt:initialCapacity];
  GnuTroveImplHashTIntIntHash_setAndConsume__set_(self, [IOSIntArray newArrayWithLength:capacity]);
  return capacity;
}

- (jboolean)containsWithInt:(jint)val {
  return [self indexWithInt:val] >= 0;
}

- (jboolean)forEachWithGnuTroveProcedureTIntProcedure:(id<GnuTroveProcedureTIntProcedure>)procedure {
  IOSByteArray *states = _states_;
  IOSIntArray *set = _set_;
  for (jint i = ((IOSIntArray *) nil_chk(set))->size_; i-- > 0; ) {
    if (IOSByteArray_Get(nil_chk(states), i) == GnuTroveImplHashTPrimitiveHash_FULL && ![((id<GnuTroveProcedureTIntProcedure>) nil_chk(procedure)) executeWithInt:IOSIntArray_Get(set, i)]) {
      return NO;
    }
  }
  return YES;
}

- (void)removeAtWithInt:(jint)index {
  *IOSIntArray_GetRef(nil_chk(_set_), index) = no_entry_key_;
  [super removeAtWithInt:index];
}

- (jint)indexWithInt:(jint)key {
  jint hash_, probe, index, length;
  IOSByteArray *states = _states_;
  IOSIntArray *set = _set_;
  length = ((IOSByteArray *) nil_chk(states))->size_;
  hash_ = GnuTroveImplHashFunctions_hash__WithInt_(key) & (jint) 0x7fffffff;
  index = hash_ % length;
  jbyte state = IOSByteArray_Get(states, index);
  if (state == GnuTroveImplHashTPrimitiveHash_FREE) return -1;
  if (state == GnuTroveImplHashTPrimitiveHash_FULL && IOSIntArray_Get(nil_chk(set), index) == key) return index;
  return [self indexRehashedWithInt:key withInt:index withInt:hash_ withByte:state];
}

- (jint)indexRehashedWithInt:(jint)key
                     withInt:(jint)index
                     withInt:(jint)hash_
                    withByte:(jbyte)state {
  jint length = ((IOSIntArray *) nil_chk(_set_))->size_;
  jint probe = 1 + (hash_ % (length - 2));
  jint loopIndex = index;
  do {
    index -= probe;
    if (index < 0) {
      index += length;
    }
    state = IOSByteArray_Get(nil_chk(_states_), index);
    if (state == GnuTroveImplHashTPrimitiveHash_FREE) return -1;
    if (key == IOSIntArray_Get(_set_, index) && state != GnuTroveImplHashTPrimitiveHash_REMOVED) return index;
  }
  while (index != loopIndex);
  return -1;
}

- (jint)insertKeyWithInt:(jint)val {
  jint hash_, index;
  hash_ = GnuTroveImplHashFunctions_hash__WithInt_(val) & (jint) 0x7fffffff;
  index = hash_ % ((IOSByteArray *) nil_chk(_states_))->size_;
  jbyte state = IOSByteArray_Get(_states_, index);
  consumeFreeSlot_ = NO;
  if (state == GnuTroveImplHashTPrimitiveHash_FREE) {
    consumeFreeSlot_ = YES;
    [self insertKeyAtWithInt:index withInt:val];
    return index;
  }
  if (state == GnuTroveImplHashTPrimitiveHash_FULL && IOSIntArray_Get(nil_chk(_set_), index) == val) {
    return -index - 1;
  }
  return [self insertKeyRehashWithInt:val withInt:index withInt:hash_ withByte:state];
}

- (jint)insertKeyRehashWithInt:(jint)val
                       withInt:(jint)index
                       withInt:(jint)hash_
                      withByte:(jbyte)state {
  jint length = ((IOSIntArray *) nil_chk(_set_))->size_;
  jint probe = 1 + (hash_ % (length - 2));
  jint loopIndex = index;
  jint firstRemoved = -1;
  do {
    if (state == GnuTroveImplHashTPrimitiveHash_REMOVED && firstRemoved == -1) firstRemoved = index;
    index -= probe;
    if (index < 0) {
      index += length;
    }
    state = IOSByteArray_Get(nil_chk(_states_), index);
    if (state == GnuTroveImplHashTPrimitiveHash_FREE) {
      if (firstRemoved != -1) {
        [self insertKeyAtWithInt:firstRemoved withInt:val];
        return firstRemoved;
      }
      else {
        consumeFreeSlot_ = YES;
        [self insertKeyAtWithInt:index withInt:val];
        return index;
      }
    }
    if (state == GnuTroveImplHashTPrimitiveHash_FULL && IOSIntArray_Get(_set_, index) == val) {
      return -index - 1;
    }
  }
  while (index != loopIndex);
  if (firstRemoved != -1) {
    [self insertKeyAtWithInt:firstRemoved withInt:val];
    return firstRemoved;
  }
  @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"No free or removed slots available. Key set full?!!"] autorelease];
}

- (void)insertKeyAtWithInt:(jint)index
                   withInt:(jint)val {
  *IOSIntArray_GetRef(nil_chk(_set_), index) = val;
  *IOSByteArray_GetRef(nil_chk(_states_), index) = GnuTroveImplHashTPrimitiveHash_FULL;
}

- (jint)XinsertKeyWithInt:(jint)key {
  jint hash_, probe, index, length;
  IOSByteArray *states = _states_;
  IOSIntArray *set = _set_;
  length = ((IOSByteArray *) nil_chk(states))->size_;
  hash_ = GnuTroveImplHashFunctions_hash__WithInt_(key) & (jint) 0x7fffffff;
  index = hash_ % length;
  jbyte state = IOSByteArray_Get(states, index);
  consumeFreeSlot_ = NO;
  if (state == GnuTroveImplHashTPrimitiveHash_FREE) {
    consumeFreeSlot_ = YES;
    *IOSIntArray_GetRef(nil_chk(set), index) = key;
    *IOSByteArray_GetRef(states, index) = GnuTroveImplHashTPrimitiveHash_FULL;
    return index;
  }
  else if (state == GnuTroveImplHashTPrimitiveHash_FULL && IOSIntArray_Get(nil_chk(set), index) == key) {
    return -index - 1;
  }
  else {
    probe = 1 + (hash_ % (length - 2));
    if (state != GnuTroveImplHashTPrimitiveHash_REMOVED) {
      do {
        index -= probe;
        if (index < 0) {
          index += length;
        }
        state = IOSByteArray_Get(states, index);
      }
      while (state == GnuTroveImplHashTPrimitiveHash_FULL && IOSIntArray_Get(nil_chk(set), index) != key);
    }
    if (state == GnuTroveImplHashTPrimitiveHash_REMOVED) {
      jint firstRemoved = index;
      while (state != GnuTroveImplHashTPrimitiveHash_FREE && (state == GnuTroveImplHashTPrimitiveHash_REMOVED || IOSIntArray_Get(nil_chk(set), index) != key)) {
        index -= probe;
        if (index < 0) {
          index += length;
        }
        state = IOSByteArray_Get(states, index);
      }
      if (state == GnuTroveImplHashTPrimitiveHash_FULL) {
        return -index - 1;
      }
      else {
        *IOSIntArray_GetRef(nil_chk(set), index) = key;
        *IOSByteArray_GetRef(states, index) = GnuTroveImplHashTPrimitiveHash_FULL;
        return firstRemoved;
      }
    }
    if (state == GnuTroveImplHashTPrimitiveHash_FULL) {
      return -index - 1;
    }
    else {
      consumeFreeSlot_ = YES;
      *IOSIntArray_GetRef(nil_chk(set), index) = key;
      *IOSByteArray_GetRef(states, index) = GnuTroveImplHashTPrimitiveHash_FULL;
      return index;
    }
  }
}

- (void)writeExternalWithJavaIoObjectOutput:(id<JavaIoObjectOutput>)outArg {
  [((id<JavaIoObjectOutput>) nil_chk(outArg)) writeByteWithInt:0];
  [super writeExternalWithJavaIoObjectOutput:outArg];
  [outArg writeIntWithInt:no_entry_key_];
  [outArg writeIntWithInt:no_entry_value_];
}

- (void)readExternalWithJavaIoObjectInput:(id<JavaIoObjectInput>)inArg {
  [((id<JavaIoObjectInput>) nil_chk(inArg)) readByte];
  [super readExternalWithJavaIoObjectInput:inArg];
  no_entry_key_ = [inArg readInt];
  no_entry_value_ = [inArg readInt];
}

- (void)dealloc {
  RELEASE_(_set_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(GnuTroveImplHashTIntIntHash *)other {
  [super copyAllFieldsTo:other];
  GnuTroveImplHashTIntIntHash_set__set_(other, _set_);
  other->no_entry_key_ = no_entry_key_;
  other->no_entry_value_ = no_entry_value_;
  other->consumeFreeSlot_ = consumeFreeSlot_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "TIntIntHash", NULL, 0x1, NULL },
    { "initWithInt:", "TIntIntHash", NULL, 0x1, NULL },
    { "initWithInt:withFloat:", "TIntIntHash", NULL, 0x1, NULL },
    { "initWithInt:withFloat:withInt:withInt:", "TIntIntHash", NULL, 0x1, NULL },
    { "getNoEntryKey", NULL, "I", 0x1, NULL },
    { "getNoEntryValue", NULL, "I", 0x1, NULL },
    { "setUpWithInt:", "setUp", "I", 0x4, NULL },
    { "containsWithInt:", "contains", "Z", 0x1, NULL },
    { "forEachWithGnuTroveProcedureTIntProcedure:", "forEach", "Z", 0x1, NULL },
    { "removeAtWithInt:", "removeAt", "V", 0x4, NULL },
    { "indexWithInt:", "index", "I", 0x4, NULL },
    { "indexRehashedWithInt:withInt:withInt:withByte:", "indexRehashed", "I", 0x0, NULL },
    { "insertKeyWithInt:", "insertKey", "I", 0x4, NULL },
    { "insertKeyRehashWithInt:withInt:withInt:withByte:", "insertKeyRehash", "I", 0x0, NULL },
    { "insertKeyAtWithInt:withInt:", "insertKeyAt", "V", 0x0, NULL },
    { "XinsertKeyWithInt:", "XinsertKey", "I", 0x4, NULL },
    { "writeExternalWithJavaIoObjectOutput:", "writeExternal", "V", 0x1, "Ljava.io.IOException;" },
    { "readExternalWithJavaIoObjectInput:", "readExternal", "V", 0x1, "Ljava.io.IOException;Ljava.lang.ClassNotFoundException;" },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID_", NULL, 0x18, "J", NULL, .constantValue.asLong = GnuTroveImplHashTIntIntHash_serialVersionUID },
    { "_set_", NULL, 0x81, "[I", NULL,  },
    { "no_entry_key_", NULL, 0x4, "I", NULL,  },
    { "no_entry_value_", NULL, 0x4, "I", NULL,  },
    { "consumeFreeSlot_", NULL, 0x4, "Z", NULL,  },
  };
  static const J2ObjcClassInfo _GnuTroveImplHashTIntIntHash = { 1, "TIntIntHash", "gnu.trove.impl.hash", NULL, 0x401, 18, methods, 5, fields, 0, NULL};
  return &_GnuTroveImplHashTIntIntHash;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GnuTroveImplHashTIntIntHash)
