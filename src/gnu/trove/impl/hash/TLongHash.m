//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: dependencies/trove/src/gnu/trove/impl/hash/TLongHash.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "gnu/trove/impl/Constants.h"
#include "gnu/trove/impl/HashFunctions.h"
#include "gnu/trove/impl/hash/TLongHash.h"
#include "gnu/trove/impl/hash/TPrimitiveHash.h"
#include "gnu/trove/procedure/TLongProcedure.h"
#include "java/lang/IllegalStateException.h"
#include "java/util/Arrays.h"

@implementation GnuTroveImplHashTLongHash

- (instancetype)init {
  if (self = [super init]) {
    no_entry_value_ = GnuTroveImplConstants_get_DEFAULT_LONG_NO_ENTRY_VALUE_();
    if (no_entry_value_ != (jlong) 0) {
      JavaUtilArrays_fillWithLongArray_withLong_(_set_, no_entry_value_);
    }
  }
  return self;
}

- (instancetype)initWithInt:(jint)initialCapacity {
  if (self = [super initWithInt:initialCapacity]) {
    no_entry_value_ = GnuTroveImplConstants_get_DEFAULT_LONG_NO_ENTRY_VALUE_();
    if (no_entry_value_ != (jlong) 0) {
      JavaUtilArrays_fillWithLongArray_withLong_(_set_, no_entry_value_);
    }
  }
  return self;
}

- (instancetype)initWithInt:(jint)initialCapacity
                  withFloat:(jfloat)loadFactor {
  if (self = [super initWithInt:initialCapacity withFloat:loadFactor]) {
    no_entry_value_ = GnuTroveImplConstants_get_DEFAULT_LONG_NO_ENTRY_VALUE_();
    if (no_entry_value_ != (jlong) 0) {
      JavaUtilArrays_fillWithLongArray_withLong_(_set_, no_entry_value_);
    }
  }
  return self;
}

- (instancetype)initWithInt:(jint)initialCapacity
                  withFloat:(jfloat)loadFactor
                   withLong:(jlong)no_entry_value {
  if (self = [super initWithInt:initialCapacity withFloat:loadFactor]) {
    self->no_entry_value_ = no_entry_value;
    if (no_entry_value != (jlong) 0) {
      JavaUtilArrays_fillWithLongArray_withLong_(_set_, no_entry_value);
    }
  }
  return self;
}

- (jlong)getNoEntryValue {
  return no_entry_value_;
}

- (jint)setUpWithInt:(jint)initialCapacity {
  jint capacity;
  capacity = [super setUpWithInt:initialCapacity];
  GnuTroveImplHashTLongHash_setAndConsume__set_(self, [IOSLongArray newArrayWithLength:capacity]);
  return capacity;
}

- (jboolean)containsWithLong:(jlong)val {
  return [self indexWithLong:val] >= 0;
}

- (jboolean)forEachWithGnuTroveProcedureTLongProcedure:(id<GnuTroveProcedureTLongProcedure>)procedure {
  IOSByteArray *states = _states_;
  IOSLongArray *set = _set_;
  for (jint i = ((IOSLongArray *) nil_chk(set))->size_; i-- > 0; ) {
    if (IOSByteArray_Get(nil_chk(states), i) == GnuTroveImplHashTPrimitiveHash_FULL && ![((id<GnuTroveProcedureTLongProcedure>) nil_chk(procedure)) executeWithLong:IOSLongArray_Get(set, i)]) {
      return NO;
    }
  }
  return YES;
}

- (void)removeAtWithInt:(jint)index {
  *IOSLongArray_GetRef(nil_chk(_set_), index) = no_entry_value_;
  [super removeAtWithInt:index];
}

- (jint)indexWithLong:(jlong)val {
  jint hash_, probe, index, length;
  IOSByteArray *states = _states_;
  IOSLongArray *set = _set_;
  length = ((IOSByteArray *) nil_chk(states))->size_;
  hash_ = GnuTroveImplHashFunctions_hash__WithLong_(val) & (jint) 0x7fffffff;
  index = hash_ % length;
  jbyte state = IOSByteArray_Get(states, index);
  if (state == GnuTroveImplHashTPrimitiveHash_FREE) return -1;
  if (state == GnuTroveImplHashTPrimitiveHash_FULL && IOSLongArray_Get(nil_chk(set), index) == val) return index;
  return [self indexRehashedWithLong:val withInt:index withInt:hash_ withByte:state];
}

- (jint)indexRehashedWithLong:(jlong)key
                      withInt:(jint)index
                      withInt:(jint)hash_
                     withByte:(jbyte)state {
  jint length = ((IOSLongArray *) nil_chk(_set_))->size_;
  jint probe = 1 + (hash_ % (length - 2));
  jint loopIndex = index;
  do {
    index -= probe;
    if (index < 0) {
      index += length;
    }
    state = IOSByteArray_Get(nil_chk(_states_), index);
    if (state == GnuTroveImplHashTPrimitiveHash_FREE) return -1;
    if (key == IOSLongArray_Get(_set_, index) && state != GnuTroveImplHashTPrimitiveHash_REMOVED) return index;
  }
  while (index != loopIndex);
  return -1;
}

- (jint)insertKeyWithLong:(jlong)val {
  jint hash_, index;
  hash_ = GnuTroveImplHashFunctions_hash__WithLong_(val) & (jint) 0x7fffffff;
  index = hash_ % ((IOSByteArray *) nil_chk(_states_))->size_;
  jbyte state = IOSByteArray_Get(_states_, index);
  consumeFreeSlot_ = NO;
  if (state == GnuTroveImplHashTPrimitiveHash_FREE) {
    consumeFreeSlot_ = YES;
    [self insertKeyAtWithInt:index withLong:val];
    return index;
  }
  if (state == GnuTroveImplHashTPrimitiveHash_FULL && IOSLongArray_Get(nil_chk(_set_), index) == val) {
    return -index - 1;
  }
  return [self insertKeyRehashWithLong:val withInt:index withInt:hash_ withByte:state];
}

- (jint)insertKeyRehashWithLong:(jlong)val
                        withInt:(jint)index
                        withInt:(jint)hash_
                       withByte:(jbyte)state {
  jint length = ((IOSLongArray *) nil_chk(_set_))->size_;
  jint probe = 1 + (hash_ % (length - 2));
  jint loopIndex = index;
  jint firstRemoved = -1;
  do {
    if (state == GnuTroveImplHashTPrimitiveHash_REMOVED && firstRemoved == -1) firstRemoved = index;
    index -= probe;
    if (index < 0) {
      index += length;
    }
    state = IOSByteArray_Get(nil_chk(_states_), index);
    if (state == GnuTroveImplHashTPrimitiveHash_FREE) {
      if (firstRemoved != -1) {
        [self insertKeyAtWithInt:firstRemoved withLong:val];
        return firstRemoved;
      }
      else {
        consumeFreeSlot_ = YES;
        [self insertKeyAtWithInt:index withLong:val];
        return index;
      }
    }
    if (state == GnuTroveImplHashTPrimitiveHash_FULL && IOSLongArray_Get(_set_, index) == val) {
      return -index - 1;
    }
  }
  while (index != loopIndex);
  if (firstRemoved != -1) {
    [self insertKeyAtWithInt:firstRemoved withLong:val];
    return firstRemoved;
  }
  @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"No free or removed slots available. Key set full?!!"] autorelease];
}

- (void)insertKeyAtWithInt:(jint)index
                  withLong:(jlong)val {
  *IOSLongArray_GetRef(nil_chk(_set_), index) = val;
  *IOSByteArray_GetRef(nil_chk(_states_), index) = GnuTroveImplHashTPrimitiveHash_FULL;
}

- (void)dealloc {
  RELEASE_(_set_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(GnuTroveImplHashTLongHash *)other {
  [super copyAllFieldsTo:other];
  GnuTroveImplHashTLongHash_set__set_(other, _set_);
  other->no_entry_value_ = no_entry_value_;
  other->consumeFreeSlot_ = consumeFreeSlot_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "TLongHash", NULL, 0x1, NULL },
    { "initWithInt:", "TLongHash", NULL, 0x1, NULL },
    { "initWithInt:withFloat:", "TLongHash", NULL, 0x1, NULL },
    { "initWithInt:withFloat:withLong:", "TLongHash", NULL, 0x1, NULL },
    { "getNoEntryValue", NULL, "J", 0x1, NULL },
    { "setUpWithInt:", "setUp", "I", 0x4, NULL },
    { "containsWithLong:", "contains", "Z", 0x1, NULL },
    { "forEachWithGnuTroveProcedureTLongProcedure:", "forEach", "Z", 0x1, NULL },
    { "removeAtWithInt:", "removeAt", "V", 0x4, NULL },
    { "indexWithLong:", "index", "I", 0x4, NULL },
    { "indexRehashedWithLong:withInt:withInt:withByte:", "indexRehashed", "I", 0x0, NULL },
    { "insertKeyWithLong:", "insertKey", "I", 0x4, NULL },
    { "insertKeyRehashWithLong:withInt:withInt:withByte:", "insertKeyRehash", "I", 0x0, NULL },
    { "insertKeyAtWithInt:withLong:", "insertKeyAt", "V", 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID_", NULL, 0x18, "J", NULL, .constantValue.asLong = GnuTroveImplHashTLongHash_serialVersionUID },
    { "_set_", NULL, 0x81, "[J", NULL,  },
    { "no_entry_value_", NULL, 0x4, "J", NULL,  },
    { "consumeFreeSlot_", NULL, 0x4, "Z", NULL,  },
  };
  static const J2ObjcClassInfo _GnuTroveImplHashTLongHash = { 1, "TLongHash", "gnu.trove.impl.hash", NULL, 0x401, 14, methods, 4, fields, 0, NULL};
  return &_GnuTroveImplHashTLongHash;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GnuTroveImplHashTLongHash)
