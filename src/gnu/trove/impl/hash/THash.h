//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: dependencies/trove/src/gnu/trove/impl/hash/THash.java
//

#ifndef _GnuTroveImplHashTHash_H_
#define _GnuTroveImplHashTHash_H_

@protocol JavaIoObjectInput;
@protocol JavaIoObjectOutput;

#include "J2ObjC_header.h"
#include "java/io/Externalizable.h"

#define GnuTroveImplHashTHash_DEFAULT_CAPACITY 10
#define GnuTroveImplHashTHash_DEFAULT_LOAD_FACTOR 0.5f
#define GnuTroveImplHashTHash_serialVersionUID -1792948471915530295LL

/**
 @brief Base class for hashtables that use open addressing to resolve collisions.
 Created: Wed Nov 28 21:11:16 2001
 @author Eric D. Friedman
 @author Rob Eden (auto-compaction)
 @author Jeff Randall
 @version $Id: THash.java,v 1.1.2.4 2010/03/02 00:55:34 robeden Exp $
 */
@interface GnuTroveImplHashTHash : NSObject < JavaIoExternalizable > {
 @public
  /**
   @brief the current number of occupied slots in the hash.
   */
  jint _size_;
  /**
   @brief the current number of free slots in the hash.
   */
  jint _free_;
  /**
   @brief Determines how full the internal table can become before rehashing is required.
   This must be a value in the range: 0.0 < loadFactor < 1.0.  The default value is 0.5, which is about as large as you can get in open addressing without hurting performance.  Cf. Knuth, Volume 3., Chapter 6.
   */
  jfloat _loadFactor_;
  /**
   @brief The maximum number of elements allowed without allocating more space.
   */
  jint _maxSize_;
  /**
   @brief The number of removes that should be performed before an auto-compaction occurs.
   */
  jint _autoCompactRemovesRemaining_;
  /**
   @brief The auto-compaction factor for the table.
   */
  jfloat _autoCompactionFactor_;
  /**
   */
  jboolean _autoCompactTemporaryDisable_;
}

/**
 @brief Creates a new <code>THash</code> instance with the default capacity and load factor.
 */
- (instancetype)init;

/**
 @brief Creates a new <code>THash</code> instance with a prime capacity at or near the specified capacity and with the default load factor.
 @param initialCapacity an <code>int</code> value
 */
- (instancetype)initWithInt:(jint)initialCapacity;

/**
 @brief Creates a new <code>THash</code> instance with a prime capacity at or near the minimum needed to hold <tt>initialCapacity</tt> elements with load factor <tt>loadFactor</tt> without triggering a rehash.
 @param initialCapacity an <code>int</code> value
 @param loadFactor a <code>float</code> value
 */
- (instancetype)initWithInt:(jint)initialCapacity
                  withFloat:(jfloat)loadFactor;

/**
 @brief Tells whether this set is currently holding any elements.
 @return a <code>boolean</code> value
 */
- (jboolean)isEmpty;

/**
 @brief Returns the number of distinct elements in this collection.
 @return an <code>int</code> value
 */
- (jint)size;

/**
 @return the current physical capacity of the hash table.
 */
- (jint)capacity;

/**
 @brief Ensure that this hashtable has sufficient capacity to hold <tt>desiredCapacity<tt> <b>additional</b> elements without requiring a rehash.
 This is a tuning method you can call before doing a large insert.
 @param desiredCapacity an <code>int</code> value
 */
- (void)ensureCapacityWithInt:(jint)desiredCapacity;

/**
 @brief Compresses the hashtable to the minimum prime size (as defined by PrimeFinder) that will hold all of the elements currently in the table.
 If you have done a lot of <tt>remove</tt> operations and plan to do a lot of queries or insertions or iteration, it is a good idea to invoke this method.  Doing so will accomplish two things: <p/> <ol> <li> You'll free memory allocated to the table but no longer needed because of the remove()s.</li> <p/> <li> You'll get better query/insert/iterator performance because there won't be any <tt>REMOVED</tt> slots to skip over when probing for indices in the table.</li> </ol>
 */
- (void)compact;

/**
 @brief The auto-compaction factor controls whether and when a table performs a #compact automatically after a certain number of remove operations.
 If the value is non-zero, the number of removes that need to occur for auto-compaction is the size of table at the time of the previous compaction (or the initial capacity) multiplied by this factor. <p/> Setting this value to zero will disable auto-compaction.
 @param factor a <tt>float</tt> that indicates the auto-compaction factor
 */
- (void)setAutoCompactionFactorWithFloat:(jfloat)factor;

/**
 @return a <<tt>float</tt> that represents the auto-compaction factor.
 */
- (jfloat)getAutoCompactionFactor;

/**
 @brief This simply calls #compact compact .
 It is included for symmetry with other collection classes.  Note that the name of this method is somewhat misleading (which is why we prefer <tt>compact</tt>) as the load factor may require capacity above and beyond the size of this collection.
 */
- (void)trimToSize;

/**
 @brief Delete the record at <tt>index</tt>.
 Reduces the size of the collection by one.
 @param index an <code>int</code> value
 */
- (void)removeAtWithInt:(jint)index;

/**
 @brief Empties the collection.
 */
- (void)clear;

/**
 @brief initializes the hashtable to a prime capacity which is at least <tt>initialCapacity + 1</tt>.
 @param initialCapacity an <code>int</code> value
 @return the actual capacity chosen
 */
- (jint)setUpWithInt:(jint)initialCapacity;

/**
 @brief Rehashes the set.
 @param newCapacity an <code>int</code> value
 */
- (void)rehashWithInt:(jint)newCapacity;

/**
 @brief Temporarily disables auto-compaction.
 MUST be followed by calling #reenableAutoCompaction .
 */
- (void)tempDisableAutoCompaction;

/**
 @brief Re-enable auto-compaction after it was disabled via #tempDisableAutoCompaction() .
 @param check_for_compaction True if compaction should be performed if needed before returning. If false, no compaction will be performed.
 */
- (void)reenableAutoCompactionWithBoolean:(jboolean)check_for_compaction;

/**
 @brief Computes the values of maxSize.
 There will always be at least one free slot required.
 @param capacity an <code>int</code> value
 */
- (void)computeMaxSizeWithInt:(jint)capacity;

/**
 @brief Computes the number of removes that need to happen before the next auto-compaction will occur.
 @param size an <tt>int</tt> that sets the auto-compaction limit.
 */
- (void)computeNextAutoCompactionAmountWithInt:(jint)size;

/**
 @brief After an insert, this hook is called to adjust the size/free values of the set and to perform rehashing if necessary.
 @param usedFreeSlot the slot
 */
- (void)postInsertHookWithBoolean:(jboolean)usedFreeSlot;

- (jint)calculateGrownCapacity;

- (void)writeExternalWithJavaIoObjectOutput:(id<JavaIoObjectOutput>)outArg;

- (void)readExternalWithJavaIoObjectInput:(id<JavaIoObjectInput>)inArg;

@end

J2OBJC_EMPTY_STATIC_INIT(GnuTroveImplHashTHash)

CF_EXTERN_C_BEGIN

J2OBJC_STATIC_FIELD_GETTER(GnuTroveImplHashTHash, serialVersionUID, jlong)

J2OBJC_STATIC_FIELD_GETTER(GnuTroveImplHashTHash, DEFAULT_LOAD_FACTOR, jfloat)

J2OBJC_STATIC_FIELD_GETTER(GnuTroveImplHashTHash, DEFAULT_CAPACITY, jint)
CF_EXTERN_C_END

J2OBJC_TYPE_LITERAL_HEADER(GnuTroveImplHashTHash)

#endif // _GnuTroveImplHashTHash_H_
