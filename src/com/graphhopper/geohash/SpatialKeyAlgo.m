//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java
//

#include "J2ObjC_source.h"
#include "com/graphhopper/geohash/SpatialKeyAlgo.h"
#include "com/graphhopper/util/shapes/BBox.h"
#include "com/graphhopper/util/shapes/GHPoint.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Math.h"

__attribute__((unused)) static void SpatialKeyAlgo_myinitWithInt_(SpatialKeyAlgo *self, jint allBits);
__attribute__((unused)) static jlong SpatialKeyAlgo_encodeWithDouble_withDouble_(SpatialKeyAlgo *self, jdouble lat, jdouble lon);

@interface SpatialKeyAlgo () {
 @public
  BBox *bbox_;
  jint allBits_;
  jlong initialBits_;
}

- (void)myinitWithInt:(jint)allBits;
@end

J2OBJC_FIELD_SETTER(SpatialKeyAlgo, bbox_, BBox *)

@implementation SpatialKeyAlgo

- (instancetype)initWithInt:(jint)allBits {
  if (self = [super init]) {
    SpatialKeyAlgo_myinitWithInt_(self, allBits);
  }
  return self;
}

- (void)myinitWithInt:(jint)allBits {
  SpatialKeyAlgo_myinitWithInt_(self, allBits);
}

- (jint)getBits {
  return allBits_;
}

- (jint)getExactPrecision {
  jint p = J2ObjCFpToInt((JavaLangMath_powWithDouble_withDouble_(2, allBits_) / 360));
  p++;
  return J2ObjCFpToInt(JavaLangMath_log10WithDouble_(p));
}

- (SpatialKeyAlgo *)boundsWithBBox:(BBox *)box {
  SpatialKeyAlgo_set_bbox_(self, [((BBox *) nil_chk(box)) clone]);
  return self;
}

- (SpatialKeyAlgo *)setBoundsWithDouble:(jdouble)minLonInit
                             withDouble:(jdouble)maxLonInit
                             withDouble:(jdouble)minLatInit
                             withDouble:(jdouble)maxLatInit {
  [self boundsWithBBox:[[[BBox alloc] initWithDouble:minLonInit withDouble:maxLonInit withDouble:minLatInit withDouble:maxLatInit] autorelease]];
  return self;
}

- (void)setWorldBounds {
  [self setBoundsWithDouble:-180 withDouble:180 withDouble:-90 withDouble:90];
}

- (jlong)encodeWithGHPoint:(GHPoint *)coord {
  return SpatialKeyAlgo_encodeWithDouble_withDouble_(self, ((GHPoint *) nil_chk(coord))->lat_, coord->lon_);
}

- (jlong)encodeWithDouble:(jdouble)lat
               withDouble:(jdouble)lon {
  return SpatialKeyAlgo_encodeWithDouble_withDouble_(self, lat, lon);
}

- (void)decodeWithLong:(jlong)spatialKey
           withGHPoint:(GHPoint *)latLon {
  jdouble midLat = (((BBox *) nil_chk(bbox_))->maxLat_ - bbox_->minLat_) / 2;
  jdouble midLon = (bbox_->maxLon_ - bbox_->minLon_) / 2;
  jdouble lat = bbox_->minLat_;
  jdouble lon = bbox_->minLon_;
  jlong bits = initialBits_;
  while (YES) {
    if ((spatialKey & bits) != 0) {
      lat += midLat;
    }
    midLat /= 2;
    URShiftAssignLong(&bits, 1);
    if ((spatialKey & bits) != 0) {
      lon += midLon;
    }
    midLon /= 2;
    if (bits > 1) {
      URShiftAssignLong(&bits, 1);
    }
    else {
      break;
    }
  }
  lat += midLat;
  lon += midLon;
  ((GHPoint *) nil_chk(latLon))->lat_ = lat;
  latLon->lon_ = lon;
}

- (NSString *)description {
  return JreStrcat("$I$@", @"bits:", allBits_, @", bounds:", bbox_);
}

- (void)dealloc {
  RELEASE_(bbox_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(SpatialKeyAlgo *)other {
  [super copyAllFieldsTo:other];
  SpatialKeyAlgo_set_bbox_(other, bbox_);
  other->allBits_ = allBits_;
  other->initialBits_ = initialBits_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithInt:", "SpatialKeyAlgo", NULL, 0x1, NULL },
    { "myinitWithInt:", "myinit", "V", 0x2, NULL },
    { "getBits", NULL, "I", 0x1, NULL },
    { "getExactPrecision", NULL, "I", 0x1, NULL },
    { "boundsWithBBox:", "bounds", "Lcom.graphhopper.geohash.SpatialKeyAlgo;", 0x1, NULL },
    { "setBoundsWithDouble:withDouble:withDouble:withDouble:", "setBounds", "Lcom.graphhopper.geohash.SpatialKeyAlgo;", 0x1, NULL },
    { "setWorldBounds", NULL, "V", 0x4, NULL },
    { "encodeWithGHPoint:", "encode", "J", 0x1, NULL },
    { "encodeWithDouble:withDouble:", "encode", "J", 0x11, NULL },
    { "decodeWithLong:withGHPoint:", "decode", "V", 0x11, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "bbox_", NULL, 0x2, "Lcom.graphhopper.util.shapes.BBox;", NULL,  },
    { "allBits_", NULL, 0x2, "I", NULL,  },
    { "initialBits_", NULL, 0x2, "J", NULL,  },
  };
  static const J2ObjcClassInfo _SpatialKeyAlgo = { 1, "SpatialKeyAlgo", "com.graphhopper.geohash", NULL, 0x1, 11, methods, 3, fields, 0, NULL};
  return &_SpatialKeyAlgo;
}

@end

void SpatialKeyAlgo_myinitWithInt_(SpatialKeyAlgo *self, jint allBits) {
  if (allBits > 64) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"allBits is too big and does not fit into 8 bytes"] autorelease];
  if (allBits <= 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"allBits must be positive"] autorelease];
  self->allBits_ = allBits;
  self->initialBits_ = LShift64(1LL, (allBits - 1));
  [self setWorldBounds];
}

jlong SpatialKeyAlgo_encodeWithDouble_withDouble_(SpatialKeyAlgo *self, jdouble lat, jdouble lon) {
  jlong hash_ = 0;
  jdouble minLatTmp = ((BBox *) nil_chk(self->bbox_))->minLat_;
  jdouble maxLatTmp = self->bbox_->maxLat_;
  jdouble minLonTmp = self->bbox_->minLon_;
  jdouble maxLonTmp = self->bbox_->maxLon_;
  jint i = 0;
  while (YES) {
    if (minLatTmp < maxLatTmp) {
      jdouble midLat = (minLatTmp + maxLatTmp) / 2;
      if (lat < midLat) {
        maxLatTmp = midLat;
      }
      else {
        hash_ |= 1;
        minLatTmp = midLat;
      }
    }
    i++;
    if (i < self->allBits_) LShiftAssignLong(&hash_, 1);
    else break;
    if (minLonTmp < maxLonTmp) {
      jdouble midLon = (minLonTmp + maxLonTmp) / 2;
      if (lon < midLon) {
        maxLonTmp = midLon;
      }
      else {
        hash_ |= 1;
        minLonTmp = midLon;
      }
    }
    i++;
    if (i < self->allBits_) LShiftAssignLong(&hash_, 1);
    else break;
  }
  return hash_;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(SpatialKeyAlgo)
