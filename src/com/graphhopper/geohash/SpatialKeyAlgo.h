//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java
//

#ifndef _SpatialKeyAlgo_H_
#define _SpatialKeyAlgo_H_

@class BBox;
@class GHPoint;

#include "J2ObjC_header.h"
#include "com/graphhopper/geohash/KeyAlgo.h"

/**
 @brief This class implements the idea of a geohash but in 'binary form' - to avoid confusion this is called 'spatial key'.
 The idea of mixing the latitude and longitude is also taken to allow removing the insignificant (right side) bits to make a geo-query or the coordinate less precise. E.g. for a 3 bit precision the spatial key would need 6 bits and look like: <p> lat0 lon0 | lat1 lon1 | lat2 lon2 <p> This works similar to how BIG endianess works for bytes to int packing. Detailed information is available in this blog post: http://karussell.wordpress.com/2012/05/23/spatial-keys-memory-efficient-geohashes/ <p> The bits are usable as key for hash tables like our SpatialKeyHashtable or for a spatial tree like QuadTreeSimple. Also the binary form makes it relative simple for implementations using this encoding scheme to expand to arbitrary dimension (e.g. shifting n-times if n would be the dimension). <p> A 32 bit representation has a precision of approx 600 meters = 40000/2^16 <p> There are different possibilities how to handle different precision and order of bits. Either: <p> lat0 lon0 | lat1 lon1 | lat2 lon2 <p> 0 0 | lat0 lon0 | lat1 lon1 <p> as it is done now. Advantage: A single shift is only necessary to make it less precise. Or: <p> lat2 lon2 | lat1 lon1 | lat0 lon0 <p> 0 0 | lat1 lon1 | lat0 lon0 <p> Advantage: the bit mask to get lat0 lon0 is simple: 000..0011 and independent of the precision! But when stored e.g. as int one would need to (left) shift several times if precision is only 3bits. <p>
 @author Peter Karich
 */
@interface SpatialKeyAlgo : NSObject < KeyAlgo > {
}

/**
 @param allBits how many bits should be used for the spatial key when encoding/decoding
 */
- (instancetype)initWithInt:(jint)allBits;

/**
 @return the number of involved bits
 */
- (jint)getBits;

- (jint)getExactPrecision;

- (SpatialKeyAlgo *)boundsWithBBox:(BBox *)box;

- (SpatialKeyAlgo *)setBoundsWithDouble:(jdouble)minLonInit
                             withDouble:(jdouble)maxLonInit
                             withDouble:(jdouble)minLatInit
                             withDouble:(jdouble)maxLatInit;

- (void)setWorldBounds;

- (jlong)encodeWithGHPoint:(GHPoint *)coord;

/**
 @brief Take latitude and longitude as input.
 <p>
 @return the spatial key
 */
- (jlong)encodeWithDouble:(jdouble)lat
               withDouble:(jdouble)lon;

/**
 @brief This method returns latitude and longitude via latLon - calculated from specified spatialKey <p>
 @param spatialKey is the input
 */
- (void)decodeWithLong:(jlong)spatialKey
           withGHPoint:(GHPoint *)latLon;

- (NSString *)description;

@end

J2OBJC_EMPTY_STATIC_INIT(SpatialKeyAlgo)

CF_EXTERN_C_BEGIN
CF_EXTERN_C_END

typedef SpatialKeyAlgo ComGraphhopperGeohashSpatialKeyAlgo;

J2OBJC_TYPE_LITERAL_HEADER(SpatialKeyAlgo)

#endif // _SpatialKeyAlgo_H_
