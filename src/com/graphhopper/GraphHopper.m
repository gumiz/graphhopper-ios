//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/GraphHopper.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/GHRequest.h"
#include "com/graphhopper/GHResponse.h"
#include "com/graphhopper/GraphHopper.h"
#include "com/graphhopper/reader/DataReader.h"
#include "com/graphhopper/reader/dem/BridgeElevationInterpolator.h"
#include "com/graphhopper/reader/dem/CGIARProvider.h"
#include "com/graphhopper/reader/dem/ElevationProvider.h"
#include "com/graphhopper/reader/dem/SRTMProvider.h"
#include "com/graphhopper/reader/dem/TunnelElevationInterpolator.h"
#include "com/graphhopper/routing/AlgorithmOptions.h"
#include "com/graphhopper/routing/QueryGraph.h"
#include "com/graphhopper/routing/RoutingAlgorithmFactory.h"
#include "com/graphhopper/routing/RoutingAlgorithmFactoryDecorator.h"
#include "com/graphhopper/routing/RoutingAlgorithmFactorySimple.h"
#include "com/graphhopper/routing/ch/CHAlgoFactoryDecorator.h"
#include "com/graphhopper/routing/ch/PrepareContractionHierarchies.h"
#include "com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworks.h"
#include "com/graphhopper/routing/template/AlternativeRoutingTemplate.h"
#include "com/graphhopper/routing/template/RoundTripRoutingTemplate.h"
#include "com/graphhopper/routing/template/RoutingTemplate.h"
#include "com/graphhopper/routing/template/ViaRoutingTemplate.h"
#include "com/graphhopper/routing/util/AllEdgesIterator.h"
#include "com/graphhopper/routing/util/DataFlagEncoder.h"
#include "com/graphhopper/routing/util/EncodingManager.h"
#include "com/graphhopper/routing/util/FlagEncoder.h"
#include "com/graphhopper/routing/util/FlagEncoderFactory.h"
#include "com/graphhopper/routing/util/HintsMap.h"
#include "com/graphhopper/routing/util/TraversalMode.h"
#include "com/graphhopper/routing/weighting/CurvatureWeighting.h"
#include "com/graphhopper/routing/weighting/FastestWeighting.h"
#include "com/graphhopper/routing/weighting/GenericWeighting.h"
#include "com/graphhopper/routing/weighting/PriorityWeighting.h"
#include "com/graphhopper/routing/weighting/ShortFastestWeighting.h"
#include "com/graphhopper/routing/weighting/ShortestWeighting.h"
#include "com/graphhopper/routing/weighting/TurnWeighting.h"
#include "com/graphhopper/routing/weighting/Weighting.h"
#include "com/graphhopper/storage/CHGraph.h"
#include "com/graphhopper/storage/DAType.h"
#include "com/graphhopper/storage/Directory.h"
#include "com/graphhopper/storage/GHDirectory.h"
#include "com/graphhopper/storage/Graph.h"
#include "com/graphhopper/storage/GraphExtension.h"
#include "com/graphhopper/storage/GraphHopperStorage.h"
#include "com/graphhopper/storage/Lock.h"
#include "com/graphhopper/storage/LockFactory.h"
#include "com/graphhopper/storage/NativeFSLockFactory.h"
#include "com/graphhopper/storage/SimpleFSLockFactory.h"
#include "com/graphhopper/storage/StorableProperties.h"
#include "com/graphhopper/storage/TurnCostExtension.h"
#include "com/graphhopper/storage/index/LocationIndex.h"
#include "com/graphhopper/storage/index/LocationIndexTree.h"
#include "com/graphhopper/util/CmdArgs.h"
#include "com/graphhopper/util/ConfigMap.h"
#include "com/graphhopper/util/Constants.h"
#include "com/graphhopper/util/DouglasPeucker.h"
#include "com/graphhopper/util/GHUtility.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/Parameters.h"
#include "com/graphhopper/util/PathMerger.h"
#include "com/graphhopper/util/StopWatch.h"
#include "com/graphhopper/util/Translation.h"
#include "com/graphhopper/util/TranslationMap.h"
#include "com/graphhopper/util/Unzipper.h"
#include "com/graphhopper/util/exceptions/PointOutOfBoundsException.h"
#include "com/graphhopper/util/shapes/BBox.h"
#include "com/graphhopper/util/shapes/GHPoint.h"
#include "java/io/File.h"
#include "java/io/IOException.h"
#include "java/lang/Boolean.h"
#include "java/lang/Deprecated.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/text/DateFormat.h"
#include "java/util/Arrays.h"
#include "java/util/Collections.h"
#include "java/util/Date.h"
#include "java/util/LinkedHashSet.h"
#include "java/util/List.h"
#include "java/util/Locale.h"
#include "java/util/Set.h"
#include "org/slf4j/Logger.h"
#include "org/slf4j/LoggerFactory.h"

__attribute__((unused)) static GraphHopper *GraphHopper_setSimplifyResponseWithBoolean_(GraphHopper *self, jboolean doSimplify);
__attribute__((unused)) static void GraphHopper_printInfo(GraphHopper *self);
__attribute__((unused)) static GraphHopper *GraphHopper_processWithNSString_(GraphHopper *self, NSString *graphHopperLocation);
__attribute__((unused)) static CHAlgoFactoryDecorator *GraphHopper_getCHFactoryDecorator(GraphHopper *self);
__attribute__((unused)) static void GraphHopper_initCHAlgoFactoryDecorator(GraphHopper *self);
__attribute__((unused)) static void GraphHopper_interpolateBridgesAndOrTunnels(GraphHopper *self);
__attribute__((unused)) static jboolean GraphHopper_isPrepared(GraphHopper *self);
__attribute__((unused)) static void GraphHopper_checkIfPointsAreInBoundsWithJavaUtilList_(GraphHopper *self, id<JavaUtilList> points);

@interface GraphHopper () {
 @public
  id<OrgSlf4jLogger> logger_;
  NSString *fileLockName_;
  id<JavaUtilSet> algoDecorators_;
  CHAlgoFactoryDecorator *chFactoryDecorator_;
  TranslationMap *trMap_;
  GraphHopperStorage *ghStorage_;
  EncodingManager *encodingManager_;
  jint defaultSegmentSize_;
  NSString *ghLocation_;
  DAType *dataAccessType_;
  jboolean sortGraph_;
  jboolean elevation_;
  id<LockFactory> lockFactory_;
  jboolean allowWrites_;
  NSString *preferredLanguage_;
  jboolean fullyLoaded_;
  jint maxRoundTripRetries_;
  jboolean simplifyResponse_;
  TraversalModeEnum *traversalMode_;
  jint maxVisitedNodes_;
  id<LocationIndex> locationIndex_;
  jint preciseIndexResolution_;
  jint maxRegionSearch_;
  jint minNetworkSize_;
  jint minOneWayNetworkSize_;
  NSString *dataReaderFile_;
  jdouble dataReaderWayPointMaxDistance_;
  jint dataReaderWorkerThreads_;
  jboolean calcPoints_;
  id<ComGraphhopperReaderDemElevationProvider> eleProvider_;
  id<FlagEncoderFactory> flagEncoderFactory_;
}

/**
 @brief Not yet stable enough to offer it for everyone
 */
- (GraphHopper *)setUnsafeMemory;

/**
 @brief This method specifies if the returned path should be simplified or not, via douglas-peucker or similar algorithm.
 */
- (GraphHopper *)setSimplifyResponseWithBoolean:(jboolean)doSimplify;

- (void)printInfo;

/**
 @brief Creates the graph from OSM data.
 */
- (GraphHopper *)processWithNSString:(NSString *)graphHopperLocation;

- (void)initCHAlgoFactoryDecorator OBJC_METHOD_FAMILY_NONE;

- (void)interpolateBridgesAndOrTunnels;

- (jboolean)isPrepared;

- (void)checkIfPointsAreInBoundsWithJavaUtilList:(id<JavaUtilList>)points;
@end

J2OBJC_FIELD_SETTER(GraphHopper, logger_, id<OrgSlf4jLogger>)
J2OBJC_FIELD_SETTER(GraphHopper, fileLockName_, NSString *)
J2OBJC_FIELD_SETTER(GraphHopper, algoDecorators_, id<JavaUtilSet>)
J2OBJC_FIELD_SETTER(GraphHopper, chFactoryDecorator_, CHAlgoFactoryDecorator *)
J2OBJC_FIELD_SETTER(GraphHopper, trMap_, TranslationMap *)
J2OBJC_FIELD_SETTER(GraphHopper, ghStorage_, GraphHopperStorage *)
J2OBJC_FIELD_SETTER(GraphHopper, encodingManager_, EncodingManager *)
J2OBJC_FIELD_SETTER(GraphHopper, ghLocation_, NSString *)
J2OBJC_FIELD_SETTER(GraphHopper, dataAccessType_, DAType *)
J2OBJC_FIELD_SETTER(GraphHopper, lockFactory_, id<LockFactory>)
J2OBJC_FIELD_SETTER(GraphHopper, preferredLanguage_, NSString *)
J2OBJC_FIELD_SETTER(GraphHopper, traversalMode_, TraversalModeEnum *)
J2OBJC_FIELD_SETTER(GraphHopper, locationIndex_, id<LocationIndex>)
J2OBJC_FIELD_SETTER(GraphHopper, dataReaderFile_, NSString *)
J2OBJC_FIELD_SETTER(GraphHopper, eleProvider_, id<ComGraphhopperReaderDemElevationProvider>)
J2OBJC_FIELD_SETTER(GraphHopper, flagEncoderFactory_, id<FlagEncoderFactory>)

@implementation GraphHopper

- (instancetype)init {
  if (self = [super init]) {
    GraphHopper_set_logger_(self, OrgSlf4jLoggerFactory_getLoggerWithIOSClass_([self getClass]));
    GraphHopper_set_fileLockName_(self, @"gh.lock");
    GraphHopper_setAndConsume_algoDecorators_(self, [[JavaUtilLinkedHashSet alloc] init]);
    GraphHopper_setAndConsume_chFactoryDecorator_(self, [[CHAlgoFactoryDecorator alloc] init]);
    GraphHopper_set_trMap_(self, [((TranslationMap *) [[[TranslationMap alloc] init] autorelease]) doImport]);
    removeZipped_ = YES;
    enableInstructions_ = YES;
    defaultSegmentSize_ = -1;
    GraphHopper_set_ghLocation_(self, @"");
    GraphHopper_set_dataAccessType_(self, DAType_get_RAM_STORE_());
    sortGraph_ = NO;
    elevation_ = NO;
    GraphHopper_setAndConsume_lockFactory_(self, [[NativeFSLockFactory alloc] init]);
    allowWrites_ = YES;
    GraphHopper_set_preferredLanguage_(self, @"");
    fullyLoaded_ = NO;
    maxRoundTripRetries_ = 3;
    simplifyResponse_ = YES;
    GraphHopper_set_traversalMode_(self, TraversalModeEnum_get_NODE_BASED());
    maxVisitedNodes_ = JavaLangInteger_MAX_VALUE;
    preciseIndexResolution_ = 300;
    maxRegionSearch_ = 4;
    minNetworkSize_ = 200;
    minOneWayNetworkSize_ = 0;
    dataReaderWayPointMaxDistance_ = 1;
    dataReaderWorkerThreads_ = -1;
    calcPoints_ = YES;
    GraphHopper_set_eleProvider_(self, ComGraphhopperReaderDemElevationProvider_get_NOOP_());
    GraphHopper_set_flagEncoderFactory_(self, FlagEncoderFactory_get_DEFAULT_());
    [chFactoryDecorator_ setEnabledWithBoolean:YES];
    [algoDecorators_ addWithId:chFactoryDecorator_];
  }
  return self;
}

- (GraphHopper *)loadGraphWithGraphHopperStorage:(GraphHopperStorage *)g {
  GraphHopper_set_ghStorage_(self, g);
  fullyLoaded_ = YES;
  [self initLocationIndex];
  return self;
}

- (id<FlagEncoder>)getDefaultVehicle {
  if (encodingManager_ == nil) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"No encoding manager specified or loaded"] autorelease];
  return [((id<JavaUtilList>) nil_chk([((EncodingManager *) nil_chk(encodingManager_)) fetchEdgeEncoders])) getWithInt:0];
}

- (EncodingManager *)getEncodingManager {
  return encodingManager_;
}

- (GraphHopper *)setEncodingManagerWithEncodingManager:(EncodingManager *)em {
  [self ensureNotLoaded];
  GraphHopper_set_encodingManager_(self, em);
  if ([((EncodingManager *) nil_chk(em)) needsTurnCostsSupport]) GraphHopper_set_traversalMode_(self, TraversalModeEnum_get_EDGE_BASED_2DIR());
  return self;
}

- (id<ComGraphhopperReaderDemElevationProvider>)getElevationProvider {
  return eleProvider_;
}

- (GraphHopper *)setElevationProviderWithComGraphhopperReaderDemElevationProvider:(id<ComGraphhopperReaderDemElevationProvider>)eleProvider {
  if (eleProvider == nil || eleProvider == ComGraphhopperReaderDemElevationProvider_get_NOOP_()) [self setElevationWithBoolean:NO];
  else [self setElevationWithBoolean:YES];
  GraphHopper_set_eleProvider_(self, eleProvider);
  return self;
}

- (jint)getWorkerThreads {
  return dataReaderWorkerThreads_;
}

- (jdouble)getWayPointMaxDistance {
  return dataReaderWayPointMaxDistance_;
}

- (GraphHopper *)setWayPointMaxDistanceWithDouble:(jdouble)wayPointMaxDistance {
  self->dataReaderWayPointMaxDistance_ = wayPointMaxDistance;
  return self;
}

- (TraversalModeEnum *)getTraversalMode {
  return traversalMode_;
}

- (GraphHopper *)setTraversalModeWithTraversalModeEnum:(TraversalModeEnum *)traversalMode {
  GraphHopper_set_traversalMode_(self, traversalMode);
  return self;
}

- (GraphHopper *)forServer {
  GraphHopper_setSimplifyResponseWithBoolean_(self, YES);
  return [self setInMemory];
}

- (GraphHopper *)forDesktop {
  GraphHopper_setSimplifyResponseWithBoolean_(self, NO);
  return [self setInMemory];
}

- (GraphHopper *)forMobile {
  GraphHopper_setSimplifyResponseWithBoolean_(self, NO);
  return [self setMemoryMapped];
}

- (GraphHopper *)setPreciseIndexResolutionWithInt:(jint)precision {
  [self ensureNotLoaded];
  preciseIndexResolution_ = precision;
  return self;
}

- (GraphHopper *)setMinNetworkSizeWithInt:(jint)minNetworkSize
                                  withInt:(jint)minOneWayNetworkSize {
  self->minNetworkSize_ = minNetworkSize;
  self->minOneWayNetworkSize_ = minOneWayNetworkSize;
  return self;
}

- (GraphHopper *)setInMemory {
  [self ensureNotLoaded];
  GraphHopper_set_dataAccessType_(self, DAType_get_RAM_STORE_());
  return self;
}

- (GraphHopper *)setStoreOnFlushWithBoolean:(jboolean)storeOnFlush {
  [self ensureNotLoaded];
  if (storeOnFlush) GraphHopper_set_dataAccessType_(self, DAType_get_RAM_STORE_());
  else GraphHopper_set_dataAccessType_(self, DAType_get_RAM_());
  return self;
}

- (GraphHopper *)setMemoryMapped {
  [self ensureNotLoaded];
  GraphHopper_set_dataAccessType_(self, DAType_get_MMAP_());
  return self;
}

- (GraphHopper *)setUnsafeMemory {
  [self ensureNotLoaded];
  GraphHopper_set_dataAccessType_(self, DAType_get_UNSAFE_STORE_());
  return self;
}

- (GraphHopper *)setCHWeightingWithNSString:(NSString *)weightingName {
  return [self setCHWeightingsWithNSStringArray:[IOSObjectArray arrayWithObjects:(id[]){ weightingName } count:1 type:NSString_class_()]];
}

- (GraphHopper *)setCHWeightingsWithNSStringArray:(IOSObjectArray *)weightingNames {
  return [self setCHWeightingsWithJavaUtilList:JavaUtilArrays_asListWithNSObjectArray_(weightingNames)];
}

- (id<JavaUtilList>)getCHWeightings {
  return [((CHAlgoFactoryDecorator *) nil_chk(chFactoryDecorator_)) getWeightingsAsStrings];
}

- (GraphHopper *)setCHWeightingsWithJavaUtilList:(id<JavaUtilList>)weightingList {
  [self ensureNotLoaded];
  [((CHAlgoFactoryDecorator *) nil_chk(chFactoryDecorator_)) setWeightingsAsStringsWithJavaUtilList:weightingList];
  return self;
}

- (jint)getCHPrepareThreads {
  return [((CHAlgoFactoryDecorator *) nil_chk(chFactoryDecorator_)) getPreparationThreads];
}

- (GraphHopper *)setCHPrepareThreadsWithInt:(jint)prepareThreads {
  [((CHAlgoFactoryDecorator *) nil_chk(chFactoryDecorator_)) setPreparationThreadsWithInt:prepareThreads];
  return self;
}

- (GraphHopper *)setCHEnableWithBoolean:(jboolean)enable {
  return [self setCHEnabledWithBoolean:enable];
}

- (jboolean)isCHEnabled {
  return [((CHAlgoFactoryDecorator *) nil_chk(chFactoryDecorator_)) isEnabled];
}

- (GraphHopper *)setCHEnabledWithBoolean:(jboolean)enable {
  [self ensureNotLoaded];
  [((CHAlgoFactoryDecorator *) nil_chk(chFactoryDecorator_)) setEnabledWithBoolean:enable];
  return self;
}

- (jint)getMaxVisitedNodes {
  return maxVisitedNodes_;
}

- (void)setMaxVisitedNodesWithInt:(jint)maxVisitedNodes {
  self->maxVisitedNodes_ = maxVisitedNodes;
}

- (jboolean)hasElevation {
  return elevation_;
}

- (GraphHopper *)setElevationWithBoolean:(jboolean)includeElevation {
  self->elevation_ = includeElevation;
  return self;
}

- (jboolean)isEnableInstructions {
  return enableInstructions_;
}

- (GraphHopper *)setEnableInstructionsWithBoolean:(jboolean)b {
  [self ensureNotLoaded];
  enableInstructions_ = b;
  return self;
}

- (NSString *)getPreferredLanguage {
  return preferredLanguage_;
}

- (GraphHopper *)setPreferredLanguageWithNSString:(NSString *)preferredLanguage {
  [self ensureNotLoaded];
  if (preferredLanguage == nil) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"preferred language cannot be null"] autorelease];
  GraphHopper_set_preferredLanguage_(self, preferredLanguage);
  return self;
}

- (GraphHopper *)setEnableCalcPointsWithBoolean:(jboolean)b {
  calcPoints_ = b;
  return self;
}

- (GraphHopper *)setSimplifyResponseWithBoolean:(jboolean)doSimplify {
  return GraphHopper_setSimplifyResponseWithBoolean_(self, doSimplify);
}

- (NSString *)getGraphHopperLocation {
  return ghLocation_;
}

- (GraphHopper *)setGraphHopperLocationWithNSString:(NSString *)ghLocation {
  [self ensureNotLoaded];
  if (ghLocation == nil) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"graphhopper location cannot be null"] autorelease];
  GraphHopper_set_ghLocation_(self, ghLocation);
  return self;
}

- (NSString *)getDataReaderFile {
  return dataReaderFile_;
}

- (GraphHopper *)setDataReaderFileWithNSString:(NSString *)dataReaderFileStr {
  [self ensureNotLoaded];
  if (Helper_isEmptyWithNSString_(dataReaderFileStr)) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Data reader file cannot be empty."] autorelease];
  GraphHopper_set_dataReaderFile_(self, dataReaderFileStr);
  return self;
}

- (GraphHopperStorage *)getGraphHopperStorage {
  if (ghStorage_ == nil) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"GraphHopper storage not initialized"] autorelease];
  return ghStorage_;
}

- (void)setGraphHopperStorageWithGraphHopperStorage:(GraphHopperStorage *)ghStorage {
  GraphHopper_set_ghStorage_(self, ghStorage);
  fullyLoaded_ = YES;
}

- (id<LocationIndex>)getLocationIndex {
  if (locationIndex_ == nil) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Location index not initialized"] autorelease];
  return locationIndex_;
}

- (void)setLocationIndexWithLocationIndex:(id<LocationIndex>)locationIndex {
  GraphHopper_set_locationIndex_(self, locationIndex);
}

- (GraphHopper *)setSortGraphWithBoolean:(jboolean)sortGraph {
  [self ensureNotLoaded];
  self->sortGraph_ = sortGraph;
  return self;
}

- (jboolean)isAllowWrites {
  return allowWrites_;
}

- (GraphHopper *)setAllowWritesWithBoolean:(jboolean)allowWrites {
  self->allowWrites_ = allowWrites;
  return self;
}

- (TranslationMap *)getTranslationMap {
  return trMap_;
}

- (GraphHopper *)setFlagEncoderFactoryWithFlagEncoderFactory:(id<FlagEncoderFactory>)factory {
  GraphHopper_set_flagEncoderFactory_(self, factory);
  return self;
}

- (GraphHopper *)init__WithCmdArgs:(CmdArgs *)args {
  args = CmdArgs_readFromConfigAndMergeWithCmdArgs_withNSString_withNSString_(args, @"config", @"graphhopper.config");
  if ([((CmdArgs *) nil_chk(args)) hasWithNSString:@"osmreader.osm"]) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Instead osmreader.osm use datareader.file, for other changes see core/files/changelog.txt"] autorelease];
  NSString *tmpOsmFile = [args getWithNSString:@"datareader.file" withNSString:@""];
  if (!Helper_isEmptyWithNSString_(tmpOsmFile)) GraphHopper_set_dataReaderFile_(self, tmpOsmFile);
  NSString *graphHopperFolder = [args getWithNSString:@"graph.location" withNSString:@""];
  if (Helper_isEmptyWithNSString_(graphHopperFolder) && Helper_isEmptyWithNSString_(ghLocation_)) {
    if (Helper_isEmptyWithNSString_(dataReaderFile_)) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"You need to specify an OSM file."] autorelease];
    graphHopperFolder = JreStrcat("$$", Helper_pruneFileEndWithNSString_(dataReaderFile_), @"-gh");
  }
  [self setGraphHopperLocationWithNSString:graphHopperFolder];
  defaultSegmentSize_ = [args getIntWithNSString:@"graph.dataaccess.segment_size" withInt:defaultSegmentSize_];
  NSString *graphDATypeStr = [args getWithNSString:@"graph.dataaccess" withNSString:@"RAM_STORE"];
  GraphHopper_set_dataAccessType_(self, DAType_fromStringWithNSString_(graphDATypeStr));
  sortGraph_ = [args getBoolWithNSString:@"graph.do_sort" withBoolean:sortGraph_];
  removeZipped_ = [args getBoolWithNSString:@"graph.remove_zipped" withBoolean:removeZipped_];
  jint bytesForFlags = [args getIntWithNSString:@"graph.bytes_for_flags" withInt:4];
  NSString *flagEncodersStr = [args getWithNSString:@"graph.flag_encoders" withNSString:@""];
  if (![((NSString *) nil_chk(flagEncodersStr)) isEmpty]) [self setEncodingManagerWithEncodingManager:[[[EncodingManager alloc] initWithFlagEncoderFactory:flagEncoderFactory_ withNSString:flagEncodersStr withInt:bytesForFlags] autorelease]];
  if ([((NSString *) nil_chk([args getWithNSString:@"graph.locktype" withNSString:@"native"])) isEqual:@"simple"]) GraphHopper_setAndConsume_lockFactory_(self, [[SimpleFSLockFactory alloc] init]);
  else GraphHopper_setAndConsume_lockFactory_(self, [[NativeFSLockFactory alloc] init]);
  NSString *eleProviderStr = [((NSString *) nil_chk([args getWithNSString:@"graph.elevation.provider" withNSString:@"noop"])) lowercaseString];
  jboolean eleCalcMean = [args hasWithNSString:@"graph.elevation.calcmean"] ? [args getBoolWithNSString:@"graph.elevation.calcmean" withBoolean:NO] : [args getBoolWithNSString:@"graph.elevation.calc_mean" withBoolean:NO];
  NSString *cacheDirStr = [args getWithNSString:@"graph.elevation.cache_dir" withNSString:@""];
  if ([((NSString *) nil_chk(cacheDirStr)) isEmpty]) cacheDirStr = [args getWithNSString:@"graph.elevation.cachedir" withNSString:@""];
  NSString *baseURL = [args getWithNSString:@"graph.elevation.base_url" withNSString:@""];
  if ([((NSString *) nil_chk(baseURL)) isEmpty]) [args getWithNSString:@"graph.elevation.baseurl" withNSString:@""];
  DAType *elevationDAType = DAType_fromStringWithNSString_([args getWithNSString:@"graph.elevation.dataaccess" withNSString:@"MMAP"]);
  id<ComGraphhopperReaderDemElevationProvider> tmpProvider = ComGraphhopperReaderDemElevationProvider_get_NOOP_();
  if ([((NSString *) nil_chk(eleProviderStr)) equalsIgnoreCase:@"srtm"]) {
    tmpProvider = [[[ComGraphhopperReaderDemSRTMProvider alloc] init] autorelease];
  }
  else if ([eleProviderStr equalsIgnoreCase:@"cgiar"]) {
    ComGraphhopperReaderDemCGIARProvider *cgiarProvider = [[[ComGraphhopperReaderDemCGIARProvider alloc] init] autorelease];
    [cgiarProvider setAutoRemoveTemporaryFilesWithBoolean:[args getBoolWithNSString:@"graph.elevation.cgiar.clear" withBoolean:YES]];
    tmpProvider = cgiarProvider;
  }
  [((id<ComGraphhopperReaderDemElevationProvider>) nil_chk(tmpProvider)) setCalcMeanWithBoolean:eleCalcMean];
  [tmpProvider setCacheDirWithJavaIoFile:[[[JavaIoFile alloc] initWithNSString:cacheDirStr] autorelease]];
  if (![baseURL isEmpty]) [tmpProvider setBaseURLWithNSString:baseURL];
  [tmpProvider setDATypeWithDAType:elevationDAType];
  [self setElevationProviderWithComGraphhopperReaderDemElevationProvider:tmpProvider];
  minNetworkSize_ = [args getIntWithNSString:@"prepare.min_network_size" withInt:minNetworkSize_];
  minOneWayNetworkSize_ = [args getIntWithNSString:@"prepare.min_one_way_network_size" withInt:minOneWayNetworkSize_];
  [((CHAlgoFactoryDecorator *) nil_chk(chFactoryDecorator_)) init__WithCmdArgs:args];
  dataReaderWayPointMaxDistance_ = [args getDoubleWithNSString:Parameters_Routing_get_INIT_WAY_POINT_MAX_DISTANCE_() withDouble:dataReaderWayPointMaxDistance_];
  dataReaderWorkerThreads_ = [args getIntWithNSString:@"datareader.worker_threads" withInt:dataReaderWorkerThreads_];
  enableInstructions_ = [args getBoolWithNSString:@"datareader.instructions" withBoolean:enableInstructions_];
  GraphHopper_set_preferredLanguage_(self, [args getWithNSString:@"datareader.preferred_language" withNSString:preferredLanguage_]);
  preciseIndexResolution_ = [args getIntWithNSString:@"index.high_resolution" withInt:preciseIndexResolution_];
  maxRegionSearch_ = [args getIntWithNSString:@"index.max_region_search" withInt:maxRegionSearch_];
  maxVisitedNodes_ = [args getIntWithNSString:Parameters_Routing_get_INIT_MAX_VISITED_NODES_() withInt:JavaLangInteger_MAX_VALUE];
  maxRoundTripRetries_ = [args getIntWithNSString:Parameters_Algorithms_RoundTrip_get_INIT_MAX_RETRIES_() withInt:maxRoundTripRetries_];
  return self;
}

- (void)printInfo {
  GraphHopper_printInfo(self);
}

- (GraphHopper *)importOrLoad {
  if (![self load__WithNSString:ghLocation_]) {
    GraphHopper_printInfo(self);
    GraphHopper_processWithNSString_(self, ghLocation_);
  }
  else {
    GraphHopper_printInfo(self);
  }
  return self;
}

- (GraphHopper *)processWithNSString:(NSString *)graphHopperLocation {
  return GraphHopper_processWithNSString_(self, graphHopperLocation);
}

- (id<DataReader>)importData {
  [self ensureWriteAccess];
  if (ghStorage_ == nil) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Load graph before importing OSM data"] autorelease];
  if (dataReaderFile_ == nil) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$$$", @"Couldn't load from existing folder: ", ghLocation_, @" but also cannot use file for DataReader as it wasn't specified!")] autorelease];
  [((EncodingManager *) nil_chk(encodingManager_)) setEnableInstructionsWithBoolean:enableInstructions_];
  [encodingManager_ setPreferredLanguageWithNSString:preferredLanguage_];
  id<DataReader> reader = [self createReaderWithGraphHopperStorage:ghStorage_];
  [((id<OrgSlf4jLogger>) nil_chk(logger_)) infoWithNSString:JreStrcat("$$$$", @"using ", [((GraphHopperStorage *) nil_chk(ghStorage_)) description], @", memory:", Helper_getMemInfo())];
  [((id<DataReader>) nil_chk(reader)) readGraph];
  return reader;
}

- (id<DataReader>)createReaderWithGraphHopperStorage:(GraphHopperStorage *)ghStorage {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Cannot create DataReader. Solutions: avoid import via calling load directly, provide a DataReader or use e.g. GraphHopperOSM or a different subclass"] autorelease];
}

- (id<DataReader>)initDataReaderWithDataReader:(id<DataReader>)reader {
  if (dataReaderFile_ == nil) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"No file for DataReader specified"] autorelease];
  [((id<OrgSlf4jLogger>) nil_chk(logger_)) infoWithNSString:JreStrcat("$$", @"start creating graph from ", dataReaderFile_)];
  return [((id<DataReader>) nil_chk([((id<DataReader>) nil_chk([((id<DataReader>) nil_chk([((id<DataReader>) nil_chk([((id<DataReader>) nil_chk(reader)) setFileWithJavaIoFile:[[[JavaIoFile alloc] initWithNSString:dataReaderFile_] autorelease]])) setElevationProviderWithComGraphhopperReaderDemElevationProvider:eleProvider_])) setWorkerThreadsWithInt:dataReaderWorkerThreads_])) setEncodingManagerWithEncodingManager:encodingManager_])) setWayPointMaxDistanceWithDouble:dataReaderWayPointMaxDistance_];
}

- (jboolean)load__WithNSString:(NSString *)graphHopperFolder {
  if (Helper_isEmptyWithNSString_(graphHopperFolder)) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"GraphHopperLocation is not specified. Call setGraphHopperLocation or init before"] autorelease];
  if (fullyLoaded_) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"graph is already successfully loaded"] autorelease];
  if ([((NSString *) nil_chk(graphHopperFolder)) hasSuffix:@"-gh"]) {
  }
  else if ([graphHopperFolder hasSuffix:@".osm"] || [graphHopperFolder hasSuffix:@".xml"]) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"GraphHopperLocation cannot be the OSM file. Instead you need to use importOrLoad"] autorelease];
  }
  else if (![graphHopperFolder contains:@"."]) {
    if ([((JavaIoFile *) [[[JavaIoFile alloc] initWithNSString:JreStrcat("$$", graphHopperFolder, @"-gh")] autorelease]) exists]) graphHopperFolder = JreStrcat("$$", graphHopperFolder, @"-gh");
  }
  else {
    JavaIoFile *compressed = [[[JavaIoFile alloc] initWithNSString:JreStrcat("$$", graphHopperFolder, @".ghz")] autorelease];
    if ([compressed exists] && ![compressed isDirectory]) {
      @try {
        [((Unzipper *) [[[Unzipper alloc] init] autorelease]) unzipWithNSString:[compressed getAbsolutePath] withNSString:graphHopperFolder withBoolean:removeZipped_];
      }
      @catch (JavaIoIOException *ex) {
        @throw [[[JavaLangRuntimeException alloc] initWithNSString:JreStrcat("$$$$", @"Couldn't extract file ", [compressed getAbsolutePath], @" to ", graphHopperFolder) withJavaLangThrowable:ex] autorelease];
      }
    }
  }
  [self setGraphHopperLocationWithNSString:graphHopperFolder];
  if (encodingManager_ == nil) [self setEncodingManagerWithEncodingManager:EncodingManager_createWithFlagEncoderFactory_withNSString_(flagEncoderFactory_, ghLocation_)];
  if (!allowWrites_ && [((DAType *) nil_chk(dataAccessType_)) isMMap]) GraphHopper_set_dataAccessType_(self, DAType_get_MMAP_RO_());
  GHDirectory *dir = [[[GHDirectory alloc] initWithNSString:ghLocation_ withDAType:dataAccessType_] autorelease];
  id<GraphExtension> ext = [((EncodingManager *) nil_chk(encodingManager_)) needsTurnCostsSupport] ? [[[TurnCostExtension alloc] init] autorelease] : [[[GraphExtension_NoOpExtension alloc] init] autorelease];
  if ([((CHAlgoFactoryDecorator *) nil_chk(chFactoryDecorator_)) isEnabled]) {
    GraphHopper_initCHAlgoFactoryDecorator(self);
    GraphHopper_setAndConsume_ghStorage_(self, [[GraphHopperStorage alloc] initWithJavaUtilList:[chFactoryDecorator_ getWeightings] withDirectory:dir withEncodingManager:encodingManager_ withBoolean:[self hasElevation] withGraphExtension:ext]);
  }
  else {
    GraphHopper_setAndConsume_ghStorage_(self, [[GraphHopperStorage alloc] initWithDirectory:dir withEncodingManager:encodingManager_ withBoolean:[self hasElevation] withGraphExtension:ext]);
  }
  [((GraphHopperStorage *) nil_chk(ghStorage_)) setSegmentSizeWithInt:defaultSegmentSize_];
  if (![((JavaIoFile *) [[[JavaIoFile alloc] initWithNSString:graphHopperFolder] autorelease]) exists]) return NO;
  id<Lock> lock = nil;
  @try {
    if ([((DAType *) nil_chk([((id<Directory>) nil_chk([ghStorage_ getDirectory])) getDefaultType])) isStoring] && [self isAllowWrites]) {
      [((id<LockFactory>) nil_chk(lockFactory_)) setLockDirWithJavaIoFile:[[[JavaIoFile alloc] initWithNSString:ghLocation_] autorelease]];
      lock = [lockFactory_ createWithNSString:fileLockName_ withBoolean:NO];
      if (![((id<Lock>) nil_chk(lock)) tryLock]) @throw [[[JavaLangRuntimeException alloc] initWithNSString:JreStrcat("$$", @"To avoid reading partial data we need to obtain the read lock but it failed. In ", ghLocation_) withJavaLangThrowable:[lock getObtainFailedReason]] autorelease];
    }
    if (![ghStorage_ loadExisting]) return NO;
    [self postProcessing];
    fullyLoaded_ = YES;
    return YES;
  }
  @finally {
    if (lock != nil) [lock release__];
  }
}

- (id<RoutingAlgorithmFactory>)getAlgorithmFactoryWithHintsMap:(HintsMap *)map {
  id<RoutingAlgorithmFactory> routingAlgorithmFactory = [[[RoutingAlgorithmFactorySimple alloc] init] autorelease];
  for (id<RoutingAlgorithmFactoryDecorator> __strong decorator in nil_chk(algoDecorators_)) {
    if ([((id<RoutingAlgorithmFactoryDecorator>) nil_chk(decorator)) isEnabled]) routingAlgorithmFactory = [decorator getDecoratedAlgorithmFactoryWithRoutingAlgorithmFactory:routingAlgorithmFactory withHintsMap:map];
  }
  return routingAlgorithmFactory;
}

- (GraphHopper *)addAlgorithmFactoryDecoratorWithRoutingAlgorithmFactoryDecorator:(id<RoutingAlgorithmFactoryDecorator>)algoFactoryDecorator {
  if (![((id<JavaUtilSet>) nil_chk(algoDecorators_)) addWithId:algoFactoryDecorator]) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$@", @"Decorator was already added ", [((id<RoutingAlgorithmFactoryDecorator>) nil_chk(algoFactoryDecorator)) getClass])] autorelease];
  return self;
}

- (CHAlgoFactoryDecorator *)getCHFactoryDecorator {
  return GraphHopper_getCHFactoryDecorator(self);
}

- (void)initCHAlgoFactoryDecorator {
  GraphHopper_initCHAlgoFactoryDecorator(self);
}

- (void)createCHPreparations {
  [((CHAlgoFactoryDecorator *) nil_chk(chFactoryDecorator_)) createPreparationsWithGraphHopperStorage:ghStorage_ withTraversalModeEnum:traversalMode_];
}

- (void)postProcessing {
  if (sortGraph_) {
    if ([((GraphHopperStorage *) nil_chk(ghStorage_)) isCHPossible] && GraphHopper_isPrepared(self)) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Sorting a prepared CHGraph is not possible yet. See #12"] autorelease];
    GraphHopperStorage *newGraph = GHUtility_newStorageWithGraphHopperStorage_(ghStorage_);
    GHUtility_sortDFSWithGraph_withGraph_(ghStorage_, newGraph);
    [((id<OrgSlf4jLogger>) nil_chk(logger_)) infoWithNSString:JreStrcat("$$C", @"graph sorted (", Helper_getMemInfo(), ')')];
    GraphHopper_set_ghStorage_(self, newGraph);
  }
  if ([self hasElevation]) {
    GraphHopper_interpolateBridgesAndOrTunnels(self);
  }
  [self initLocationIndex];
  if ([((CHAlgoFactoryDecorator *) nil_chk(chFactoryDecorator_)) isEnabled]) [self createCHPreparations];
  if (!GraphHopper_isPrepared(self)) [self prepare];
}

- (void)interpolateBridgesAndOrTunnels {
  GraphHopper_interpolateBridgesAndOrTunnels(self);
}

- (jboolean)isPrepared {
  return GraphHopper_isPrepared(self);
}

- (id<ComGraphhopperRoutingWeightingWeighting>)createWeightingWithHintsMap:(HintsMap *)hintsMap
                                                           withFlagEncoder:(id<FlagEncoder>)encoder {
  NSString *weighting = [((NSString *) nil_chk([((HintsMap *) nil_chk(hintsMap)) getWeighting])) lowercaseString];
  if ([((id<FlagEncoder>) nil_chk(encoder)) supportsWithIOSClass:ComGraphhopperRoutingWeightingGenericWeighting_class_()]) {
    DataFlagEncoder *dataEncoder = (DataFlagEncoder *) check_class_cast(encoder, [DataFlagEncoder class]);
    return [[[ComGraphhopperRoutingWeightingGenericWeighting alloc] initWithDataFlagEncoder:dataEncoder withConfigMap:[dataEncoder readStringMapWithPMap:hintsMap]] autorelease];
  }
  else if ([@"shortest" equalsIgnoreCase:weighting]) {
    return [[[ComGraphhopperRoutingWeightingShortestWeighting alloc] initWithFlagEncoder:encoder] autorelease];
  }
  else if ([@"fastest" equalsIgnoreCase:weighting] || [((NSString *) nil_chk(weighting)) isEmpty]) {
    if ([encoder supportsWithIOSClass:ComGraphhopperRoutingWeightingPriorityWeighting_class_()]) return [[[ComGraphhopperRoutingWeightingPriorityWeighting alloc] initWithFlagEncoder:encoder withPMap:hintsMap] autorelease];
    else return [[[ComGraphhopperRoutingWeightingFastestWeighting alloc] initWithFlagEncoder:encoder withPMap:hintsMap] autorelease];
  }
  else if ([@"curvature" equalsIgnoreCase:weighting]) {
    if ([encoder supportsWithIOSClass:ComGraphhopperRoutingWeightingCurvatureWeighting_class_()]) return [[[ComGraphhopperRoutingWeightingCurvatureWeighting alloc] initWithFlagEncoder:encoder withPMap:hintsMap] autorelease];
  }
  else if ([@"short_fastest" equalsIgnoreCase:weighting]) {
    return [[[ComGraphhopperRoutingWeightingShortFastestWeighting alloc] initWithFlagEncoder:encoder withPMap:hintsMap] autorelease];
  }
  @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$$$", @"weighting ", weighting, @" not supported")] autorelease];
}

- (id<ComGraphhopperRoutingWeightingWeighting>)createTurnWeightingWithGraph:(id<Graph>)graph
                                withComGraphhopperRoutingWeightingWeighting:(id<ComGraphhopperRoutingWeightingWeighting>)weighting
                                                      withTraversalModeEnum:(TraversalModeEnum *)tMode {
  id<FlagEncoder> encoder = [((id<ComGraphhopperRoutingWeightingWeighting>) nil_chk(weighting)) getFlagEncoder];
  if ([((id<FlagEncoder>) nil_chk(encoder)) supportsWithIOSClass:ComGraphhopperRoutingWeightingTurnWeighting_class_()] && ![((TraversalModeEnum *) nil_chk(tMode)) isEqual:TraversalModeEnum_get_NODE_BASED()]) return [[[ComGraphhopperRoutingWeightingTurnWeighting alloc] initWithComGraphhopperRoutingWeightingWeighting:weighting withTurnCostExtension:(TurnCostExtension *) check_class_cast([((id<Graph>) nil_chk(graph)) getExtension], [TurnCostExtension class])] autorelease];
  return weighting;
}

- (GHResponse *)routeWithGHRequest:(GHRequest *)request {
  GHResponse *response = [[[GHResponse alloc] init] autorelease];
  [self calcPathsWithGHRequest:request withGHResponse:response];
  return response;
}

- (id<JavaUtilList>)calcPathsWithGHRequest:(GHRequest *)request
                            withGHResponse:(GHResponse *)ghRsp {
  if (ghStorage_ == nil || !fullyLoaded_) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Do a successful call to load or importOrLoad before routing"] autorelease];
  if ([((GraphHopperStorage *) nil_chk(ghStorage_)) isClosed]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"You need to create a new GraphHopper instance as it is already closed"] autorelease];
  NSString *vehicle = [((GHRequest *) nil_chk(request)) getVehicle];
  if ([((NSString *) nil_chk(vehicle)) isEmpty]) {
    vehicle = [((id<FlagEncoder>) nil_chk([self getDefaultVehicle])) description];
    [request setVehicleWithNSString:vehicle];
  }
  @try {
    if (![((EncodingManager *) nil_chk(encodingManager_)) supportsWithNSString:vehicle]) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$$$@", @"Vehicle ", vehicle, @" unsupported. Supported are: ", [self getEncodingManager])] autorelease];
    HintsMap *hints = [request getHints];
    NSString *tModeStr = [((HintsMap *) nil_chk(hints)) getWithNSString:@"traversal_mode" withNSString:[((TraversalModeEnum *) nil_chk(traversalMode_)) description]];
    TraversalModeEnum *tMode = TraversalModeEnum_fromStringWithNSString_(tModeStr);
    if ([hints hasWithNSString:Parameters_Routing_get_EDGE_BASED_()]) tMode = [hints getBoolWithNSString:Parameters_Routing_get_EDGE_BASED_() withBoolean:NO] ? TraversalModeEnum_get_EDGE_BASED_2DIR() : TraversalModeEnum_get_NODE_BASED();
    id<FlagEncoder> encoder = [encodingManager_ getEncoderWithNSString:vehicle];
    id<JavaUtilList> points = [request getPoints];
    NSString *algoStr = [((NSString *) nil_chk([request getAlgorithm])) isEmpty] ? Parameters_Algorithms_get_DIJKSTRA_BI_() : [request getAlgorithm];
    GraphHopper_checkIfPointsAreInBoundsWithJavaUtilList_(self, points);
    id<ComGraphhopperRoutingTemplateRoutingTemplate> routingTemplate;
    if ([((NSString *) nil_chk(Parameters_Algorithms_get_ROUND_TRIP_())) equalsIgnoreCase:algoStr]) routingTemplate = [[[ComGraphhopperRoutingTemplateRoundTripRoutingTemplate alloc] initWithGHRequest:request withGHResponse:ghRsp withLocationIndex:locationIndex_ withInt:maxRoundTripRetries_] autorelease];
    else if ([((NSString *) nil_chk(Parameters_Algorithms_get_ALT_ROUTE_())) equalsIgnoreCase:algoStr]) routingTemplate = [[[ComGraphhopperRoutingTemplateAlternativeRoutingTemplate alloc] initWithGHRequest:request withGHResponse:ghRsp withLocationIndex:locationIndex_] autorelease];
    else routingTemplate = [[[ComGraphhopperRoutingTemplateViaRoutingTemplate alloc] initWithGHRequest:request withGHResponse:ghRsp withLocationIndex:locationIndex_] autorelease];
    id<JavaUtilList> altPaths = nil;
    id<JavaUtilList> qResults = nil;
    jint maxRetries = [((id<ComGraphhopperRoutingTemplateRoutingTemplate>) nil_chk(routingTemplate)) getMaxRetries];
    JavaUtilLocale *locale = [request getLocale];
    id<Translation> tr = [((TranslationMap *) nil_chk(trMap_)) getWithFallBackWithJavaUtilLocale:locale];
    for (jint i = 0; i < maxRetries; i++) {
      StopWatch *sw = [((StopWatch *) [[[StopWatch alloc] init] autorelease]) start];
      qResults = [routingTemplate lookupWithJavaUtilList:points withFlagEncoder:encoder];
      [((GHResponse *) nil_chk(ghRsp)) addDebugInfoWithNSString:JreStrcat("$FC", @"idLookup:", [((StopWatch *) nil_chk([((StopWatch *) nil_chk(sw)) stop])) getSeconds], 's')];
      if ([ghRsp hasErrors]) return JavaUtilCollections_emptyList();
      id<RoutingAlgorithmFactory> tmpAlgoFactory = [self getAlgorithmFactoryWithHintsMap:hints];
      id<ComGraphhopperRoutingWeightingWeighting> weighting = nil;
      id<Graph> routingGraph = ghStorage_;
      jboolean forceFlexibleMode = [hints getBoolWithNSString:Parameters_CH_get_DISABLE_() withBoolean:NO];
      if (![((CHAlgoFactoryDecorator *) nil_chk(chFactoryDecorator_)) isDisablingAllowed] && forceFlexibleMode) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Flexible mode not enabled on the server-side"] autorelease];
      if ([chFactoryDecorator_ isEnabled] && !forceFlexibleMode) {
        jboolean forceCHHeading = [hints getBoolWithNSString:Parameters_CH_get_FORCE_HEADING_() withBoolean:NO];
        if (!forceCHHeading && [request hasFavoredHeadingWithInt:0]) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Heading is not (fully) supported for CHGraph. See issue #483"] autorelease];
        else if (!([tmpAlgoFactory isKindOfClass:[PrepareContractionHierarchies class]])) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$@", @"Although CH was enabled a non-CH algorithm factory was returned ", tmpAlgoFactory)] autorelease];
        tMode = [((CHAlgoFactoryDecorator *) nil_chk(GraphHopper_getCHFactoryDecorator(self))) getNodeBase];
        weighting = [((PrepareContractionHierarchies *) nil_chk(((PrepareContractionHierarchies *) check_class_cast(tmpAlgoFactory, [PrepareContractionHierarchies class])))) getWeighting];
        routingGraph = [ghStorage_ getGraphWithIOSClass:CHGraph_class_() withComGraphhopperRoutingWeightingWeighting:weighting];
      }
      else {
        weighting = [self createWeightingWithHintsMap:hints withFlagEncoder:encoder];
        [ghRsp addDebugInfoWithNSString:JreStrcat("$$", @"tmode:", [((TraversalModeEnum *) nil_chk(tMode)) description])];
      }
      jint maxVisitedNodesForRequest = [hints getIntWithNSString:Parameters_Routing_get_MAX_VISITED_NODES_() withInt:maxVisitedNodes_];
      if (maxVisitedNodesForRequest > maxVisitedNodes_) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$I", @"The max_visited_nodes parameter has to be below or equal to:", maxVisitedNodes_)] autorelease];
      QueryGraph *queryGraph = [[[QueryGraph alloc] initWithGraph:routingGraph] autorelease];
      [queryGraph lookupWithJavaUtilList:qResults];
      weighting = [self createTurnWeightingWithGraph:queryGraph withComGraphhopperRoutingWeightingWeighting:weighting withTraversalModeEnum:tMode];
      AlgorithmOptions *algoOpts = [((AlgorithmOptions_Builder *) nil_chk([((AlgorithmOptions_Builder *) nil_chk([((AlgorithmOptions_Builder *) nil_chk([((AlgorithmOptions_Builder *) nil_chk([((AlgorithmOptions_Builder *) nil_chk([((AlgorithmOptions_Builder *) nil_chk(AlgorithmOptions_start())) algorithmWithNSString:algoStr])) traversalModeWithTraversalModeEnum:tMode])) weightingWithComGraphhopperRoutingWeightingWeighting:weighting])) maxVisitedNodesWithInt:maxVisitedNodesForRequest])) hintsWithPMap:hints])) build];
      altPaths = [routingTemplate calcPathsWithQueryGraph:queryGraph withRoutingAlgorithmFactory:tmpAlgoFactory withAlgorithmOptions:algoOpts];
      jboolean tmpEnableInstructions = [hints getBoolWithNSString:Parameters_Routing_get_INSTRUCTIONS_() withBoolean:enableInstructions_];
      jboolean tmpCalcPoints = [hints getBoolWithNSString:Parameters_Routing_get_CALC_POINTS_() withBoolean:calcPoints_];
      jdouble wayPointMaxDistance = [hints getDoubleWithNSString:Parameters_Routing_get_WAY_POINT_MAX_DISTANCE_() withDouble:1.0];
      DouglasPeucker *peucker = [((DouglasPeucker *) [[[DouglasPeucker alloc] init] autorelease]) setMaxDistanceWithDouble:wayPointMaxDistance];
      PathMerger *pathMerger = [((PathMerger *) nil_chk([((PathMerger *) nil_chk([((PathMerger *) nil_chk([((PathMerger *) [[[PathMerger alloc] init] autorelease]) setCalcPointsWithBoolean:tmpCalcPoints])) setDouglasPeuckerWithDouglasPeucker:peucker])) setEnableInstructionsWithBoolean:tmpEnableInstructions])) setSimplifyResponseWithBoolean:simplifyResponse_ && wayPointMaxDistance > 0];
      if ([routingTemplate isReadyWithPathMerger:pathMerger withTranslation:tr]) break;
    }
    return altPaths;
  }
  @catch (JavaLangIllegalArgumentException *ex) {
    [((GHResponse *) nil_chk(ghRsp)) addErrorWithJavaLangThrowable:ex];
    return JavaUtilCollections_emptyList();
  }
}

- (void)checkIfPointsAreInBoundsWithJavaUtilList:(id<JavaUtilList>)points {
  GraphHopper_checkIfPointsAreInBoundsWithJavaUtilList_(self, points);
}

- (id<LocationIndex>)createLocationIndexWithDirectory:(id<Directory>)dir {
  LocationIndexTree *tmpIndex = [[[LocationIndexTree alloc] initWithGraph:ghStorage_ withDirectory:dir] autorelease];
  [tmpIndex setResolutionWithInt:preciseIndexResolution_];
  [tmpIndex setMaxRegionSearchWithInt:maxRegionSearch_];
  if (![tmpIndex loadExisting]) {
    [self ensureWriteAccess];
    [tmpIndex prepareIndex];
  }
  return tmpIndex;
}

- (void)initLocationIndex {
  if (locationIndex_ != nil) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Cannot initialize locationIndex twice!"] autorelease];
  GraphHopper_set_locationIndex_(self, [self createLocationIndexWithDirectory:[((GraphHopperStorage *) nil_chk(ghStorage_)) getDirectory]]);
}

- (void)prepare {
  jboolean tmpPrepare = [((CHAlgoFactoryDecorator *) nil_chk(chFactoryDecorator_)) isEnabled];
  if (tmpPrepare) {
    [self ensureWriteAccess];
    if ([chFactoryDecorator_ getPreparationThreads] > 1 && [((DAType *) nil_chk(dataAccessType_)) isMMap] && ![dataAccessType_ isSynched]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"You cannot execute CH preparation in parallel for MMAP without synching! Specify MMAP_SYNC or use 1 thread only"] autorelease];
    [((GraphHopperStorage *) nil_chk(ghStorage_)) freeze];
    [chFactoryDecorator_ prepareWithStorableProperties:[ghStorage_ getProperties]];
  }
  [((StorableProperties *) nil_chk([((GraphHopperStorage *) nil_chk(ghStorage_)) getProperties])) putWithNSString:@"prepare.done" withId:JavaLangBoolean_valueOfWithBoolean_(tmpPrepare)];
}

- (void)cleanUp {
  jint prevNodeCount = [((GraphHopperStorage *) nil_chk(ghStorage_)) getNodes];
  ComGraphhopperRoutingSubnetworkPrepareRoutingSubnetworks *preparation = [[[ComGraphhopperRoutingSubnetworkPrepareRoutingSubnetworks alloc] initWithGraphHopperStorage:ghStorage_ withJavaUtilList:[((EncodingManager *) nil_chk(encodingManager_)) fetchEdgeEncoders]] autorelease];
  [preparation setMinNetworkSizeWithInt:minNetworkSize_];
  [preparation setMinOneWayNetworkSizeWithInt:minOneWayNetworkSize_];
  [((id<OrgSlf4jLogger>) nil_chk(logger_)) infoWithNSString:JreStrcat("$$", @"start finding subnetworks, ", Helper_getMemInfo())];
  [preparation doWork];
  jint currNodeCount = [ghStorage_ getNodes];
  [logger_ infoWithNSString:JreStrcat("$I$I$I$I$", @"edges: ", [((id<AllEdgesIterator>) nil_chk([ghStorage_ getAllEdges])) getMaxId], @", nodes ", currNodeCount, @", there were ", [preparation getMaxSubnetworks], @" subnetworks. removed them => ", (prevNodeCount - currNodeCount), @" less nodes")];
}

- (void)flush {
  [((id<OrgSlf4jLogger>) nil_chk(logger_)) infoWithNSString:JreStrcat("$$$$$$C", @"flushing graph ", [((GraphHopperStorage *) nil_chk(ghStorage_)) description], @", details:", [ghStorage_ toDetailsString], @", ", Helper_getMemInfo(), ')')];
  [ghStorage_ flush];
  [logger_ infoWithNSString:JreStrcat("$$C", @"flushed graph ", Helper_getMemInfo(), ')')];
  fullyLoaded_ = YES;
}

- (void)close {
  if (ghStorage_ != nil) [ghStorage_ close];
  if (locationIndex_ != nil) [locationIndex_ close];
  @try {
    [((id<LockFactory>) nil_chk(lockFactory_)) forceRemoveWithNSString:fileLockName_ withBoolean:YES];
  }
  @catch (JavaLangException *ex) {
  }
}

- (void)clean {
  if ([((NSString *) nil_chk([self getGraphHopperLocation])) isEmpty]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Cannot clean GraphHopper without specified graphHopperLocation"] autorelease];
  JavaIoFile *folder = [[[JavaIoFile alloc] initWithNSString:[self getGraphHopperLocation]] autorelease];
  Helper_removeDirWithJavaIoFile_(folder);
}

- (void)ensureNotLoaded {
  if (fullyLoaded_) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"No configuration changes are possible after loading the graph"] autorelease];
}

- (void)ensureWriteAccess {
  if (!allowWrites_) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Writes are not allowed!"] autorelease];
}

- (void)dealloc {
  RELEASE_(logger_);
  RELEASE_(fileLockName_);
  RELEASE_(algoDecorators_);
  RELEASE_(chFactoryDecorator_);
  RELEASE_(trMap_);
  RELEASE_(ghStorage_);
  RELEASE_(encodingManager_);
  RELEASE_(ghLocation_);
  RELEASE_(dataAccessType_);
  RELEASE_(lockFactory_);
  RELEASE_(preferredLanguage_);
  RELEASE_(traversalMode_);
  RELEASE_(locationIndex_);
  RELEASE_(dataReaderFile_);
  RELEASE_(eleProvider_);
  RELEASE_(flagEncoderFactory_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(GraphHopper *)other {
  [super copyAllFieldsTo:other];
  GraphHopper_set_logger_(other, logger_);
  GraphHopper_set_fileLockName_(other, fileLockName_);
  GraphHopper_set_algoDecorators_(other, algoDecorators_);
  GraphHopper_set_chFactoryDecorator_(other, chFactoryDecorator_);
  GraphHopper_set_trMap_(other, trMap_);
  other->removeZipped_ = removeZipped_;
  other->enableInstructions_ = enableInstructions_;
  GraphHopper_set_ghStorage_(other, ghStorage_);
  GraphHopper_set_encodingManager_(other, encodingManager_);
  other->defaultSegmentSize_ = defaultSegmentSize_;
  GraphHopper_set_ghLocation_(other, ghLocation_);
  GraphHopper_set_dataAccessType_(other, dataAccessType_);
  other->sortGraph_ = sortGraph_;
  other->elevation_ = elevation_;
  GraphHopper_set_lockFactory_(other, lockFactory_);
  other->allowWrites_ = allowWrites_;
  GraphHopper_set_preferredLanguage_(other, preferredLanguage_);
  other->fullyLoaded_ = fullyLoaded_;
  other->maxRoundTripRetries_ = maxRoundTripRetries_;
  other->simplifyResponse_ = simplifyResponse_;
  GraphHopper_set_traversalMode_(other, traversalMode_);
  other->maxVisitedNodes_ = maxVisitedNodes_;
  GraphHopper_set_locationIndex_(other, locationIndex_);
  other->preciseIndexResolution_ = preciseIndexResolution_;
  other->maxRegionSearch_ = maxRegionSearch_;
  other->minNetworkSize_ = minNetworkSize_;
  other->minOneWayNetworkSize_ = minOneWayNetworkSize_;
  GraphHopper_set_dataReaderFile_(other, dataReaderFile_);
  other->dataReaderWayPointMaxDistance_ = dataReaderWayPointMaxDistance_;
  other->dataReaderWorkerThreads_ = dataReaderWorkerThreads_;
  other->calcPoints_ = calcPoints_;
  GraphHopper_set_eleProvider_(other, eleProvider_);
  GraphHopper_set_flagEncoderFactory_(other, flagEncoderFactory_);
}

+ (IOSObjectArray *)__annotations_setCHWeightingWithNSString_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [[[JavaLangDeprecated alloc] init] autorelease] } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "GraphHopper", NULL, 0x1, NULL },
    { "loadGraphWithGraphHopperStorage:", "loadGraph", "Lcom.graphhopper.GraphHopper;", 0x4, NULL },
    { "getDefaultVehicle", NULL, "Lcom.graphhopper.routing.util.FlagEncoder;", 0x0, NULL },
    { "getEncodingManager", NULL, "Lcom.graphhopper.routing.util.EncodingManager;", 0x1, NULL },
    { "setEncodingManagerWithEncodingManager:", "setEncodingManager", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "getElevationProvider", NULL, "Lcom.graphhopper.reader.dem.ElevationProvider;", 0x1, NULL },
    { "setElevationProviderWithComGraphhopperReaderDemElevationProvider:", "setElevationProvider", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "getWorkerThreads", NULL, "I", 0x4, NULL },
    { "getWayPointMaxDistance", NULL, "D", 0x4, NULL },
    { "setWayPointMaxDistanceWithDouble:", "setWayPointMaxDistance", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "getTraversalMode", NULL, "Lcom.graphhopper.routing.util.TraversalMode;", 0x1, NULL },
    { "setTraversalModeWithTraversalModeEnum:", "setTraversalMode", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "forServer", NULL, "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "forDesktop", NULL, "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "forMobile", NULL, "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "setPreciseIndexResolutionWithInt:", "setPreciseIndexResolution", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "setMinNetworkSizeWithInt:withInt:", "setMinNetworkSize", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "setInMemory", NULL, "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "setStoreOnFlushWithBoolean:", "setStoreOnFlush", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "setMemoryMapped", NULL, "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "setUnsafeMemory", NULL, "Lcom.graphhopper.GraphHopper;", 0x2, NULL },
    { "setCHWeightingWithNSString:", "setCHWeighting", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "setCHWeightingsWithNSStringArray:", "setCHWeightings", "Lcom.graphhopper.GraphHopper;", 0x81, NULL },
    { "getCHWeightings", NULL, "Ljava.util.List;", 0x1, NULL },
    { "setCHWeightingsWithJavaUtilList:", "setCHWeightings", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "getCHPrepareThreads", NULL, "I", 0x1, NULL },
    { "setCHPrepareThreadsWithInt:", "setCHPrepareThreads", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "setCHEnableWithBoolean:", "setCHEnable", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "isCHEnabled", NULL, "Z", 0x11, NULL },
    { "setCHEnabledWithBoolean:", "setCHEnabled", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "getMaxVisitedNodes", NULL, "I", 0x1, NULL },
    { "setMaxVisitedNodesWithInt:", "setMaxVisitedNodes", "V", 0x1, NULL },
    { "hasElevation", NULL, "Z", 0x1, NULL },
    { "setElevationWithBoolean:", "setElevation", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "isEnableInstructions", NULL, "Z", 0x1, NULL },
    { "setEnableInstructionsWithBoolean:", "setEnableInstructions", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "getPreferredLanguage", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "setPreferredLanguageWithNSString:", "setPreferredLanguage", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "setEnableCalcPointsWithBoolean:", "setEnableCalcPoints", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "setSimplifyResponseWithBoolean:", "setSimplifyResponse", "Lcom.graphhopper.GraphHopper;", 0x2, NULL },
    { "getGraphHopperLocation", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "setGraphHopperLocationWithNSString:", "setGraphHopperLocation", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "getDataReaderFile", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "setDataReaderFileWithNSString:", "setDataReaderFile", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "getGraphHopperStorage", NULL, "Lcom.graphhopper.storage.GraphHopperStorage;", 0x1, NULL },
    { "setGraphHopperStorageWithGraphHopperStorage:", "setGraphHopperStorage", "V", 0x1, NULL },
    { "getLocationIndex", NULL, "Lcom.graphhopper.storage.index.LocationIndex;", 0x1, NULL },
    { "setLocationIndexWithLocationIndex:", "setLocationIndex", "V", 0x4, NULL },
    { "setSortGraphWithBoolean:", "setSortGraph", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "isAllowWrites", NULL, "Z", 0x1, NULL },
    { "setAllowWritesWithBoolean:", "setAllowWrites", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "getTranslationMap", NULL, "Lcom.graphhopper.util.TranslationMap;", 0x1, NULL },
    { "setFlagEncoderFactoryWithFlagEncoderFactory:", "setFlagEncoderFactory", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "init__WithCmdArgs:", "init", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "printInfo", NULL, "V", 0x2, NULL },
    { "importOrLoad", NULL, "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "processWithNSString:", "process", "Lcom.graphhopper.GraphHopper;", 0x2, NULL },
    { "importData", NULL, "Lcom.graphhopper.reader.DataReader;", 0x4, "Ljava.io.IOException;" },
    { "createReaderWithGraphHopperStorage:", "createReader", "Lcom.graphhopper.reader.DataReader;", 0x4, NULL },
    { "initDataReaderWithDataReader:", "initDataReader", "Lcom.graphhopper.reader.DataReader;", 0x4, NULL },
    { "load__WithNSString:", "load", "Z", 0x1, NULL },
    { "getAlgorithmFactoryWithHintsMap:", "getAlgorithmFactory", "Lcom.graphhopper.routing.RoutingAlgorithmFactory;", 0x1, NULL },
    { "addAlgorithmFactoryDecoratorWithRoutingAlgorithmFactoryDecorator:", "addAlgorithmFactoryDecorator", "Lcom.graphhopper.GraphHopper;", 0x1, NULL },
    { "getCHFactoryDecorator", NULL, "Lcom.graphhopper.routing.ch.CHAlgoFactoryDecorator;", 0x11, NULL },
    { "initCHAlgoFactoryDecorator", NULL, "V", 0x2, NULL },
    { "createCHPreparations", NULL, "V", 0x4, NULL },
    { "postProcessing", NULL, "V", 0x1, NULL },
    { "interpolateBridgesAndOrTunnels", NULL, "V", 0x2, NULL },
    { "isPrepared", NULL, "Z", 0x2, NULL },
    { "createWeightingWithHintsMap:withFlagEncoder:", "createWeighting", "Lcom.graphhopper.routing.weighting.Weighting;", 0x1, NULL },
    { "createTurnWeightingWithGraph:withComGraphhopperRoutingWeightingWeighting:withTraversalModeEnum:", "createTurnWeighting", "Lcom.graphhopper.routing.weighting.Weighting;", 0x1, NULL },
    { "routeWithGHRequest:", "route", "Lcom.graphhopper.GHResponse;", 0x1, NULL },
    { "calcPathsWithGHRequest:withGHResponse:", "calcPaths", "Ljava.util.List;", 0x1, NULL },
    { "checkIfPointsAreInBoundsWithJavaUtilList:", "checkIfPointsAreInBounds", "V", 0x2, NULL },
    { "createLocationIndexWithDirectory:", "createLocationIndex", "Lcom.graphhopper.storage.index.LocationIndex;", 0x4, NULL },
    { "initLocationIndex", NULL, "V", 0x4, NULL },
    { "prepare", NULL, "V", 0x4, NULL },
    { "cleanUp", NULL, "V", 0x4, NULL },
    { "flush", NULL, "V", 0x4, NULL },
    { "close", NULL, "V", 0x1, NULL },
    { "clean", NULL, "V", 0x1, NULL },
    { "ensureNotLoaded", NULL, "V", 0x4, NULL },
    { "ensureWriteAccess", NULL, "V", 0x4, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "logger_", NULL, 0x12, "Lorg.slf4j.Logger;", NULL,  },
    { "fileLockName_", NULL, 0x12, "Ljava.lang.String;", NULL,  },
    { "algoDecorators_", NULL, 0x12, "Ljava.util.Set;", NULL,  },
    { "chFactoryDecorator_", NULL, 0x12, "Lcom.graphhopper.routing.ch.CHAlgoFactoryDecorator;", NULL,  },
    { "trMap_", NULL, 0x12, "Lcom.graphhopper.util.TranslationMap;", NULL,  },
    { "removeZipped_", NULL, 0x0, "Z", NULL,  },
    { "enableInstructions_", NULL, 0x0, "Z", NULL,  },
    { "ghStorage_", NULL, 0x2, "Lcom.graphhopper.storage.GraphHopperStorage;", NULL,  },
    { "encodingManager_", NULL, 0x2, "Lcom.graphhopper.routing.util.EncodingManager;", NULL,  },
    { "defaultSegmentSize_", NULL, 0x2, "I", NULL,  },
    { "ghLocation_", NULL, 0x2, "Ljava.lang.String;", NULL,  },
    { "dataAccessType_", NULL, 0x2, "Lcom.graphhopper.storage.DAType;", NULL,  },
    { "sortGraph_", NULL, 0x2, "Z", NULL,  },
    { "elevation_", NULL, 0x2, "Z", NULL,  },
    { "lockFactory_", NULL, 0x2, "Lcom.graphhopper.storage.LockFactory;", NULL,  },
    { "allowWrites_", NULL, 0x2, "Z", NULL,  },
    { "preferredLanguage_", NULL, 0x2, "Ljava.lang.String;", NULL,  },
    { "fullyLoaded_", NULL, 0x2, "Z", NULL,  },
    { "maxRoundTripRetries_", NULL, 0x2, "I", NULL,  },
    { "simplifyResponse_", NULL, 0x2, "Z", NULL,  },
    { "traversalMode_", NULL, 0x2, "Lcom.graphhopper.routing.util.TraversalMode;", NULL,  },
    { "maxVisitedNodes_", NULL, 0x2, "I", NULL,  },
    { "locationIndex_", NULL, 0x2, "Lcom.graphhopper.storage.index.LocationIndex;", NULL,  },
    { "preciseIndexResolution_", NULL, 0x2, "I", NULL,  },
    { "maxRegionSearch_", NULL, 0x2, "I", NULL,  },
    { "minNetworkSize_", NULL, 0x2, "I", NULL,  },
    { "minOneWayNetworkSize_", NULL, 0x2, "I", NULL,  },
    { "dataReaderFile_", NULL, 0x2, "Ljava.lang.String;", NULL,  },
    { "dataReaderWayPointMaxDistance_", NULL, 0x2, "D", NULL,  },
    { "dataReaderWorkerThreads_", NULL, 0x2, "I", NULL,  },
    { "calcPoints_", NULL, 0x2, "Z", NULL,  },
    { "eleProvider_", NULL, 0x2, "Lcom.graphhopper.reader.dem.ElevationProvider;", NULL,  },
    { "flagEncoderFactory_", NULL, 0x2, "Lcom.graphhopper.routing.util.FlagEncoderFactory;", NULL,  },
  };
  static const J2ObjcClassInfo _GraphHopper = { 1, "GraphHopper", "com.graphhopper", NULL, 0x1, 83, methods, 33, fields, 0, NULL};
  return &_GraphHopper;
}

@end

GraphHopper *GraphHopper_setSimplifyResponseWithBoolean_(GraphHopper *self, jboolean doSimplify) {
  self->simplifyResponse_ = doSimplify;
  return self;
}

void GraphHopper_printInfo(GraphHopper *self) {
  [((id<OrgSlf4jLogger>) nil_chk(self->logger_)) infoWithNSString:JreStrcat("$$C$$$C", @"version ", Constants_get_VERSION_(), '|', Constants_get_BUILD_DATE_(), @" (", Constants_getVersions(), ')')];
  if (self->ghStorage_ != nil) [self->logger_ infoWithNSString:JreStrcat("$$$$", @"graph ", [self->ghStorage_ description], @", details:", [self->ghStorage_ toDetailsString])];
}

GraphHopper *GraphHopper_processWithNSString_(GraphHopper *self, NSString *graphHopperLocation) {
  [self setGraphHopperLocationWithNSString:graphHopperLocation];
  id<Lock> lock = nil;
  @try {
    if ([((DAType *) nil_chk([((id<Directory>) nil_chk([((GraphHopperStorage *) nil_chk(self->ghStorage_)) getDirectory])) getDefaultType])) isStoring]) {
      [((id<LockFactory>) nil_chk(self->lockFactory_)) setLockDirWithJavaIoFile:[[[JavaIoFile alloc] initWithNSString:graphHopperLocation] autorelease]];
      lock = [self->lockFactory_ createWithNSString:self->fileLockName_ withBoolean:YES];
      if (![((id<Lock>) nil_chk(lock)) tryLock]) @throw [[[JavaLangRuntimeException alloc] initWithNSString:JreStrcat("$$", @"To avoid multiple writers we need to obtain a write lock but it failed. In ", graphHopperLocation) withJavaLangThrowable:[lock getObtainFailedReason]] autorelease];
    }
    @try {
      id<DataReader> reader = [self importData];
      JavaTextDateFormat *f = Helper_createFormatter();
      [((StorableProperties *) nil_chk([self->ghStorage_ getProperties])) putWithNSString:@"datareader.import.date" withNSString:[((JavaTextDateFormat *) nil_chk(f)) formatWithJavaUtilDate:[[[JavaUtilDate alloc] init] autorelease]]];
      if ([((id<DataReader>) nil_chk(reader)) getDataDate] != nil) [((StorableProperties *) nil_chk([self->ghStorage_ getProperties])) putWithNSString:@"datareader.data.date" withNSString:[f formatWithJavaUtilDate:[reader getDataDate]]];
    }
    @catch (JavaIoIOException *ex) {
      @throw [[[JavaLangRuntimeException alloc] initWithNSString:JreStrcat("$$", @"Cannot read file ", [self getDataReaderFile]) withJavaLangThrowable:ex] autorelease];
    }
    [self cleanUp];
    [self postProcessing];
    [self flush];
  }
  @finally {
    if (lock != nil) [lock release__];
  }
  return self;
}

CHAlgoFactoryDecorator *GraphHopper_getCHFactoryDecorator(GraphHopper *self) {
  return self->chFactoryDecorator_;
}

void GraphHopper_initCHAlgoFactoryDecorator(GraphHopper *self) {
  if (![((CHAlgoFactoryDecorator *) nil_chk(self->chFactoryDecorator_)) hasWeightings]) for (id<FlagEncoder> __strong encoder in nil_chk([((EncodingManager *) nil_chk(self->encodingManager_)) fetchEdgeEncoders])) {
    for (NSString * __strong chWeightingStr in nil_chk([self->chFactoryDecorator_ getWeightingsAsStrings])) {
      id<ComGraphhopperRoutingWeightingWeighting> weighting = [self createWeightingWithHintsMap:[[[HintsMap alloc] initWithNSString:chWeightingStr] autorelease] withFlagEncoder:encoder];
      [self->chFactoryDecorator_ addWeightingWithComGraphhopperRoutingWeightingWeighting:weighting];
    }
  }
}

void GraphHopper_interpolateBridgesAndOrTunnels(GraphHopper *self) {
  if ([((EncodingManager *) nil_chk([((GraphHopperStorage *) nil_chk(self->ghStorage_)) getEncodingManager])) supportsWithNSString:@"generic"]) {
    id<FlagEncoder> genericFlagEncoder = [((EncodingManager *) nil_chk([self->ghStorage_ getEncodingManager])) getEncoderWithNSString:@"generic"];
    if (!([genericFlagEncoder isKindOfClass:[DataFlagEncoder class]])) {
      @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$$C", @"'generic' flag encoder for elevation interpolation of bridges and tunnels is enabled but does not have the expected type ", [DataFlagEncoder_class_() getName], '.')] autorelease];
    }
    DataFlagEncoder *dataFlagEncoder = (DataFlagEncoder *) check_class_cast(genericFlagEncoder, [DataFlagEncoder class]);
    StopWatch *sw = [((StopWatch *) [[[StopWatch alloc] init] autorelease]) start];
    [((ComGraphhopperReaderDemTunnelElevationInterpolator *) [[[ComGraphhopperReaderDemTunnelElevationInterpolator alloc] initWithGraphHopperStorage:self->ghStorage_ withDataFlagEncoder:dataFlagEncoder] autorelease]) execute];
    jfloat tunnel = [((StopWatch *) nil_chk([((StopWatch *) nil_chk(sw)) stop])) getSeconds];
    sw = [((StopWatch *) [[[StopWatch alloc] init] autorelease]) start];
    [((ComGraphhopperReaderDemBridgeElevationInterpolator *) [[[ComGraphhopperReaderDemBridgeElevationInterpolator alloc] initWithGraphHopperStorage:self->ghStorage_ withDataFlagEncoder:dataFlagEncoder] autorelease]) execute];
    [((id<OrgSlf4jLogger>) nil_chk(self->logger_)) infoWithNSString:JreStrcat("$I$IC", @"Bridge interpolation ", J2ObjCFpToInt([((StopWatch *) nil_chk([((StopWatch *) nil_chk(sw)) stop])) getSeconds]), @"s, tunnel interpolation ", J2ObjCFpToInt(tunnel), 's')];
  }
}

jboolean GraphHopper_isPrepared(GraphHopper *self) {
  return [@"true" isEqual:[((StorableProperties *) nil_chk([((GraphHopperStorage *) nil_chk(self->ghStorage_)) getProperties])) getWithNSString:@"prepare.done"]];
}

void GraphHopper_checkIfPointsAreInBoundsWithJavaUtilList_(GraphHopper *self, id<JavaUtilList> points) {
  BBox *bounds = [((GraphHopperStorage *) nil_chk([self getGraphHopperStorage])) getBounds];
  for (jint i = 0; i < [((id<JavaUtilList>) nil_chk(points)) size]; i++) {
    GHPoint *point = [points getWithInt:i];
    if (![((BBox *) nil_chk(bounds)) containsWithDouble:[((GHPoint *) nil_chk(point)) getLat] withDouble:[point getLon]]) {
      @throw [[[ComGraphhopperUtilExceptionsPointOutOfBoundsException alloc] initWithNSString:JreStrcat("$I$@", @"Point ", i, @" is ouf of bounds: ", point) withInt:i] autorelease];
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GraphHopper)
