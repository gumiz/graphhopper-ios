//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/coll/OSMIDMap.h"
#include "com/graphhopper/storage/DataAccess.h"
#include "com/graphhopper/storage/Directory.h"
#include "com/graphhopper/util/BitUtil.h"
#include "com/graphhopper/util/Helper.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Long.h"
#include "java/lang/Math.h"

@interface OSMIDMap () {
 @public
  id<DataAccess> keys_;
  id<DataAccess> values_;
  jint noEntryValue_;
  id<Directory> dir_;
  jlong lastKey_;
  jlong size_;
}
@end

J2OBJC_FIELD_SETTER(OSMIDMap, keys_, id<DataAccess>)
J2OBJC_FIELD_SETTER(OSMIDMap, values_, id<DataAccess>)
J2OBJC_FIELD_SETTER(OSMIDMap, dir_, id<Directory>)

BOOL OSMIDMap_initialized = NO;

@implementation OSMIDMap

BitUtil * OSMIDMap_bitUtil_;

- (instancetype)initWithDirectory:(id<Directory>)dir {
  return [self initOSMIDMapWithDirectory:dir withInt:-1];
}

- (instancetype)initOSMIDMapWithDirectory:(id<Directory>)dir
                                  withInt:(jint)noNumber {
  if (self = [super init]) {
    lastKey_ = JavaLangLong_MIN_VALUE;
    OSMIDMap_set_dir_(self, dir);
    self->noEntryValue_ = noNumber;
    OSMIDMap_set_keys_(self, [((id<Directory>) nil_chk(dir)) findWithNSString:@"osmid_map_keys"]);
    [((id<DataAccess>) nil_chk(keys_)) createWithLong:2000];
    OSMIDMap_set_values_(self, [dir findWithNSString:@"osmid_map_values"]);
    [((id<DataAccess>) nil_chk(values_)) createWithLong:1000];
  }
  return self;
}

- (instancetype)initWithDirectory:(id<Directory>)dir
                          withInt:(jint)noNumber {
  return [self initOSMIDMapWithDirectory:dir withInt:noNumber];
}

+ (jlong)binarySearchWithDataAccess:(id<DataAccess>)da
                           withLong:(jlong)start
                           withLong:(jlong)len
                           withLong:(jlong)key {
  return OSMIDMap_binarySearchWithDataAccess_withLong_withLong_withLong_(da, start, len, key);
}

- (void)remove {
  [((id<Directory>) nil_chk(dir_)) removeWithDataAccess:keys_];
}

- (jint)putWithLong:(jlong)key
            withInt:(jint)value {
  if (key <= lastKey_) {
    jlong oldValueIndex = OSMIDMap_binarySearchWithDataAccess_withLong_withLong_withLong_(keys_, 0, [self getSize], key);
    if (oldValueIndex < 0) {
      @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$J$J$", @"Cannot insert keys lower than the last key ", key, @" < ", lastKey_, @". Only updating supported")] autorelease];
    }
    oldValueIndex *= 4;
    jint oldValue = [((id<DataAccess>) nil_chk(values_)) getIntWithLong:oldValueIndex];
    [values_ setIntWithLong:oldValueIndex withInt:value];
    return oldValue;
  }
  [((id<DataAccess>) nil_chk(values_)) ensureCapacityWithLong:size_ + 4];
  [values_ setIntWithLong:size_ withInt:value];
  jlong doubleSize = size_ * 2;
  [((id<DataAccess>) nil_chk(keys_)) ensureCapacityWithLong:doubleSize + 8];
  IOSByteArray *longBytes = [((BitUtil *) nil_chk(OSMIDMap_bitUtil_)) fromLongWithLong:key];
  [keys_ setBytesWithLong:doubleSize withByteArray:longBytes withInt:8];
  lastKey_ = key;
  size_ += 4;
  return -1;
}

- (jint)getWithLong:(jlong)key {
  jlong retIndex = OSMIDMap_binarySearchWithDataAccess_withLong_withLong_withLong_(keys_, 0, [self getSize], key);
  if (retIndex < 0) return noEntryValue_;
  return [((id<DataAccess>) nil_chk(values_)) getIntWithLong:retIndex * 4];
}

- (jlong)getSize {
  return size_ / 4;
}

- (jlong)getCapacity {
  return [((id<DataAccess>) nil_chk(keys_)) getCapacity];
}

- (jint)getMemoryUsage {
  return JavaLangMath_roundWithFloat_([self getCapacity] / Helper_MB);
}

- (void)optimize {
}

- (void)dealloc {
  RELEASE_(keys_);
  RELEASE_(values_);
  RELEASE_(dir_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(OSMIDMap *)other {
  [super copyAllFieldsTo:other];
  OSMIDMap_set_keys_(other, keys_);
  OSMIDMap_set_values_(other, values_);
  other->noEntryValue_ = noEntryValue_;
  OSMIDMap_set_dir_(other, dir_);
  other->lastKey_ = lastKey_;
  other->size_ = size_;
}

+ (void)initialize {
  if (self == [OSMIDMap class]) {
    JreStrongAssign(&OSMIDMap_bitUtil_, nil, BitUtil_get_LITTLE_());
    J2OBJC_SET_INITIALIZED(OSMIDMap)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithDirectory:", "OSMIDMap", NULL, 0x1, NULL },
    { "initWithDirectory:withInt:", "OSMIDMap", NULL, 0x1, NULL },
    { "binarySearchWithDataAccess:withLong:withLong:withLong:", "binarySearch", "J", 0x8, NULL },
    { "remove", NULL, "V", 0x1, NULL },
    { "putWithLong:withInt:", "put", "I", 0x1, NULL },
    { "getWithLong:", "get", "I", 0x1, NULL },
    { "getSize", NULL, "J", 0x1, NULL },
    { "getCapacity", NULL, "J", 0x1, NULL },
    { "getMemoryUsage", NULL, "I", 0x1, NULL },
    { "optimize", NULL, "V", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "bitUtil_", NULL, 0x1a, "Lcom.graphhopper.util.BitUtil;", &OSMIDMap_bitUtil_,  },
    { "keys_", NULL, 0x12, "Lcom.graphhopper.storage.DataAccess;", NULL,  },
    { "values_", NULL, 0x12, "Lcom.graphhopper.storage.DataAccess;", NULL,  },
    { "noEntryValue_", NULL, 0x12, "I", NULL,  },
    { "dir_", NULL, 0x12, "Lcom.graphhopper.storage.Directory;", NULL,  },
    { "lastKey_", NULL, 0x2, "J", NULL,  },
    { "size_", NULL, 0x2, "J", NULL,  },
  };
  static const J2ObjcClassInfo _OSMIDMap = { 1, "OSMIDMap", "com.graphhopper.coll", NULL, 0x1, 10, methods, 7, fields, 0, NULL};
  return &_OSMIDMap;
}

@end

jlong OSMIDMap_binarySearchWithDataAccess_withLong_withLong_withLong_(id<DataAccess> da, jlong start, jlong len, jlong key) {
  OSMIDMap_init();
  jlong high = start + len, low = start - 1, guess;
  IOSByteArray *longBytes = [IOSByteArray arrayWithLength:8];
  while (high - low > 1) {
    guess = URShift64((high + low), 1);
    jlong tmp = LShift64(guess, 3);
    [((id<DataAccess>) nil_chk(da)) getBytesWithLong:tmp withByteArray:longBytes withInt:8];
    jlong guessedKey = [((BitUtil *) nil_chk(OSMIDMap_bitUtil_)) toLongWithByteArray:longBytes];
    if (guessedKey < key) low = guess;
    else high = guess;
  }
  if (high == start + len) return ~(start + len);
  jlong tmp = LShift64(high, 3);
  [((id<DataAccess>) nil_chk(da)) getBytesWithLong:tmp withByteArray:longBytes withInt:8];
  jlong highKey = [((BitUtil *) nil_chk(OSMIDMap_bitUtil_)) toLongWithByteArray:longBytes];
  if (highKey == key) return high;
  else return ~high;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OSMIDMap)
