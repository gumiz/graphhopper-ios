//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/coll/CompressedArray.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/coll/CompressedArray.h"
#include "com/graphhopper/geohash/SpatialKeyAlgo.h"
#include "com/graphhopper/storage/VLongStorage.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/shapes/GHPoint.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/lang/ArrayIndexOutOfBoundsException.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/RuntimeException.h"
#include "java/util/ArrayList.h"
#include "java/util/List.h"
#include "java/util/zip/DataFormatException.h"
#include "java/util/zip/Deflater.h"
#include "java/util/zip/Inflater.h"

@interface CompressedArray () {
 @public
  jint compressionLevel_;
  VLongStorage *currentWriter_;
  jint currentEntry_;
  id<JavaUtilList> segments_;
  jint entriesPerSegment_;
  jint approxBytesPerEntry_;
  SpatialKeyAlgo *algo_;
}
@end

J2OBJC_FIELD_SETTER(CompressedArray, currentWriter_, VLongStorage *)
J2OBJC_FIELD_SETTER(CompressedArray, segments_, id<JavaUtilList>)
J2OBJC_FIELD_SETTER(CompressedArray, algo_, SpatialKeyAlgo *)

@implementation CompressedArray

- (instancetype)init {
  return [self initCompressedArrayWithInt:100 withInt:200 withInt:4];
}

- (instancetype)initCompressedArrayWithInt:(jint)_segments
                                   withInt:(jint)entriesPerSeg
                                   withInt:(jint)approxBytesPerEntry {
  if (self = [super init]) {
    compressionLevel_ = 5;
    currentEntry_ = 0;
    if (entriesPerSeg < 1) {
      @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"at least one entry should be per segment"] autorelease];
    }
    self->entriesPerSegment_ = entriesPerSeg;
    self->approxBytesPerEntry_ = approxBytesPerEntry;
    CompressedArray_setAndConsume_segments_(self, [[JavaUtilArrayList alloc] initWithInt:_segments]);
    CompressedArray_setAndConsume_algo_(self, [[SpatialKeyAlgo alloc] initWithInt:63]);
  }
  return self;
}

- (instancetype)initWithInt:(jint)_segments
                    withInt:(jint)entriesPerSeg
                    withInt:(jint)approxBytesPerEntry {
  return [self initCompressedArrayWithInt:_segments withInt:entriesPerSeg withInt:approxBytesPerEntry];
}

+ (IOSByteArray *)compressWithByteArray:(IOSByteArray *)value
                                withInt:(jint)offset
                                withInt:(jint)length
                                withInt:(jint)compressionLevel {
  return CompressedArray_compressWithByteArray_withInt_withInt_withInt_(value, offset, length, compressionLevel);
}

+ (IOSByteArray *)decompressWithByteArray:(IOSByteArray *)value {
  return CompressedArray_decompressWithByteArray_(value);
}

- (CompressedArray *)setCompressionLevelWithInt:(jint)compressionLevel {
  self->compressionLevel_ = compressionLevel;
  return self;
}

- (void)writeWithDouble:(jdouble)lat
             withDouble:(jdouble)lon {
  @try {
    if (currentWriter_ == nil) CompressedArray_setAndConsume_currentWriter_(self, [[VLongStorage alloc] initWithInt:entriesPerSegment_ * approxBytesPerEntry_]);
    jlong latlon = [((SpatialKeyAlgo *) nil_chk(algo_)) encodeWithGHPoint:[[[GHPoint alloc] initWithDouble:lat withDouble:lon] autorelease]];
    [((VLongStorage *) nil_chk(currentWriter_)) writeVLongWithLong:latlon];
    currentEntry_++;
    if (currentEntry_ >= entriesPerSegment_) {
      [self flush];
    }
  }
  @catch (JavaLangException *ex) {
    @throw [[[JavaLangRuntimeException alloc] initWithJavaLangThrowable:ex] autorelease];
  }
}

- (GHPoint *)getWithLong:(jlong)index {
  jint segmentNo = (jint) (index / entriesPerSegment_);
  jint entry_ = (jint) (index % entriesPerSegment_);
  @try {
    if (segmentNo >= [((id<JavaUtilList>) nil_chk(segments_)) size]) {
      return nil;
    }
    IOSByteArray *bytes = [segments_ getWithInt:segmentNo];
    VLongStorage *store = [[[VLongStorage alloc] initWithByteArray:CompressedArray_decompressWithByteArray_(bytes)] autorelease];
    jlong len = [store getLength];
    for (jint i = 0; [store getPosition] < len; i++) {
      jlong latlon = [store readVLong];
      if (i == entry_) {
        GHPoint *point = [[[GHPoint alloc] init] autorelease];
        [((SpatialKeyAlgo *) nil_chk(algo_)) decodeWithLong:latlon withGHPoint:point];
        return point;
      }
    }
    return nil;
  }
  @catch (JavaLangArrayIndexOutOfBoundsException *ex) {
    @throw [[[JavaLangRuntimeException alloc] initWithNSString:JreStrcat("$J$I$I$I", @"index ", index, @"=> segNo:", segmentNo, @", entry=", entry_, @", segments:", [((id<JavaUtilList>) nil_chk(segments_)) size]) withJavaLangThrowable:ex] autorelease];
  }
  @catch (JavaLangException *ex) {
    @throw [[[JavaLangRuntimeException alloc] initWithJavaLangThrowable:ex] autorelease];
  }
}

- (void)flush {
  if (currentWriter_ == nil) {
    return;
  }
  @try {
    [((VLongStorage *) nil_chk(currentWriter_)) trimToSize];
    IOSByteArray *input = [currentWriter_ getBytes];
    [((id<JavaUtilList>) nil_chk(segments_)) addWithId:CompressedArray_compressWithByteArray_withInt_withInt_withInt_(input, 0, ((IOSByteArray *) nil_chk(input))->size_, compressionLevel_)];
    CompressedArray_set_currentWriter_(self, nil);
    currentEntry_ = 0;
  }
  @catch (JavaLangException *ex) {
    @throw [[[JavaLangRuntimeException alloc] initWithJavaLangThrowable:ex] autorelease];
  }
}

- (jfloat)calcMemInMB {
  jlong bytes = 0;
  for (jint i = 0; i < [((id<JavaUtilList>) nil_chk(segments_)) size]; i++) {
    bytes += ((IOSByteArray *) nil_chk([segments_ getWithInt:i]))->size_;
  }
  return (jfloat) ([segments_ size] * 4 + bytes) / Helper_MB;
}

- (void)dealloc {
  RELEASE_(currentWriter_);
  RELEASE_(segments_);
  RELEASE_(algo_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(CompressedArray *)other {
  [super copyAllFieldsTo:other];
  other->compressionLevel_ = compressionLevel_;
  CompressedArray_set_currentWriter_(other, currentWriter_);
  other->currentEntry_ = currentEntry_;
  CompressedArray_set_segments_(other, segments_);
  other->entriesPerSegment_ = entriesPerSegment_;
  other->approxBytesPerEntry_ = approxBytesPerEntry_;
  CompressedArray_set_algo_(other, algo_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "CompressedArray", NULL, 0x1, NULL },
    { "initWithInt:withInt:withInt:", "CompressedArray", NULL, 0x1, NULL },
    { "compressWithByteArray:withInt:withInt:withInt:", "compress", "[B", 0x9, NULL },
    { "decompressWithByteArray:", "decompress", "[B", 0x9, "Ljava.util.zip.DataFormatException;" },
    { "setCompressionLevelWithInt:", "setCompressionLevel", "Lcom.graphhopper.coll.CompressedArray;", 0x1, NULL },
    { "writeWithDouble:withDouble:", "write", "V", 0x1, NULL },
    { "getWithLong:", "get", "Lcom.graphhopper.util.shapes.GHPoint;", 0x1, NULL },
    { "flush", NULL, "V", 0x1, NULL },
    { "calcMemInMB", NULL, "F", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "compressionLevel_", NULL, 0x2, "I", NULL,  },
    { "currentWriter_", NULL, 0x2, "Lcom.graphhopper.storage.VLongStorage;", NULL,  },
    { "currentEntry_", NULL, 0x2, "I", NULL,  },
    { "segments_", NULL, 0x2, "Ljava.util.List;", NULL,  },
    { "entriesPerSegment_", NULL, 0x2, "I", NULL,  },
    { "approxBytesPerEntry_", NULL, 0x2, "I", NULL,  },
    { "algo_", NULL, 0x2, "Lcom.graphhopper.geohash.SpatialKeyAlgo;", NULL,  },
  };
  static const J2ObjcClassInfo _CompressedArray = { 1, "CompressedArray", "com.graphhopper.coll", NULL, 0x1, 9, methods, 7, fields, 0, NULL};
  return &_CompressedArray;
}

@end

IOSByteArray *CompressedArray_compressWithByteArray_withInt_withInt_withInt_(IOSByteArray *value, jint offset, jint length, jint compressionLevel) {
  CompressedArray_init();
  JavaIoByteArrayOutputStream *bos = [[[JavaIoByteArrayOutputStream alloc] initWithInt:length] autorelease];
  JavaUtilZipDeflater *compressor = [[[JavaUtilZipDeflater alloc] init] autorelease];
  @try {
    [compressor setLevelWithInt:compressionLevel];
    [compressor setInputWithByteArray:value withInt:offset withInt:length];
    [compressor finish];
    IOSByteArray *buf = [IOSByteArray arrayWithLength:1024];
    while (![compressor finished]) {
      jint count = [compressor deflateWithByteArray:buf];
      [bos writeWithByteArray:buf withInt:0 withInt:count];
    }
  }
  @finally {
    [compressor end];
  }
  return [bos toByteArray];
}

IOSByteArray *CompressedArray_decompressWithByteArray_(IOSByteArray *value) {
  CompressedArray_init();
  JavaIoByteArrayOutputStream *bos = [[[JavaIoByteArrayOutputStream alloc] initWithInt:((IOSByteArray *) nil_chk(value))->size_] autorelease];
  JavaUtilZipInflater *decompressor = [[[JavaUtilZipInflater alloc] init] autorelease];
  @try {
    [decompressor setInputWithByteArray:value];
    IOSByteArray *buf = [IOSByteArray arrayWithLength:1024];
    while (![decompressor finished]) {
      jint count = [decompressor inflateWithByteArray:buf];
      [bos writeWithByteArray:buf withInt:0 withInt:count];
    }
  }
  @finally {
    [decompressor end];
  }
  return [bos toByteArray];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(CompressedArray)
