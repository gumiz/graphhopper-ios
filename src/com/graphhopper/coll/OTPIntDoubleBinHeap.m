//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/tools-lgpl/src/main/java/com/graphhopper/coll/OTPIntDoubleBinHeap.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/coll/OTPIntDoubleBinHeap.h"
#include "java/lang/Double.h"
#include "java/lang/Float.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/StringBuilder.h"
#include "java/util/Arrays.h"

@interface OTPIntDoubleBinHeap () {
 @public
  IOSFloatArray *keys_;
  IOSIntArray *elem_;
  jint size__;
  jint capacity_;
}
@end

J2OBJC_FIELD_SETTER(OTPIntDoubleBinHeap, keys_, IOSFloatArray *)
J2OBJC_FIELD_SETTER(OTPIntDoubleBinHeap, elem_, IOSIntArray *)

@implementation OTPIntDoubleBinHeap

- (instancetype)init {
  return [self initOTPIntDoubleBinHeapWithInt:1000];
}

- (instancetype)initOTPIntDoubleBinHeapWithInt:(jint)capacity {
  if (self = [super init]) {
    if (capacity < 10) {
      capacity = 10;
    }
    self->capacity_ = capacity;
    size__ = 0;
    OTPIntDoubleBinHeap_setAndConsume_elem_(self, [IOSIntArray newArrayWithLength:capacity + 1]);
    OTPIntDoubleBinHeap_setAndConsume_keys_(self, [IOSFloatArray newArrayWithLength:capacity + 1]);
    *IOSFloatArray_GetRef(keys_, 0) = JavaLangFloat_NEGATIVE_INFINITY;
  }
  return self;
}

- (instancetype)initWithInt:(jint)capacity {
  return [self initOTPIntDoubleBinHeapWithInt:capacity];
}

- (jint)getSize {
  return size__;
}

- (jint)size {
  return size__;
}

- (jboolean)isEmpty {
  return size__ == 0;
}

- (JavaLangDouble *)peekKey {
  return JavaLangDouble_valueOfWithDouble_([self peek_key]);
}

- (jdouble)peek_key {
  if (size__ > 0) {
    return IOSFloatArray_Get(nil_chk(keys_), 1);
  }
  else {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"An empty queue does not have a minimum key."] autorelease];
  }
}

- (JavaLangInteger *)peekElement {
  return JavaLangInteger_valueOfWithInt_([self peek_element]);
}

- (jint)peek_element {
  if (size__ > 0) {
    return IOSIntArray_Get(nil_chk(elem_), 1);
  }
  else {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"An empty queue does not have a minimum value."] autorelease];
  }
}

- (JavaLangInteger *)pollElement {
  return JavaLangInteger_valueOfWithInt_([self poll_element]);
}

- (jint)poll_element {
  jint i, child;
  jint minElem = IOSIntArray_Get(nil_chk(elem_), 1);
  jint lastElem = IOSIntArray_Get(elem_, size__);
  jdouble lastPrio = IOSFloatArray_Get(nil_chk(keys_), size__);
  if (size__ <= 0) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"An empty queue does not have a minimum value."] autorelease];
  }
  size__ -= 1;
  for (i = 1; i * 2 <= size__; i = child) {
    child = i * 2;
    if (child != size__ && IOSFloatArray_Get(keys_, child + 1) < IOSFloatArray_Get(keys_, child)) {
      child++;
    }
    if (lastPrio > IOSFloatArray_Get(keys_, child)) {
      *IOSIntArray_GetRef(elem_, i) = IOSIntArray_Get(elem_, child);
      *IOSFloatArray_GetRef(keys_, i) = IOSFloatArray_Get(keys_, child);
    }
    else {
      break;
    }
  }
  *IOSIntArray_GetRef(elem_, i) = lastElem;
  *IOSFloatArray_GetRef(keys_, i) = (jfloat) lastPrio;
  return minElem;
}

- (void)updateWithNSNumber:(NSNumber *)key
       withJavaLangInteger:(JavaLangInteger *)element {
  [self update_WithDouble:[((NSNumber *) nil_chk(key)) doubleValue] withInt:[((JavaLangInteger *) nil_chk(element)) intValue]];
}

- (jboolean)update_WithDouble:(jdouble)key
                      withInt:(jint)element {
  jint i;
  for (i = 1; i <= size__; i++) {
    if (IOSIntArray_Get(nil_chk(elem_), i) == element) {
      break;
    }
  }
  if (i > size__) {
    return NO;
  }
  if (key > IOSFloatArray_Get(nil_chk(keys_), i)) {
    while (i * 2 <= size__) {
      jint child = i * 2;
      if (child != size__ && IOSFloatArray_Get(keys_, child + 1) < IOSFloatArray_Get(keys_, child)) {
        child++;
      }
      if (key > IOSFloatArray_Get(keys_, child)) {
        *IOSIntArray_GetRef(nil_chk(elem_), i) = IOSIntArray_Get(elem_, child);
        *IOSFloatArray_GetRef(keys_, i) = IOSFloatArray_Get(keys_, child);
        i = child;
      }
      else {
        break;
      }
    }
    *IOSIntArray_GetRef(nil_chk(elem_), i) = element;
    *IOSFloatArray_GetRef(keys_, i) = (jfloat) key;
  }
  else {
    while (IOSFloatArray_Get(keys_, i / 2) > key) {
      *IOSIntArray_GetRef(nil_chk(elem_), i) = IOSIntArray_Get(elem_, i / 2);
      *IOSFloatArray_GetRef(keys_, i) = IOSFloatArray_Get(keys_, i / 2);
      i /= 2;
    }
    *IOSIntArray_GetRef(nil_chk(elem_), i) = element;
    *IOSFloatArray_GetRef(keys_, i) = (jfloat) key;
  }
  return YES;
}

- (void)insertWithNSNumber:(NSNumber *)key
       withJavaLangInteger:(JavaLangInteger *)element {
  [self insert_WithDouble:[((NSNumber *) nil_chk(key)) doubleValue] withInt:[((JavaLangInteger *) nil_chk(element)) intValue]];
}

- (void)insert_WithDouble:(jdouble)key
                  withInt:(jint)element {
  jint i;
  size__ += 1;
  if (size__ > capacity_) {
    [self ensureCapacityWithInt:J2ObjCFpToInt((capacity_ * OTPIntDoubleBinHeap_GROW_FACTOR))];
  }
  for (i = size__; IOSFloatArray_Get(nil_chk(keys_), i / 2) > key; i /= 2) {
    *IOSIntArray_GetRef(nil_chk(elem_), i) = IOSIntArray_Get(elem_, i / 2);
    *IOSFloatArray_GetRef(keys_, i) = IOSFloatArray_Get(keys_, i / 2);
  }
  *IOSIntArray_GetRef(nil_chk(elem_), i) = element;
  *IOSFloatArray_GetRef(keys_, i) = (jfloat) key;
}

- (void)ensureCapacityWithInt:(jint)capacity {
  if (capacity < size__) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"BinHeap contains too many elements to fit in new capacity."] autorelease];
  }
  self->capacity_ = capacity;
  OTPIntDoubleBinHeap_set_keys_(self, JavaUtilArrays_copyOfWithFloatArray_withInt_(keys_, capacity + 1));
  OTPIntDoubleBinHeap_set_elem_(self, JavaUtilArrays_copyOfWithIntArray_withInt_(elem_, capacity + 1));
}

- (jint)getCapacity {
  return capacity_;
}

- (jfloat)getKeyWithInt:(jint)index {
  return IOSFloatArray_Get(nil_chk(keys_), index);
}

- (jint)getElementWithInt:(jint)index {
  return IOSIntArray_Get(nil_chk(elem_), index);
}

- (void)setWithInt:(jint)index
         withFloat:(jfloat)key
           withInt:(jint)element {
  *IOSFloatArray_GetRef(nil_chk(keys_), index) = key;
  *IOSIntArray_GetRef(nil_chk(elem_), index) = element;
}

- (void)trimToWithInt:(jint)toSize {
  self->size__ = toSize;
  toSize++;
  JavaUtilArrays_fillWithFloatArray_withInt_withInt_withFloat_(keys_, toSize, size__ + 1, 0.0f);
  JavaUtilArrays_fillWithIntArray_withInt_withInt_withInt_(elem_, toSize, size__ + 1, 0);
}

- (void)clear {
  [self trimToWithInt:0];
}

- (NSString *)description {
  JavaLangStringBuilder *sb = [[[JavaLangStringBuilder alloc] init] autorelease];
  for (jint i = 1; i <= size__; i++) {
    if (i > 1) {
      [sb appendWithNSString:@", "];
    }
    [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([sb appendWithFloat:IOSFloatArray_Get(nil_chk(keys_), i)])) appendWithNSString:@":"])) appendWithInt:IOSIntArray_Get(nil_chk(elem_), i)];
  }
  return [sb description];
}

- (NSString *)toKeyString {
  JavaLangStringBuilder *sb = [[[JavaLangStringBuilder alloc] init] autorelease];
  for (jint i = 1; i <= size__; i++) {
    if (i > 1) {
      [sb appendWithNSString:@", "];
    }
    [sb appendWithFloat:IOSFloatArray_Get(nil_chk(keys_), i)];
  }
  return [sb description];
}

- (jint)indexOfValueWithInt:(jint)value {
  for (jint i = 0; i <= size__; i++) {
    if (IOSIntArray_Get(nil_chk(elem_), i) == value) {
      return i;
    }
  }
  return -1;
}

- (void)dealloc {
  RELEASE_(keys_);
  RELEASE_(elem_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(OTPIntDoubleBinHeap *)other {
  [super copyAllFieldsTo:other];
  OTPIntDoubleBinHeap_set_keys_(other, keys_);
  OTPIntDoubleBinHeap_set_elem_(other, elem_);
  other->size__ = size__;
  other->capacity_ = capacity_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "OTPIntDoubleBinHeap", NULL, 0x1, NULL },
    { "initWithInt:", "OTPIntDoubleBinHeap", NULL, 0x1, NULL },
    { "getSize", NULL, "I", 0x1, NULL },
    { "size", NULL, "I", 0x1, NULL },
    { "isEmpty", NULL, "Z", 0x1, NULL },
    { "peekKey", NULL, "Ljava.lang.Double;", 0x1, NULL },
    { "peek_key", NULL, "D", 0x1, NULL },
    { "peekElement", NULL, "Ljava.lang.Integer;", 0x1, NULL },
    { "peek_element", NULL, "I", 0x1, NULL },
    { "pollElement", NULL, "Ljava.lang.Integer;", 0x1, NULL },
    { "poll_element", NULL, "I", 0x1, NULL },
    { "updateWithNSNumber:withJavaLangInteger:", "update", "V", 0x1, NULL },
    { "update_WithDouble:withInt:", "update_", "Z", 0x1, NULL },
    { "insertWithNSNumber:withJavaLangInteger:", "insert", "V", 0x1, NULL },
    { "insert_WithDouble:withInt:", "insert_", "V", 0x1, NULL },
    { "ensureCapacityWithInt:", "ensureCapacity", "V", 0x1, NULL },
    { "getCapacity", NULL, "I", 0x1, NULL },
    { "getKeyWithInt:", "getKey", "F", 0x0, NULL },
    { "getElementWithInt:", "getElement", "I", 0x0, NULL },
    { "setWithInt:withFloat:withInt:", "set", "V", 0x0, NULL },
    { "trimToWithInt:", "trimTo", "V", 0x0, NULL },
    { "clear", NULL, "V", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "toKeyString", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "indexOfValueWithInt:", "indexOfValue", "I", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "GROW_FACTOR_", NULL, 0x1a, "D", NULL, .constantValue.asDouble = OTPIntDoubleBinHeap_GROW_FACTOR },
    { "keys_", NULL, 0x2, "[F", NULL,  },
    { "elem_", NULL, 0x2, "[I", NULL,  },
    { "size__", "size", 0x2, "I", NULL,  },
    { "capacity_", NULL, 0x2, "I", NULL,  },
  };
  static const J2ObjcClassInfo _OTPIntDoubleBinHeap = { 1, "OTPIntDoubleBinHeap", "com.graphhopper.coll", NULL, 0x1, 25, methods, 5, fields, 0, NULL};
  return &_OTPIntDoubleBinHeap;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OTPIntDoubleBinHeap)
