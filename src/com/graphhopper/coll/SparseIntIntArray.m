//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/coll/SparseIntIntArray.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/coll/SparseIntIntArray.h"
#include "com/graphhopper/util/Helper.h"
#include "java/io/PrintStream.h"
#include "java/lang/Integer.h"
#include "java/lang/OutOfMemoryError.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"

__attribute__((unused)) static jint SparseIntIntArray_getWithInt_withInt_(SparseIntIntArray *self, jint key, jint valueIfKeyNotFound);
__attribute__((unused)) static void SparseIntIntArray_gc(SparseIntIntArray *self);

@interface SparseIntIntArray () {
 @public
  jboolean mGarbage_;
  IOSIntArray *mKeys_;
  IOSIntArray *mValues_;
  jint mSize_;
}

/**
 @brief Gets the Object mapped from the specified key, or the specified Object if no such mapping has been made.
 */
- (jint)getWithInt:(jint)key
           withInt:(jint)valueIfKeyNotFound;

- (void)gc;
@end

J2OBJC_FIELD_SETTER(SparseIntIntArray, mKeys_, IOSIntArray *)
J2OBJC_FIELD_SETTER(SparseIntIntArray, mValues_, IOSIntArray *)

@implementation SparseIntIntArray

- (instancetype)init {
  return [self initSparseIntIntArrayWithInt:10];
}

- (instancetype)initSparseIntIntArrayWithInt:(jint)cap {
  if (self = [super init]) {
    mGarbage_ = NO;
    @try {
      cap = Helper_idealIntArraySizeWithInt_(cap);
      SparseIntIntArray_setAndConsume_mKeys_(self, [IOSIntArray newArrayWithLength:cap]);
      SparseIntIntArray_setAndConsume_mValues_(self, [IOSIntArray newArrayWithLength:cap]);
      mSize_ = 0;
    }
    @catch (JavaLangOutOfMemoryError *err) {
      [((JavaIoPrintStream *) nil_chk(JavaLangSystem_get_err_())) printlnWithNSString:JreStrcat("$I", @"requested capacity ", cap)];
      @throw err;
    }
  }
  return self;
}

- (instancetype)initWithInt:(jint)cap {
  return [self initSparseIntIntArrayWithInt:cap];
}

+ (jint)binarySearchWithIntArray:(IOSIntArray *)a
                         withInt:(jint)start
                         withInt:(jint)len
                         withInt:(jint)key {
  return SparseIntIntArray_binarySearchWithIntArray_withInt_withInt_withInt_(a, start, len, key);
}

- (jint)getWithInt:(jint)key {
  return SparseIntIntArray_getWithInt_withInt_(self, key, -1);
}

- (jint)getWithInt:(jint)key
           withInt:(jint)valueIfKeyNotFound {
  return SparseIntIntArray_getWithInt_withInt_(self, key, valueIfKeyNotFound);
}

- (void)removeWithInt:(jint)key {
  jint i = SparseIntIntArray_binarySearchWithIntArray_withInt_withInt_withInt_(mKeys_, 0, mSize_, key);
  if (i >= 0 && IOSIntArray_Get(nil_chk(mValues_), i) != SparseIntIntArray_DELETED) {
    *IOSIntArray_GetRef(mValues_, i) = SparseIntIntArray_DELETED;
    mGarbage_ = YES;
  }
}

- (void)gc {
  SparseIntIntArray_gc(self);
}

- (jint)putWithInt:(jint)key
           withInt:(jint)value {
  jint i = SparseIntIntArray_binarySearchWithIntArray_withInt_withInt_withInt_(mKeys_, 0, mSize_, key);
  if (i >= 0) {
    *IOSIntArray_GetRef(nil_chk(mValues_), i) = value;
  }
  else {
    i = ~i;
    if (i < mSize_ && IOSIntArray_Get(nil_chk(mValues_), i) == SparseIntIntArray_DELETED) {
      *IOSIntArray_GetRef(nil_chk(mKeys_), i) = key;
      *IOSIntArray_GetRef(mValues_, i) = value;
      return i;
    }
    if (mGarbage_ && mSize_ >= ((IOSIntArray *) nil_chk(mKeys_))->size_) {
      SparseIntIntArray_gc(self);
      i = ~SparseIntIntArray_binarySearchWithIntArray_withInt_withInt_withInt_(mKeys_, 0, mSize_, key);
    }
    if (mSize_ >= ((IOSIntArray *) nil_chk(mKeys_))->size_) {
      jint n = Helper_idealIntArraySizeWithInt_(mSize_ + 1);
      IOSIntArray *nkeys = [IOSIntArray arrayWithLength:n];
      IOSIntArray *nvalues = [IOSIntArray arrayWithLength:n];
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(mKeys_, 0, nkeys, 0, mKeys_->size_);
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(mValues_, 0, nvalues, 0, ((IOSIntArray *) nil_chk(mValues_))->size_);
      SparseIntIntArray_set_mKeys_(self, nkeys);
      SparseIntIntArray_set_mValues_(self, nvalues);
    }
    if (mSize_ - i != 0) {
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(mKeys_, i, mKeys_, i + 1, mSize_ - i);
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(mValues_, i, mValues_, i + 1, mSize_ - i);
    }
    *IOSIntArray_GetRef(mKeys_, i) = key;
    *IOSIntArray_GetRef(nil_chk(mValues_), i) = value;
    mSize_++;
  }
  return i;
}

- (jint)getSize {
  if (mGarbage_) {
    SparseIntIntArray_gc(self);
  }
  return mSize_;
}

- (jint)keyAtWithInt:(jint)index {
  if (mGarbage_) {
    SparseIntIntArray_gc(self);
  }
  return IOSIntArray_Get(nil_chk(mKeys_), index);
}

- (void)setKeyAtWithInt:(jint)index
                withInt:(jint)key {
  if (mGarbage_) {
    SparseIntIntArray_gc(self);
  }
  *IOSIntArray_GetRef(nil_chk(mKeys_), index) = key;
}

- (jint)valueAtWithInt:(jint)index {
  if (mGarbage_) {
    SparseIntIntArray_gc(self);
  }
  return IOSIntArray_Get(nil_chk(mValues_), index);
}

- (void)setValueAtWithInt:(jint)index
                  withInt:(jint)value {
  if (mGarbage_) {
    SparseIntIntArray_gc(self);
  }
  *IOSIntArray_GetRef(nil_chk(mValues_), index) = value;
}

- (void)clear {
  jint n = mSize_;
  IOSIntArray *values = mValues_;
  for (jint i = 0; i < n; i++) {
    *IOSIntArray_GetRef(nil_chk(values), i) = -1;
  }
  mSize_ = 0;
  mGarbage_ = NO;
}

- (jint)appendWithInt:(jint)key
              withInt:(jint)value {
  if (mSize_ != 0 && key <= IOSIntArray_Get(nil_chk(mKeys_), mSize_ - 1)) {
    return [self putWithInt:key withInt:value];
  }
  if (mGarbage_ && mSize_ >= ((IOSIntArray *) nil_chk(mKeys_))->size_) {
    SparseIntIntArray_gc(self);
  }
  jint pos = mSize_;
  if (pos >= ((IOSIntArray *) nil_chk(mKeys_))->size_) {
    jint n = Helper_idealIntArraySizeWithInt_(pos + 1);
    IOSIntArray *nkeys = [IOSIntArray arrayWithLength:n];
    IOSIntArray *nvalues = [IOSIntArray arrayWithLength:n];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(mKeys_, 0, nkeys, 0, mKeys_->size_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(mValues_, 0, nvalues, 0, ((IOSIntArray *) nil_chk(mValues_))->size_);
    SparseIntIntArray_set_mKeys_(self, nkeys);
    SparseIntIntArray_set_mValues_(self, nvalues);
  }
  *IOSIntArray_GetRef(mKeys_, pos) = key;
  *IOSIntArray_GetRef(nil_chk(mValues_), pos) = value;
  mSize_ = pos + 1;
  return pos;
}

- (NSString *)description {
  JavaLangStringBuilder *sb = [[[JavaLangStringBuilder alloc] init] autorelease];
  for (jint i = 0; i < [self getSize]; i++) {
    jint k = IOSIntArray_Get(nil_chk(mKeys_), i);
    jint v = IOSIntArray_Get(nil_chk(mValues_), i);
    if (i > 0) {
      [sb appendWithNSString:@","];
    }
    [sb appendWithInt:k];
    [sb appendWithNSString:@":"];
    [sb appendWithInt:v];
  }
  return [sb description];
}

- (jint)binarySearchWithInt:(jint)key {
  return SparseIntIntArray_binarySearchWithIntArray_withInt_withInt_withInt_(mKeys_, 0, mSize_, key);
}

- (void)dealloc {
  RELEASE_(mKeys_);
  RELEASE_(mValues_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(SparseIntIntArray *)other {
  [super copyAllFieldsTo:other];
  other->mGarbage_ = mGarbage_;
  SparseIntIntArray_set_mKeys_(other, mKeys_);
  SparseIntIntArray_set_mValues_(other, mValues_);
  other->mSize_ = mSize_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "SparseIntIntArray", NULL, 0x1, NULL },
    { "initWithInt:", "SparseIntIntArray", NULL, 0x1, NULL },
    { "binarySearchWithIntArray:withInt:withInt:withInt:", "binarySearch", "I", 0x8, NULL },
    { "getWithInt:", "get", "I", 0x1, NULL },
    { "getWithInt:withInt:", "get", "I", 0x2, NULL },
    { "removeWithInt:", "remove", "V", 0x1, NULL },
    { "gc", NULL, "V", 0x2, NULL },
    { "putWithInt:withInt:", "put", "I", 0x1, NULL },
    { "getSize", NULL, "I", 0x1, NULL },
    { "keyAtWithInt:", "keyAt", "I", 0x1, NULL },
    { "setKeyAtWithInt:withInt:", "setKeyAt", "V", 0x1, NULL },
    { "valueAtWithInt:", "valueAt", "I", 0x1, NULL },
    { "setValueAtWithInt:withInt:", "setValueAt", "V", 0x1, NULL },
    { "clear", NULL, "V", 0x1, NULL },
    { "appendWithInt:withInt:", "append", "I", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "binarySearchWithInt:", "binarySearch", "I", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "DELETED_", NULL, 0x1a, "I", NULL, .constantValue.asInt = SparseIntIntArray_DELETED },
    { "mGarbage_", NULL, 0x2, "Z", NULL,  },
    { "mKeys_", NULL, 0x2, "[I", NULL,  },
    { "mValues_", NULL, 0x2, "[I", NULL,  },
    { "mSize_", NULL, 0x2, "I", NULL,  },
  };
  static const J2ObjcClassInfo _SparseIntIntArray = { 1, "SparseIntIntArray", "com.graphhopper.coll", NULL, 0x1, 17, methods, 5, fields, 0, NULL};
  return &_SparseIntIntArray;
}

@end

jint SparseIntIntArray_binarySearchWithIntArray_withInt_withInt_withInt_(IOSIntArray *a, jint start, jint len, jint key) {
  SparseIntIntArray_init();
  jint high = start + len, low = start - 1, guess;
  while (high - low > 1) {
    guess = URShift32((high + low), 1);
    if (IOSIntArray_Get(nil_chk(a), guess) < key) {
      low = guess;
    }
    else {
      high = guess;
    }
  }
  if (high == start + len) {
    return ~(start + len);
  }
  else if (IOSIntArray_Get(nil_chk(a), high) == key) {
    return high;
  }
  else {
    return ~high;
  }
}

jint SparseIntIntArray_getWithInt_withInt_(SparseIntIntArray *self, jint key, jint valueIfKeyNotFound) {
  jint i = SparseIntIntArray_binarySearchWithIntArray_withInt_withInt_withInt_(self->mKeys_, 0, self->mSize_, key);
  if (i < 0 || IOSIntArray_Get(nil_chk(self->mValues_), i) == SparseIntIntArray_DELETED) {
    return valueIfKeyNotFound;
  }
  else {
    return IOSIntArray_Get(self->mValues_, i);
  }
}

void SparseIntIntArray_gc(SparseIntIntArray *self) {
  jint n = self->mSize_;
  jint o = 0;
  IOSIntArray *keys = self->mKeys_;
  IOSIntArray *values = self->mValues_;
  for (jint i = 0; i < n; i++) {
    jint val = IOSIntArray_Get(nil_chk(values), i);
    if (val != SparseIntIntArray_DELETED) {
      if (i != o) {
        *IOSIntArray_GetRef(nil_chk(keys), o) = IOSIntArray_Get(keys, i);
        *IOSIntArray_GetRef(values, o) = val;
      }
      o++;
    }
  }
  self->mGarbage_ = NO;
  self->mSize_ = o;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(SparseIntIntArray)
