//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/util/GHUtility.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/coll/GHBitSet.h"
#include "com/graphhopper/coll/GHBitSetImpl.h"
#include "com/graphhopper/routing/util/AllCHEdgesIterator.h"
#include "com/graphhopper/routing/util/AllEdgesIterator.h"
#include "com/graphhopper/routing/util/EdgeFilter.h"
#include "com/graphhopper/routing/util/EncodingManager.h"
#include "com/graphhopper/routing/util/FlagEncoder.h"
#include "com/graphhopper/storage/CHGraph.h"
#include "com/graphhopper/storage/Directory.h"
#include "com/graphhopper/storage/GHDirectory.h"
#include "com/graphhopper/storage/Graph.h"
#include "com/graphhopper/storage/GraphExtension.h"
#include "com/graphhopper/storage/GraphHopperStorage.h"
#include "com/graphhopper/storage/GraphStorage.h"
#include "com/graphhopper/storage/MMapDirectory.h"
#include "com/graphhopper/storage/NodeAccess.h"
#include "com/graphhopper/storage/RAMDirectory.h"
#include "com/graphhopper/util/BitUtil.h"
#include "com/graphhopper/util/CHEdgeExplorer.h"
#include "com/graphhopper/util/CHEdgeIterator.h"
#include "com/graphhopper/util/CHEdgeIteratorState.h"
#include "com/graphhopper/util/EdgeExplorer.h"
#include "com/graphhopper/util/EdgeIterator.h"
#include "com/graphhopper/util/EdgeIteratorState.h"
#include "com/graphhopper/util/GHUtility.h"
#include "com/graphhopper/util/PointList.h"
#include "gnu/trove/list/TIntList.h"
#include "gnu/trove/list/array/TIntArrayList.h"
#include "java/io/PrintStream.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/System.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/util/ArrayList.h"
#include "java/util/HashSet.h"
#include "java/util/LinkedHashSet.h"
#include "java/util/List.h"
#include "java/util/Random.h"
#include "java/util/Set.h"
#include "java/util/concurrent/atomic/AtomicInteger.h"

@interface GHUtility_$1 () {
 @public
  id<Graph> val$g_;
  id<EdgeFilter> val$filter_;
  jint val$counts_;
}
@end

J2OBJC_FIELD_SETTER(GHUtility_$1, val$g_, id<Graph>)
J2OBJC_FIELD_SETTER(GHUtility_$1, val$filter_, id<EdgeFilter>)

@interface GHUtility_$2 () {
 @public
  GHBitSetImpl *val$bitset_;
  id<GnuTroveListTIntList> val$list_;
  JavaUtilConcurrentAtomicAtomicInteger *val$ref_;
}
@end

J2OBJC_FIELD_SETTER(GHUtility_$2, val$bitset_, GHBitSetImpl *)
J2OBJC_FIELD_SETTER(GHUtility_$2, val$list_, id<GnuTroveListTIntList>)
J2OBJC_FIELD_SETTER(GHUtility_$2, val$ref_, JavaUtilConcurrentAtomicAtomicInteger *)

@interface GHUtility_$3 () {
 @public
  jdouble val$distance_;
  jlong val$flags_;
}
@end

@implementation GHUtility

+ (id<JavaUtilList>)getProblemsWithGraph:(id<Graph>)g {
  return GHUtility_getProblemsWithGraph_(g);
}

+ (jint)countWithEdgeIterator:(id<EdgeIterator>)iter {
  return GHUtility_countWithEdgeIterator_(iter);
}

+ (id<JavaUtilSet>)asSetWithIntArray:(IOSIntArray *)values {
  return GHUtility_asSetWithIntArray_(values);
}

+ (id<JavaUtilSet>)getNeighborsWithEdgeIterator:(id<EdgeIterator>)iter {
  return GHUtility_getNeighborsWithEdgeIterator_(iter);
}

+ (id<JavaUtilList>)getEdgeIdsWithEdgeIterator:(id<EdgeIterator>)iter {
  return GHUtility_getEdgeIdsWithEdgeIterator_(iter);
}

+ (void)printEdgeInfoWithGraph:(id<Graph>)g
               withFlagEncoder:(id<FlagEncoder>)encoder {
  GHUtility_printEdgeInfoWithGraph_withFlagEncoder_(g, encoder);
}

+ (void)printInfoWithGraph:(id<Graph>)g
                   withInt:(jint)startNode
                   withInt:(jint)counts
            withEdgeFilter:(id<EdgeFilter>)filter {
  GHUtility_printInfoWithGraph_withInt_withInt_withEdgeFilter_(g, startNode, counts, filter);
}

+ (NSString *)getNodeInfoWithCHGraph:(id<CHGraph>)g
                             withInt:(jint)nodeId
                      withEdgeFilter:(id<EdgeFilter>)filter {
  return GHUtility_getNodeInfoWithCHGraph_withInt_withEdgeFilter_(g, nodeId, filter);
}

+ (NSString *)getNodeInfoWithGraph:(id<Graph>)g
                           withInt:(jint)nodeId
                    withEdgeFilter:(id<EdgeFilter>)filter {
  return GHUtility_getNodeInfoWithGraph_withInt_withEdgeFilter_(g, nodeId, filter);
}

+ (id<Graph>)shuffleWithGraph:(id<Graph>)g
                    withGraph:(id<Graph>)sortedGraph {
  return GHUtility_shuffleWithGraph_withGraph_(g, sortedGraph);
}

+ (id<Graph>)sortDFSWithGraph:(id<Graph>)g
                    withGraph:(id<Graph>)sortedGraph {
  return GHUtility_sortDFSWithGraph_withGraph_(g, sortedGraph);
}

+ (id<Graph>)createSortedGraphWithGraph:(id<Graph>)fromGraph
                              withGraph:(id<Graph>)toSortedGraph
               withGnuTroveListTIntList:(id<GnuTroveListTIntList>)oldToNewNodeList {
  return GHUtility_createSortedGraphWithGraph_withGraph_withGnuTroveListTIntList_(fromGraph, toSortedGraph, oldToNewNodeList);
}

+ (id<Graph>)copyToWithGraph:(id<Graph>)fromGraph
                   withGraph:(id<Graph>)toGraph {
  return GHUtility_copyToWithGraph_withGraph_(fromGraph, toGraph);
}

+ (id<Directory>)guessDirectoryWithGraphStorage:(id<GraphStorage>)store {
  return GHUtility_guessDirectoryWithGraphStorage_(store);
}

+ (GraphHopperStorage *)newStorageWithGraphHopperStorage:(GraphHopperStorage *)store {
  return GHUtility_newStorageWithGraphHopperStorage_(store);
}

+ (jint)getAdjNodeWithGraph:(id<Graph>)g
                    withInt:(jint)edge
                    withInt:(jint)adjNode {
  return GHUtility_getAdjNodeWithGraph_withInt_withInt_(g, edge, adjNode);
}

+ (id<EdgeIteratorState>)createMockedEdgeIteratorStateWithDouble:(jdouble)distance
                                                        withLong:(jlong)flags {
  return GHUtility_createMockedEdgeIteratorStateWithDouble_withLong_(distance, flags);
}

+ (id<EdgeIteratorState>)getEdgeWithGraph:(id<Graph>)graph
                                  withInt:(jint)base
                                  withInt:(jint)adj {
  return GHUtility_getEdgeWithGraph_withInt_withInt_(graph, base, adj);
}

+ (jint)createEdgeKeyWithInt:(jint)nodeA
                     withInt:(jint)nodeB
                     withInt:(jint)edgeId
                 withBoolean:(jboolean)reverse {
  return GHUtility_createEdgeKeyWithInt_withInt_withInt_withBoolean_(nodeA, nodeB, edgeId, reverse);
}

+ (jboolean)isSameEdgeKeysWithInt:(jint)edgeKey1
                          withInt:(jint)edgeKey2 {
  return GHUtility_isSameEdgeKeysWithInt_withInt_(edgeKey1, edgeKey2);
}

+ (jint)reverseEdgeKeyWithInt:(jint)edgeKey {
  return GHUtility_reverseEdgeKeyWithInt_(edgeKey);
}

+ (jint)getEdgeFromEdgeKeyWithInt:(jint)edgeKey {
  return GHUtility_getEdgeFromEdgeKeyWithInt_(edgeKey);
}

- (instancetype)init {
  return [super init];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "getProblemsWithGraph:", "getProblems", "Ljava.util.List;", 0x9, NULL },
    { "countWithEdgeIterator:", "count", "I", 0x9, NULL },
    { "asSetWithIntArray:", "asSet", "Ljava.util.Set;", 0x89, NULL },
    { "getNeighborsWithEdgeIterator:", "getNeighbors", "Ljava.util.Set;", 0x9, NULL },
    { "getEdgeIdsWithEdgeIterator:", "getEdgeIds", "Ljava.util.List;", 0x9, NULL },
    { "printEdgeInfoWithGraph:withFlagEncoder:", "printEdgeInfo", "V", 0x9, NULL },
    { "printInfoWithGraph:withInt:withInt:withEdgeFilter:", "printInfo", "V", 0x9, NULL },
    { "getNodeInfoWithCHGraph:withInt:withEdgeFilter:", "getNodeInfo", "Ljava.lang.String;", 0x9, NULL },
    { "getNodeInfoWithGraph:withInt:withEdgeFilter:", "getNodeInfo", "Ljava.lang.String;", 0x9, NULL },
    { "shuffleWithGraph:withGraph:", "shuffle", "Lcom.graphhopper.storage.Graph;", 0x9, NULL },
    { "sortDFSWithGraph:withGraph:", "sortDFS", "Lcom.graphhopper.storage.Graph;", 0x9, NULL },
    { "createSortedGraphWithGraph:withGraph:withGnuTroveListTIntList:", "createSortedGraph", "Lcom.graphhopper.storage.Graph;", 0x8, NULL },
    { "copyToWithGraph:withGraph:", "copyTo", "Lcom.graphhopper.storage.Graph;", 0x9, NULL },
    { "guessDirectoryWithGraphStorage:", "guessDirectory", "Lcom.graphhopper.storage.Directory;", 0x8, NULL },
    { "newStorageWithGraphHopperStorage:", "newStorage", "Lcom.graphhopper.storage.GraphHopperStorage;", 0x9, NULL },
    { "getAdjNodeWithGraph:withInt:withInt:", "getAdjNode", "I", 0x9, NULL },
    { "createMockedEdgeIteratorStateWithDouble:withLong:", "createMockedEdgeIteratorState", "Lcom.graphhopper.util.EdgeIteratorState;", 0x9, NULL },
    { "getEdgeWithGraph:withInt:withInt:", "getEdge", "Lcom.graphhopper.util.EdgeIteratorState;", 0x9, NULL },
    { "createEdgeKeyWithInt:withInt:withInt:withBoolean:", "createEdgeKey", "I", 0x9, NULL },
    { "isSameEdgeKeysWithInt:withInt:", "isSameEdgeKeys", "Z", 0x9, NULL },
    { "reverseEdgeKeyWithInt:", "reverseEdgeKey", "I", 0x9, NULL },
    { "getEdgeFromEdgeKeyWithInt:", "getEdgeFromEdgeKey", "I", 0x9, NULL },
    { "init", NULL, NULL, 0x1, NULL },
  };
  static const J2ObjcClassInfo _GHUtility = { 1, "GHUtility", "com.graphhopper.util", NULL, 0x1, 23, methods, 0, NULL, 0, NULL};
  return &_GHUtility;
}

@end

id<JavaUtilList> GHUtility_getProblemsWithGraph_(id<Graph> g) {
  GHUtility_init();
  id<JavaUtilList> problems = [[[JavaUtilArrayList alloc] init] autorelease];
  jint nodes = [((id<Graph>) nil_chk(g)) getNodes];
  jint nodeIndex = 0;
  id<NodeAccess> na = [g getNodeAccess];
  @try {
    id<EdgeExplorer> explorer = [g createEdgeExplorer];
    for (; nodeIndex < nodes; nodeIndex++) {
      jdouble lat = [((id<NodeAccess>) nil_chk(na)) getLatitudeWithInt:nodeIndex];
      if (lat > 90 || lat < -90) [problems addWithId:JreStrcat("$D", @"latitude is not within its bounds ", lat)];
      jdouble lon = [na getLongitudeWithInt:nodeIndex];
      if (lon > 180 || lon < -180) [problems addWithId:JreStrcat("$D", @"longitude is not within its bounds ", lon)];
      id<EdgeIterator> iter = [((id<EdgeExplorer>) nil_chk(explorer)) setBaseNodeWithInt:nodeIndex];
      while ([((id<EdgeIterator>) nil_chk(iter)) next]) {
        if ([iter getAdjNode] >= nodes) {
          [problems addWithId:JreStrcat("$I$I$", @"edge of ", nodeIndex, @" has a node ", [iter getAdjNode], @" greater or equal to getNodes")];
        }
        if ([iter getAdjNode] < 0) {
          [problems addWithId:JreStrcat("$I$I", @"edge of ", nodeIndex, @" has a negative node ", [iter getAdjNode])];
        }
      }
    }
  }
  @catch (JavaLangException *ex) {
    @throw [[[JavaLangRuntimeException alloc] initWithNSString:JreStrcat("$I", @"problem with node ", nodeIndex) withJavaLangThrowable:ex] autorelease];
  }
  return problems;
}

jint GHUtility_countWithEdgeIterator_(id<EdgeIterator> iter) {
  GHUtility_init();
  jint counter = 0;
  while ([((id<EdgeIterator>) nil_chk(iter)) next]) {
    counter++;
  }
  return counter;
}

id<JavaUtilSet> GHUtility_asSetWithIntArray_(IOSIntArray *values) {
  GHUtility_init();
  id<JavaUtilSet> s = [[[JavaUtilHashSet alloc] init] autorelease];
  {
    IOSIntArray *a__ = values;
    jint const *b__ = ((IOSIntArray *) nil_chk(a__))->buffer_;
    jint const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      jint v = *b__++;
      [s addWithId:JavaLangInteger_valueOfWithInt_(v)];
    }
  }
  return s;
}

id<JavaUtilSet> GHUtility_getNeighborsWithEdgeIterator_(id<EdgeIterator> iter) {
  GHUtility_init();
  id<JavaUtilSet> list = [[[JavaUtilLinkedHashSet alloc] init] autorelease];
  while ([((id<EdgeIterator>) nil_chk(iter)) next]) {
    [list addWithId:JavaLangInteger_valueOfWithInt_([iter getAdjNode])];
  }
  return list;
}

id<JavaUtilList> GHUtility_getEdgeIdsWithEdgeIterator_(id<EdgeIterator> iter) {
  GHUtility_init();
  id<JavaUtilList> list = [[[JavaUtilArrayList alloc] init] autorelease];
  while ([((id<EdgeIterator>) nil_chk(iter)) next]) {
    [list addWithId:JavaLangInteger_valueOfWithInt_([iter getEdge])];
  }
  return list;
}

void GHUtility_printEdgeInfoWithGraph_withFlagEncoder_(id<Graph> g, id<FlagEncoder> encoder) {
  GHUtility_init();
  [((JavaIoPrintStream *) nil_chk(JavaLangSystem_get_out_())) printlnWithNSString:JreStrcat("$I$I$", @"-- Graph n:", [((id<Graph>) nil_chk(g)) getNodes], @" e:", [((id<AllEdgesIterator>) nil_chk([g getAllEdges])) getMaxId], @" ---")];
  id<AllEdgesIterator> iter = [g getAllEdges];
  while ([((id<AllEdgesIterator>) nil_chk(iter)) next]) {
    NSString *sc = @"";
    if ([AllCHEdgesIterator_class_() isInstance:iter]) {
      id<AllCHEdgesIterator> aeSkip = (id<AllCHEdgesIterator>) check_protocol_cast(iter, @protocol(AllCHEdgesIterator));
      sc = [aeSkip isShortcut] ? @"sc" : @"  ";
    }
    NSString *fwdStr = [iter isForwardWithFlagEncoder:encoder] ? @"fwd" : @"   ";
    NSString *bckStr = [iter isBackwardWithFlagEncoder:encoder] ? @"bckwd" : @"";
    [JavaLangSystem_get_out_() printlnWithNSString:JreStrcat("$C@C$C$", sc, ' ', iter, ' ', fwdStr, ' ', bckStr)];
  }
}

void GHUtility_printInfoWithGraph_withInt_withInt_withEdgeFilter_(id<Graph> g, jint startNode, jint counts, id<EdgeFilter> filter) {
  GHUtility_init();
  [((GHUtility_$1 *) [[[GHUtility_$1 alloc] initWithGraph:g withEdgeFilter:filter withInt:counts] autorelease]) startWithEdgeExplorer:[((id<Graph>) nil_chk(g)) createEdgeExplorer] withInt:startNode];
}

NSString *GHUtility_getNodeInfoWithCHGraph_withInt_withEdgeFilter_(id<CHGraph> g, jint nodeId, id<EdgeFilter> filter) {
  GHUtility_init();
  id<CHEdgeExplorer> ex = [((id<CHGraph>) nil_chk(g)) createEdgeExplorerWithEdgeFilter:filter];
  id<CHEdgeIterator> iter = [((id<CHEdgeExplorer>) nil_chk(ex)) setBaseNodeWithInt:nodeId];
  id<NodeAccess> na = [g getNodeAccess];
  NSString *str = JreStrcat("ICDCDC", nodeId, ':', [((id<NodeAccess>) nil_chk(na)) getLatitudeWithInt:nodeId], ',', [na getLongitudeWithInt:nodeId], 0x000a);
  while ([((id<CHEdgeIterator>) nil_chk(iter)) next]) {
    str = JreStrcat("$$", str, JreStrcat("$ICICI$I$$C", @"  ->", [iter getAdjNode], '(', [iter getSkippedEdge1], ',', [iter getSkippedEdge2], @") ", [iter getEdge], @" \t", [((BitUtil *) nil_chk(BitUtil_get_BIG_())) toBitStringWithLong:[iter getFlags] withInt:8], 0x000a));
  }
  return str;
}

NSString *GHUtility_getNodeInfoWithGraph_withInt_withEdgeFilter_(id<Graph> g, jint nodeId, id<EdgeFilter> filter) {
  GHUtility_init();
  id<EdgeIterator> iter = [((id<EdgeExplorer>) nil_chk([((id<Graph>) nil_chk(g)) createEdgeExplorerWithEdgeFilter:filter])) setBaseNodeWithInt:nodeId];
  id<NodeAccess> na = [g getNodeAccess];
  NSString *str = JreStrcat("ICDCDC", nodeId, ':', [((id<NodeAccess>) nil_chk(na)) getLatitudeWithInt:nodeId], ',', [na getLongitudeWithInt:nodeId], 0x000a);
  while ([((id<EdgeIterator>) nil_chk(iter)) next]) {
    str = JreStrcat("$$", str, JreStrcat("$I$D$I$IC$C", @"  ->", [iter getAdjNode], @" (", [iter getDistance], @") pillars:", [((PointList *) nil_chk([iter fetchWayGeometryWithInt:0])) getSize], @", edgeId:", [iter getEdge], 0x0009, [((BitUtil *) nil_chk(BitUtil_get_BIG_())) toBitStringWithLong:[iter getFlags] withInt:8], 0x000a));
  }
  return str;
}

id<Graph> GHUtility_shuffleWithGraph_withGraph_(id<Graph> g, id<Graph> sortedGraph) {
  GHUtility_init();
  jint len = [((id<Graph>) nil_chk(g)) getNodes];
  id<GnuTroveListTIntList> list = [[[GnuTroveListArrayTIntArrayList alloc] initWithInt:len withInt:-1] autorelease];
  [list fillWithInt:0 withInt:len withInt:-1];
  for (jint i = 0; i < len; i++) {
    [list setWithInt:i withInt:i];
  }
  [list shuffleWithJavaUtilRandom:[[[JavaUtilRandom alloc] init] autorelease]];
  return GHUtility_createSortedGraphWithGraph_withGraph_withGnuTroveListTIntList_(g, sortedGraph, list);
}

id<Graph> GHUtility_sortDFSWithGraph_withGraph_(id<Graph> g, id<Graph> sortedGraph) {
  GHUtility_init();
  id<GnuTroveListTIntList> list = [[[GnuTroveListArrayTIntArrayList alloc] initWithInt:[((id<Graph>) nil_chk(g)) getNodes] withInt:-1] autorelease];
  jint nodes = [g getNodes];
  [list fillWithInt:0 withInt:nodes withInt:-1];
  GHBitSetImpl *bitset = [[[GHBitSetImpl alloc] initWithInt:nodes] autorelease];
  JavaUtilConcurrentAtomicAtomicInteger *ref = [[[JavaUtilConcurrentAtomicAtomicInteger alloc] initWithInt:-1] autorelease];
  id<EdgeExplorer> explorer = [g createEdgeExplorer];
  for (jint startNode = 0; startNode >= 0 && startNode < nodes; startNode = [bitset nextClearWithInt:startNode + 1]) {
    [((GHUtility_$2 *) [[[GHUtility_$2 alloc] initWithGHBitSetImpl:bitset withGnuTroveListTIntList:list withJavaUtilConcurrentAtomicAtomicInteger:ref] autorelease]) startWithEdgeExplorer:explorer withInt:startNode];
  }
  return GHUtility_createSortedGraphWithGraph_withGraph_withGnuTroveListTIntList_(g, sortedGraph, list);
}

id<Graph> GHUtility_createSortedGraphWithGraph_withGraph_withGnuTroveListTIntList_(id<Graph> fromGraph, id<Graph> toSortedGraph, id<GnuTroveListTIntList> oldToNewNodeList) {
  GHUtility_init();
  id<AllEdgesIterator> eIter = [((id<Graph>) nil_chk(fromGraph)) getAllEdges];
  while ([((id<AllEdgesIterator>) nil_chk(eIter)) next]) {
    jint base = [eIter getBaseNode];
    jint newBaseIndex = [((id<GnuTroveListTIntList>) nil_chk(oldToNewNodeList)) getWithInt:base];
    jint adj = [eIter getAdjNode];
    jint newAdjIndex = [oldToNewNodeList getWithInt:adj];
    if (newBaseIndex < 0 || newAdjIndex < 0) continue;
    [eIter copyPropertiesToWithEdgeIteratorState:[((id<Graph>) nil_chk(toSortedGraph)) edgeWithInt:newBaseIndex withInt:newAdjIndex]];
  }
  jint nodes = [fromGraph getNodes];
  id<NodeAccess> na = [fromGraph getNodeAccess];
  id<NodeAccess> sna = [((id<Graph>) nil_chk(toSortedGraph)) getNodeAccess];
  for (jint old = 0; old < nodes; old++) {
    jint newIndex = [((id<GnuTroveListTIntList>) nil_chk(oldToNewNodeList)) getWithInt:old];
    if ([((id<NodeAccess>) nil_chk(sna)) is3D]) [sna setNodeWithInt:newIndex withDouble:[((id<NodeAccess>) nil_chk(na)) getLatitudeWithInt:old] withDouble:[na getLongitudeWithInt:old] withDouble:[na getElevationWithInt:old]];
    else [sna setNodeWithInt:newIndex withDouble:[((id<NodeAccess>) nil_chk(na)) getLatitudeWithInt:old] withDouble:[na getLongitudeWithInt:old]];
  }
  return toSortedGraph;
}

id<Graph> GHUtility_copyToWithGraph_withGraph_(id<Graph> fromGraph, id<Graph> toGraph) {
  GHUtility_init();
  id<AllEdgesIterator> eIter = [((id<Graph>) nil_chk(fromGraph)) getAllEdges];
  while ([((id<AllEdgesIterator>) nil_chk(eIter)) next]) {
    jint base = [eIter getBaseNode];
    jint adj = [eIter getAdjNode];
    [eIter copyPropertiesToWithEdgeIteratorState:[((id<Graph>) nil_chk(toGraph)) edgeWithInt:base withInt:adj]];
  }
  id<NodeAccess> fna = [fromGraph getNodeAccess];
  id<NodeAccess> tna = [((id<Graph>) nil_chk(toGraph)) getNodeAccess];
  jint nodes = [fromGraph getNodes];
  for (jint node = 0; node < nodes; node++) {
    if ([((id<NodeAccess>) nil_chk(tna)) is3D]) [tna setNodeWithInt:node withDouble:[((id<NodeAccess>) nil_chk(fna)) getLatitudeWithInt:node] withDouble:[fna getLongitudeWithInt:node] withDouble:[fna getElevationWithInt:node]];
    else [tna setNodeWithInt:node withDouble:[((id<NodeAccess>) nil_chk(fna)) getLatitudeWithInt:node] withDouble:[fna getLongitudeWithInt:node]];
  }
  return toGraph;
}

id<Directory> GHUtility_guessDirectoryWithGraphStorage_(id<GraphStorage> store) {
  GHUtility_init();
  NSString *location = [((id<Directory>) nil_chk([((id<GraphStorage>) nil_chk(store)) getDirectory])) getLocation];
  id<Directory> outdir;
  if ([[store getDirectory] isKindOfClass:[MMapDirectory class]]) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"not supported yet: mmap will overwrite existing storage at the same location"] autorelease];
  }
  else {
    jboolean isStoring = [((GHDirectory *) nil_chk(((GHDirectory *) check_class_cast([store getDirectory], [GHDirectory class])))) isStoring];
    outdir = [[[RAMDirectory alloc] initWithNSString:location withBoolean:isStoring] autorelease];
  }
  return outdir;
}

GraphHopperStorage *GHUtility_newStorageWithGraphHopperStorage_(GraphHopperStorage *store) {
  GHUtility_init();
  id<Directory> outdir = GHUtility_guessDirectoryWithGraphStorage_(store);
  jboolean is3D = [((id<NodeAccess>) nil_chk([((GraphHopperStorage *) nil_chk(store)) getNodeAccess])) is3D];
  return [((GraphHopperStorage *) [[[GraphHopperStorage alloc] initWithJavaUtilList:[store getCHWeightings] withDirectory:outdir withEncodingManager:[store getEncodingManager] withBoolean:is3D withGraphExtension:[store getExtension]] autorelease]) createWithLong:[store getNodes]];
}

jint GHUtility_getAdjNodeWithGraph_withInt_withInt_(id<Graph> g, jint edge, jint adjNode) {
  GHUtility_init();
  if (EdgeIterator_Edge_isValidWithInt_(edge)) {
    id<EdgeIteratorState> iterTo = [((id<Graph>) nil_chk(g)) getEdgeIteratorStateWithInt:edge withInt:adjNode];
    return [((id<EdgeIteratorState>) nil_chk(iterTo)) getAdjNode];
  }
  return adjNode;
}

id<EdgeIteratorState> GHUtility_createMockedEdgeIteratorStateWithDouble_withLong_(jdouble distance, jlong flags) {
  GHUtility_init();
  return [[[GHUtility_$3 alloc] initWithDouble:distance withLong:flags] autorelease];
}

id<EdgeIteratorState> GHUtility_getEdgeWithGraph_withInt_withInt_(id<Graph> graph, jint base, jint adj) {
  GHUtility_init();
  id<EdgeIterator> iter = [((id<EdgeExplorer>) nil_chk([((id<Graph>) nil_chk(graph)) createEdgeExplorer])) setBaseNodeWithInt:base];
  while ([((id<EdgeIterator>) nil_chk(iter)) next]) {
    if ([iter getAdjNode] == adj) return iter;
  }
  return nil;
}

jint GHUtility_createEdgeKeyWithInt_withInt_withInt_withBoolean_(jint nodeA, jint nodeB, jint edgeId, jboolean reverse) {
  GHUtility_init();
  edgeId = LShift32(edgeId, 1);
  if (reverse) return (nodeA > nodeB) ? edgeId : edgeId + 1;
  return (nodeA > nodeB) ? edgeId + 1 : edgeId;
}

jboolean GHUtility_isSameEdgeKeysWithInt_withInt_(jint edgeKey1, jint edgeKey2) {
  GHUtility_init();
  return edgeKey1 / 2 == edgeKey2 / 2;
}

jint GHUtility_reverseEdgeKeyWithInt_(jint edgeKey) {
  GHUtility_init();
  return edgeKey % 2 == 0 ? edgeKey + 1 : edgeKey - 1;
}

jint GHUtility_getEdgeFromEdgeKeyWithInt_(jint edgeKey) {
  GHUtility_init();
  return edgeKey / 2;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GHUtility)

@implementation GHUtility_$1

- (jboolean)goFurtherWithInt:(jint)nodeId {
  [((JavaIoPrintStream *) nil_chk(JavaLangSystem_get_out_())) printlnWithNSString:GHUtility_getNodeInfoWithGraph_withInt_withEdgeFilter_(val$g_, nodeId, val$filter_)];
  if (counter_++ > val$counts_) {
    return NO;
  }
  return YES;
}

- (instancetype)initWithGraph:(id<Graph>)capture$0
               withEdgeFilter:(id<EdgeFilter>)capture$1
                      withInt:(jint)capture$2 {
  GHUtility_$1_set_val$g_(self, capture$0);
  GHUtility_$1_set_val$filter_(self, capture$1);
  val$counts_ = capture$2;
  if (self = [super init]) {
    counter_ = 0;
  }
  return self;
}

- (void)dealloc {
  RELEASE_(val$g_);
  RELEASE_(val$filter_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(GHUtility_$1 *)other {
  [super copyAllFieldsTo:other];
  other->counter_ = counter_;
  GHUtility_$1_set_val$g_(other, val$g_);
  GHUtility_$1_set_val$filter_(other, val$filter_);
  other->val$counts_ = val$counts_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "goFurtherWithInt:", "goFurther", "Z", 0x4, NULL },
    { "initWithGraph:withEdgeFilter:withInt:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "counter_", NULL, 0x0, "I", NULL,  },
    { "val$g_", NULL, 0x1012, "Lcom.graphhopper.storage.Graph;", NULL,  },
    { "val$filter_", NULL, 0x1012, "Lcom.graphhopper.routing.util.EdgeFilter;", NULL,  },
    { "val$counts_", NULL, 0x1012, "I", NULL,  },
  };
  static const J2ObjcClassInfo _GHUtility_$1 = { 1, "$1", "com.graphhopper.util", "GHUtility", 0x8000, 2, methods, 4, fields, 0, NULL};
  return &_GHUtility_$1;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GHUtility_$1)

@implementation GHUtility_$2

- (id<GHBitSet>)createBitSet {
  return val$bitset_;
}

- (jboolean)goFurtherWithInt:(jint)nodeId {
  [((id<GnuTroveListTIntList>) nil_chk(val$list_)) setWithInt:nodeId withInt:[((JavaUtilConcurrentAtomicAtomicInteger *) nil_chk(val$ref_)) incrementAndGet]];
  return [super goFurtherWithInt:nodeId];
}

- (instancetype)initWithGHBitSetImpl:(GHBitSetImpl *)capture$0
            withGnuTroveListTIntList:(id<GnuTroveListTIntList>)capture$1
withJavaUtilConcurrentAtomicAtomicInteger:(JavaUtilConcurrentAtomicAtomicInteger *)capture$2 {
  GHUtility_$2_set_val$bitset_(self, capture$0);
  GHUtility_$2_set_val$list_(self, capture$1);
  GHUtility_$2_set_val$ref_(self, capture$2);
  return [super init];
}

- (void)dealloc {
  RELEASE_(val$bitset_);
  RELEASE_(val$list_);
  RELEASE_(val$ref_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(GHUtility_$2 *)other {
  [super copyAllFieldsTo:other];
  GHUtility_$2_set_val$bitset_(other, val$bitset_);
  GHUtility_$2_set_val$list_(other, val$list_);
  GHUtility_$2_set_val$ref_(other, val$ref_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "createBitSet", NULL, "Lcom.graphhopper.coll.GHBitSet;", 0x4, NULL },
    { "goFurtherWithInt:", "goFurther", "Z", 0x4, NULL },
    { "initWithGHBitSetImpl:withGnuTroveListTIntList:withJavaUtilConcurrentAtomicAtomicInteger:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "val$bitset_", NULL, 0x1012, "Lcom.graphhopper.coll.GHBitSetImpl;", NULL,  },
    { "val$list_", NULL, 0x1012, "Lgnu.trove.list.TIntList;", NULL,  },
    { "val$ref_", NULL, 0x1012, "Ljava.util.concurrent.atomic.AtomicInteger;", NULL,  },
  };
  static const J2ObjcClassInfo _GHUtility_$2 = { 1, "$2", "com.graphhopper.util", "GHUtility", 0x8000, 3, methods, 3, fields, 0, NULL};
  return &_GHUtility_$2;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GHUtility_$2)

@implementation GHUtility_DisabledEdgeIterator

- (id<EdgeIterator>)detachWithBoolean:(jboolean)reverse {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (id<EdgeIteratorState>)setDistanceWithDouble:(jdouble)dist {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (id<EdgeIteratorState>)setFlagsWithLong:(jlong)flags {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (jboolean)next {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (jint)getEdge {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (jint)getBaseNode {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (jint)getAdjNode {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (jdouble)getDistance {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (jlong)getFlags {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (PointList *)fetchWayGeometryWithInt:(jint)type {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (id<EdgeIteratorState>)setWayGeometryWithPointList:(PointList *)list {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (NSString *)getName {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (id<EdgeIteratorState>)setNameWithNSString:(NSString *)name {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (jboolean)getBoolWithInt:(jint)key
               withBoolean:(jboolean)_default {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (jboolean)isBackwardWithFlagEncoder:(id<FlagEncoder>)encoder {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (jboolean)isForwardWithFlagEncoder:(id<FlagEncoder>)encoder {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (jint)getAdditionalField {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (id<EdgeIteratorState>)setAdditionalFieldWithInt:(jint)value {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (id<EdgeIteratorState>)copyPropertiesToWithEdgeIteratorState:(id<EdgeIteratorState>)edge {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (jboolean)isShortcut {
  return NO;
}

- (jint)getSkippedEdge1 {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (jint)getSkippedEdge2 {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (void)setSkippedEdgesWithInt:(jint)edge1
                       withInt:(jint)edge2 {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (jdouble)getWeight {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (id<CHEdgeIteratorState>)setWeightWithDouble:(jdouble)weight {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (jboolean)canBeOverwrittenWithLong:(jlong)flags {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Edge is empty."] autorelease];
}

- (instancetype)init {
  return [super init];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "detachWithBoolean:", "detach", "Lcom.graphhopper.util.EdgeIterator;", 0x1, NULL },
    { "setDistanceWithDouble:", "setDistance", "Lcom.graphhopper.util.EdgeIteratorState;", 0x1, NULL },
    { "setFlagsWithLong:", "setFlags", "Lcom.graphhopper.util.EdgeIteratorState;", 0x1, NULL },
    { "next", NULL, "Z", 0x1, NULL },
    { "getEdge", NULL, "I", 0x1, NULL },
    { "getBaseNode", NULL, "I", 0x1, NULL },
    { "getAdjNode", NULL, "I", 0x1, NULL },
    { "getDistance", NULL, "D", 0x1, NULL },
    { "getFlags", NULL, "J", 0x1, NULL },
    { "fetchWayGeometryWithInt:", "fetchWayGeometry", "Lcom.graphhopper.util.PointList;", 0x1, NULL },
    { "setWayGeometryWithPointList:", "setWayGeometry", "Lcom.graphhopper.util.EdgeIteratorState;", 0x1, NULL },
    { "getName", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "setNameWithNSString:", "setName", "Lcom.graphhopper.util.EdgeIteratorState;", 0x1, NULL },
    { "getBoolWithInt:withBoolean:", "getBool", "Z", 0x1, NULL },
    { "isBackwardWithFlagEncoder:", "isBackward", "Z", 0x1, NULL },
    { "isForwardWithFlagEncoder:", "isForward", "Z", 0x1, NULL },
    { "getAdditionalField", NULL, "I", 0x1, NULL },
    { "setAdditionalFieldWithInt:", "setAdditionalField", "Lcom.graphhopper.util.EdgeIteratorState;", 0x1, NULL },
    { "copyPropertiesToWithEdgeIteratorState:", "copyPropertiesTo", "Lcom.graphhopper.util.EdgeIteratorState;", 0x1, NULL },
    { "isShortcut", NULL, "Z", 0x1, NULL },
    { "getSkippedEdge1", NULL, "I", 0x1, NULL },
    { "getSkippedEdge2", NULL, "I", 0x1, NULL },
    { "setSkippedEdgesWithInt:withInt:", "setSkippedEdges", "V", 0x1, NULL },
    { "getWeight", NULL, "D", 0x1, NULL },
    { "setWeightWithDouble:", "setWeight", "Lcom.graphhopper.util.CHEdgeIteratorState;", 0x1, NULL },
    { "canBeOverwrittenWithLong:", "canBeOverwritten", "Z", 0x1, NULL },
    { "init", NULL, NULL, 0x1, NULL },
  };
  static const J2ObjcClassInfo _GHUtility_DisabledEdgeIterator = { 1, "DisabledEdgeIterator", "com.graphhopper.util", "GHUtility", 0x9, 27, methods, 0, NULL, 0, NULL};
  return &_GHUtility_DisabledEdgeIterator;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GHUtility_DisabledEdgeIterator)

@implementation GHUtility_$3

- (jdouble)getDistance {
  return val$distance_;
}

- (jlong)getFlags {
  return val$flags_;
}

- (jboolean)getBoolWithInt:(jint)key
               withBoolean:(jboolean)_default {
  return _default;
}

- (instancetype)initWithDouble:(jdouble)capture$0
                      withLong:(jlong)capture$1 {
  val$distance_ = capture$0;
  val$flags_ = capture$1;
  return [super init];
}

- (void)copyAllFieldsTo:(GHUtility_$3 *)other {
  [super copyAllFieldsTo:other];
  other->val$distance_ = val$distance_;
  other->val$flags_ = val$flags_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "getDistance", NULL, "D", 0x1, NULL },
    { "getFlags", NULL, "J", 0x1, NULL },
    { "getBoolWithInt:withBoolean:", "getBool", "Z", 0x1, NULL },
    { "initWithDouble:withLong:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "val$distance_", NULL, 0x1012, "D", NULL,  },
    { "val$flags_", NULL, 0x1012, "J", NULL,  },
  };
  static const J2ObjcClassInfo _GHUtility_$3 = { 1, "$3", "com.graphhopper.util", "GHUtility", 0x8000, 4, methods, 2, fields, 0, NULL};
  return &_GHUtility_$3;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GHUtility_$3)
