//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/util/InstructionList.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/util/Constants.h"
#include "com/graphhopper/util/DistanceCalc.h"
#include "com/graphhopper/util/GPXEntry.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/Instruction.h"
#include "com/graphhopper/util/InstructionAnnotation.h"
#include "com/graphhopper/util/InstructionList.h"
#include "com/graphhopper/util/PointList.h"
#include "com/graphhopper/util/Translation.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/StringBuilder.h"
#include "java/text/DateFormat.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/Collections.h"
#include "java/util/Date.h"
#include "java/util/HashMap.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"
#include "java/util/Map.h"

__attribute__((unused)) static void InstructionList_createWayPointBlockWithJavaLangStringBuilder_withInstruction_(InstructionList *self, JavaLangStringBuilder *output, Instruction *instruction);

@interface InstructionList () {
 @public
  id<JavaUtilList> instructions_;
  id<Translation> tr_;
}
- (instancetype)init;

- (void)createWayPointBlockWithJavaLangStringBuilder:(JavaLangStringBuilder *)output
                                     withInstruction:(Instruction *)instruction;
@end

J2OBJC_FIELD_SETTER(InstructionList, instructions_, id<JavaUtilList>)
J2OBJC_FIELD_SETTER(InstructionList, tr_, id<Translation>)

BOOL InstructionList_initialized = NO;

@implementation InstructionList

InstructionList * InstructionList_EMPTY_;

- (instancetype)init {
  return [self initInstructionListWithInt:0 withTranslation:nil];
}

- (instancetype)initWithTranslation:(id<Translation>)tr {
  return [self initInstructionListWithInt:10 withTranslation:tr];
}

- (instancetype)initInstructionListWithInt:(jint)cap
                           withTranslation:(id<Translation>)tr {
  if (self = [super init]) {
    InstructionList_setAndConsume_instructions_(self, [[JavaUtilArrayList alloc] initWithInt:cap]);
    InstructionList_set_tr_(self, tr);
  }
  return self;
}

- (instancetype)initWithInt:(jint)cap
            withTranslation:(id<Translation>)tr {
  return [self initInstructionListWithInt:cap withTranslation:tr];
}

+ (NSString *)simpleXMLEscapeWithNSString:(NSString *)str {
  return InstructionList_simpleXMLEscapeWithNSString_(str);
}

- (void)replaceLastWithInstruction:(Instruction *)instr {
  if ([((id<JavaUtilList>) nil_chk(instructions_)) isEmpty]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Cannot replace last instruction as list is empty"] autorelease];
  [instructions_ setWithInt:[instructions_ size] - 1 withId:instr];
}

- (void)addWithInstruction:(Instruction *)instr {
  [((id<JavaUtilList>) nil_chk(instructions_)) addWithId:instr];
}

- (jint)getSize {
  return [((id<JavaUtilList>) nil_chk(instructions_)) size];
}

- (jint)size {
  return [((id<JavaUtilList>) nil_chk(instructions_)) size];
}

- (id<JavaUtilList>)createJson {
  id<JavaUtilList> instrList = [[[JavaUtilArrayList alloc] initWithInt:[((id<JavaUtilList>) nil_chk(instructions_)) size]] autorelease];
  jint pointsIndex = 0;
  jint counter = 0;
  for (Instruction * __strong instruction in instructions_) {
    id<JavaUtilMap> instrJson = [[[JavaUtilHashMap alloc] init] autorelease];
    [instrList addWithId:instrJson];
    InstructionAnnotation *ia = [((Instruction *) nil_chk(instruction)) getAnnotation];
    NSString *str = [instruction getTurnDescriptionWithTranslation:tr_];
    if (Helper_isEmptyWithNSString_(str)) str = [((InstructionAnnotation *) nil_chk(ia)) getMessage];
    [instrJson putWithId:@"text" withId:Helper_firstBigWithNSString_(str)];
    if (![((InstructionAnnotation *) nil_chk(ia)) isEmpty]) {
      [instrJson putWithId:@"annotation_text" withId:[ia getMessage]];
      [instrJson putWithId:@"annotation_importance" withId:JavaLangInteger_valueOfWithInt_([ia getImportance])];
    }
    [instrJson putWithId:@"time" withId:JavaLangLong_valueOfWithLong_([instruction getTime])];
    [instrJson putWithId:@"distance" withId:JavaLangDouble_valueOfWithDouble_(Helper_roundWithDouble_withInt_([instruction getDistance], 3))];
    [instrJson putWithId:@"sign" withId:JavaLangInteger_valueOfWithInt_([instruction getSign])];
    [instrJson putAllWithJavaUtilMap:[instruction getExtraInfoJSON]];
    jint tmpIndex = pointsIndex + [((PointList *) nil_chk([instruction getPoints])) size];
    if (counter + 1 == [instructions_ size]) tmpIndex--;
    [instrJson putWithId:@"interval" withId:JavaUtilArrays_asListWithNSObjectArray_([IOSObjectArray arrayWithObjects:(id[]){ JavaLangInteger_valueOfWithInt_(pointsIndex), JavaLangInteger_valueOfWithInt_(tmpIndex) } count:2 type:JavaLangInteger_class_()])];
    pointsIndex = tmpIndex;
    counter++;
  }
  return instrList;
}

- (jboolean)isEmpty {
  return [((id<JavaUtilList>) nil_chk(instructions_)) isEmpty];
}

- (id<JavaUtilIterator>)iterator {
  return [((id<JavaUtilList>) nil_chk(instructions_)) iterator];
}

- (Instruction *)getWithInt:(jint)index {
  return [((id<JavaUtilList>) nil_chk(instructions_)) getWithInt:index];
}

- (NSString *)description {
  return [((id<JavaUtilList>) nil_chk(instructions_)) description];
}

- (id<JavaUtilList>)createGPXList {
  if ([self isEmpty]) return JavaUtilCollections_emptyList();
  id<JavaUtilList> gpxList = [[[JavaUtilArrayList alloc] init] autorelease];
  jlong timeOffset = 0;
  for (jint i = 0; i < [self size] - 1; i++) {
    Instruction *prevInstr = (i > 0) ? [self getWithInt:i - 1] : nil;
    jboolean instrIsFirst = prevInstr == nil;
    Instruction *nextInstr = [self getWithInt:i + 1];
    [((Instruction *) nil_chk(nextInstr)) checkOne];
    timeOffset = [((Instruction *) nil_chk([self getWithInt:i])) fillGPXListWithJavaUtilList:gpxList withLong:timeOffset withInstruction:prevInstr withInstruction:nextInstr withBoolean:instrIsFirst];
  }
  Instruction *lastI = [self getWithInt:[self size] - 1];
  if ([((PointList *) nil_chk(((Instruction *) nil_chk(lastI))->points_)) size] != 1) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I", @"Last instruction must have exactly one point but was ", [lastI->points_ size])] autorelease];
  jdouble lastLat = [lastI getFirstLat], lastLon = [lastI getFirstLon], lastEle = [((PointList *) nil_chk([lastI getPoints])) is3D] ? [lastI getFirstEle] : JavaLangDouble_NaN;
  [gpxList addWithId:[[[GPXEntry alloc] initWithDouble:lastLat withDouble:lastLon withDouble:lastEle withLong:timeOffset] autorelease]];
  return gpxList;
}

- (NSString *)createGPX {
  return [self createGPXWithNSString:@"GraphHopper" withLong:[((JavaUtilDate *) [[[JavaUtilDate alloc] init] autorelease]) getTime]];
}

- (NSString *)createGPXWithNSString:(NSString *)trackName
                           withLong:(jlong)startTimeMillis {
  jboolean includeElevation = [self getSize] > 0 ? [((PointList *) nil_chk([((Instruction *) nil_chk([self getWithInt:0])) getPoints])) is3D] : NO;
  return [self createGPXWithNSString:trackName withLong:startTimeMillis withBoolean:includeElevation withBoolean:YES withBoolean:YES withBoolean:YES];
}

- (void)createWayPointBlockWithJavaLangStringBuilder:(JavaLangStringBuilder *)output
                                     withInstruction:(Instruction *)instruction {
  InstructionList_createWayPointBlockWithJavaLangStringBuilder_withInstruction_(self, output, instruction);
}

- (NSString *)createGPXWithNSString:(NSString *)trackName
                           withLong:(jlong)startTimeMillis
                        withBoolean:(jboolean)includeElevation
                        withBoolean:(jboolean)withRoute
                        withBoolean:(jboolean)withTrack
                        withBoolean:(jboolean)withWayPoints {
  JavaTextDateFormat *formatter = Helper_createFormatter();
  NSString *header = JreStrcat("$$$$$", @"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?><gpx xmlns=\"http://www.topografix.com/GPX/1/1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" creator=\"Graphhopper version ", Constants_get_VERSION_(), @"\" version=\"1.1\" xmlns:gh=\"https://graphhopper.com/public/schema/gpx/1.1\">\n<metadata><copyright author=\"OpenStreetMap contributors\"/><link href=\"http://graphhopper.com\"><text>GraphHopper GPX</text></link><time>", [((JavaTextDateFormat *) nil_chk(formatter)) formatWithId:JavaLangLong_valueOfWithLong_(startTimeMillis)], @"</time></metadata>");
  JavaLangStringBuilder *gpxOutput = [[[JavaLangStringBuilder alloc] initWithNSString:header] autorelease];
  if (![self isEmpty]) {
    if (withWayPoints) {
      InstructionList_createWayPointBlockWithJavaLangStringBuilder_withInstruction_(self, gpxOutput, [((id<JavaUtilList>) nil_chk(instructions_)) getWithInt:0]);
      for (Instruction * __strong currInstr in instructions_) {
        if (([((Instruction *) nil_chk(currInstr)) getSign] == Instruction_REACHED_VIA) || ([currInstr getSign] == Instruction_FINISH)) {
          InstructionList_createWayPointBlockWithJavaLangStringBuilder_withInstruction_(self, gpxOutput, currInstr);
        }
      }
    }
    if (withRoute) {
      [gpxOutput appendWithNSString:@"\n<rte>"];
      Instruction *nextInstr = nil;
      for (Instruction * __strong currInstr in nil_chk(instructions_)) {
        if (nil != nextInstr) [self createRteptBlockWithJavaLangStringBuilder:gpxOutput withInstruction:nextInstr withInstruction:currInstr];
        nextInstr = currInstr;
      }
      [self createRteptBlockWithJavaLangStringBuilder:gpxOutput withInstruction:nextInstr withInstruction:nil];
      [gpxOutput appendWithNSString:@"\n</rte>"];
    }
  }
  if (withTrack) {
    [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([gpxOutput appendWithNSString:@"\n<trk><name>"])) appendWithNSString:trackName])) appendWithNSString:@"</name>"];
    [gpxOutput appendWithNSString:@"<trkseg>"];
    for (GPXEntry * __strong entry_ in nil_chk([self createGPXList])) {
      [((JavaLangStringBuilder *) nil_chk([gpxOutput appendWithNSString:@"\n<trkpt lat=\""])) appendWithDouble:Helper_round6WithDouble_([((GPXEntry *) nil_chk(entry_)) getLat])];
      [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([gpxOutput appendWithNSString:@"\" lon=\""])) appendWithDouble:Helper_round6WithDouble_([entry_ getLon])])) appendWithNSString:@"\">"];
      if (includeElevation) [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([gpxOutput appendWithNSString:@"<ele>"])) appendWithDouble:Helper_round2WithDouble_([entry_ getEle])])) appendWithNSString:@"</ele>"];
      [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([gpxOutput appendWithNSString:@"<time>"])) appendWithNSString:[formatter formatWithId:JavaLangLong_valueOfWithLong_(startTimeMillis + [entry_ getTime])]])) appendWithNSString:@"</time>"];
      [gpxOutput appendWithNSString:@"</trkpt>"];
    }
    [gpxOutput appendWithNSString:@"\n</trkseg>"];
    [gpxOutput appendWithNSString:@"\n</trk>"];
  }
  [gpxOutput appendWithNSString:@"\n</gpx>"];
  return [gpxOutput description];
}

- (void)createRteptBlockWithJavaLangStringBuilder:(JavaLangStringBuilder *)output
                                  withInstruction:(Instruction *)instruction
                                  withInstruction:(Instruction *)nextI {
  [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk(output)) appendWithNSString:@"\n<rtept lat=\""])) appendWithDouble:Helper_round6WithDouble_([((Instruction *) nil_chk(instruction)) getFirstLat])])) appendWithNSString:@"\" lon=\""])) appendWithDouble:Helper_round6WithDouble_([instruction getFirstLon])])) appendWithNSString:@"\">"];
  if (![((NSString *) nil_chk([instruction getName])) isEmpty]) [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([output appendWithNSString:@"<desc>"])) appendWithNSString:InstructionList_simpleXMLEscapeWithNSString_([instruction getTurnDescriptionWithTranslation:tr_])])) appendWithNSString:@"</desc>"];
  [output appendWithNSString:@"<extensions>"];
  [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([output appendWithNSString:@"<gh:distance>"])) appendWithDouble:Helper_roundWithDouble_withInt_([instruction getDistance], 1)])) appendWithNSString:@"</gh:distance>"];
  [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([output appendWithNSString:@"<gh:time>"])) appendWithLong:[instruction getTime]])) appendWithNSString:@"</gh:time>"];
  NSString *direction = [instruction calcDirectionWithInstruction:nextI];
  if (![((NSString *) nil_chk(direction)) isEmpty]) [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([output appendWithNSString:@"<gh:direction>"])) appendWithNSString:direction])) appendWithNSString:@"</gh:direction>"];
  jdouble azimuth = [instruction calcAzimuthWithInstruction:nextI];
  if (!JavaLangDouble_isNaNWithDouble_(azimuth)) [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([output appendWithNSString:@"<gh:azimuth>"])) appendWithDouble:Helper_round2WithDouble_(azimuth)])) appendWithNSString:@"</gh:azimuth>"];
  [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([output appendWithNSString:@"<gh:sign>"])) appendWithInt:[instruction getSign]])) appendWithNSString:@"</gh:sign>"];
  [output appendWithNSString:@"</extensions>"];
  [output appendWithNSString:@"</rtept>"];
}

- (id<JavaUtilList>)createStartPoints {
  id<JavaUtilList> res = [[[JavaUtilArrayList alloc] initWithInt:[((id<JavaUtilList>) nil_chk(instructions_)) size]] autorelease];
  for (Instruction * __strong instruction in instructions_) {
    [res addWithId:JavaUtilArrays_asListWithNSObjectArray_([IOSObjectArray arrayWithObjects:(id[]){ JavaLangDouble_valueOfWithDouble_([((Instruction *) nil_chk(instruction)) getFirstLat]), JavaLangDouble_valueOfWithDouble_([instruction getFirstLon]) } count:2 type:JavaLangDouble_class_()])];
  }
  return res;
}

- (Instruction *)findWithDouble:(jdouble)lat
                     withDouble:(jdouble)lon
                     withDouble:(jdouble)maxDistance {
  if ([self getSize] == 0) {
    return nil;
  }
  PointList *points = [((Instruction *) nil_chk([self getWithInt:0])) getPoints];
  jdouble prevLat = [((PointList *) nil_chk(points)) getLatitudeWithInt:0];
  jdouble prevLon = [points getLongitudeWithInt:0];
  id<DistanceCalc> distCalc = Helper_get_DIST_EARTH_();
  jdouble foundMinDistance = [((id<DistanceCalc>) nil_chk(distCalc)) calcNormalizedDistWithDouble:lat withDouble:lon withDouble:prevLat withDouble:prevLon];
  jint foundInstruction = 0;
  if ([self getSize] > 1) {
    for (jint instructionIndex = 0; instructionIndex < [self getSize]; instructionIndex++) {
      points = [((Instruction *) nil_chk([self getWithInt:instructionIndex])) getPoints];
      for (jint pointIndex = 0; pointIndex < [((PointList *) nil_chk(points)) size]; pointIndex++) {
        jdouble currLat = [points getLatitudeWithInt:pointIndex];
        jdouble currLon = [points getLongitudeWithInt:pointIndex];
        if (!(instructionIndex == 0 && pointIndex == 0)) {
          jdouble distance;
          jint index = instructionIndex;
          if ([distCalc validEdgeDistanceWithDouble:lat withDouble:lon withDouble:currLat withDouble:currLon withDouble:prevLat withDouble:prevLon]) {
            distance = [distCalc calcNormalizedEdgeDistanceWithDouble:lat withDouble:lon withDouble:currLat withDouble:currLon withDouble:prevLat withDouble:prevLon];
            if (pointIndex > 0) index++;
          }
          else {
            distance = [distCalc calcNormalizedDistWithDouble:lat withDouble:lon withDouble:currLat withDouble:currLon];
            if (pointIndex > 0) index++;
          }
          if (distance < foundMinDistance) {
            foundMinDistance = distance;
            foundInstruction = index;
          }
        }
        prevLat = currLat;
        prevLon = currLon;
      }
    }
  }
  if ([distCalc calcDenormalizedDistWithDouble:foundMinDistance] > maxDistance) return nil;
  if (foundInstruction == [self getSize]) foundInstruction--;
  return [self getWithInt:foundInstruction];
}

- (void)dealloc {
  RELEASE_(instructions_);
  RELEASE_(tr_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(InstructionList *)other {
  [super copyAllFieldsTo:other];
  InstructionList_set_instructions_(other, instructions_);
  InstructionList_set_tr_(other, tr_);
}

- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unsafe_unretained id *)stackbuf count:(NSUInteger)len {
  return JreDefaultFastEnumeration(self, state, stackbuf, len);
}

+ (void)initialize {
  if (self == [InstructionList class]) {
    JreStrongAssignAndConsume(&InstructionList_EMPTY_, nil, [[InstructionList alloc] init]);
    J2OBJC_SET_INITIALIZED(InstructionList)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "InstructionList", NULL, 0x2, NULL },
    { "initWithTranslation:", "InstructionList", NULL, 0x1, NULL },
    { "initWithInt:withTranslation:", "InstructionList", NULL, 0x1, NULL },
    { "simpleXMLEscapeWithNSString:", "simpleXMLEscape", "Ljava.lang.String;", 0x8, NULL },
    { "replaceLastWithInstruction:", "replaceLast", "V", 0x1, NULL },
    { "addWithInstruction:", "add", "V", 0x1, NULL },
    { "getSize", NULL, "I", 0x1, NULL },
    { "size", NULL, "I", 0x1, NULL },
    { "createJson", NULL, "Ljava.util.List;", 0x1, NULL },
    { "isEmpty", NULL, "Z", 0x1, NULL },
    { "iterator", NULL, "Ljava.util.Iterator;", 0x1, NULL },
    { "getWithInt:", "get", "Lcom.graphhopper.util.Instruction;", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "createGPXList", NULL, "Ljava.util.List;", 0x1, NULL },
    { "createGPX", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "createGPXWithNSString:withLong:", "createGPX", "Ljava.lang.String;", 0x1, NULL },
    { "createWayPointBlockWithJavaLangStringBuilder:withInstruction:", "createWayPointBlock", "V", 0x2, NULL },
    { "createGPXWithNSString:withLong:withBoolean:withBoolean:withBoolean:withBoolean:", "createGPX", "Ljava.lang.String;", 0x1, NULL },
    { "createRteptBlockWithJavaLangStringBuilder:withInstruction:withInstruction:", "createRteptBlock", "V", 0x1, NULL },
    { "createStartPoints", NULL, "Ljava.util.List;", 0x0, NULL },
    { "findWithDouble:withDouble:withDouble:", "find", "Lcom.graphhopper.util.Instruction;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "EMPTY_", NULL, 0x19, "Lcom.graphhopper.util.InstructionList;", &InstructionList_EMPTY_,  },
    { "instructions_", NULL, 0x12, "Ljava.util.List;", NULL,  },
    { "tr_", NULL, 0x12, "Lcom.graphhopper.util.Translation;", NULL,  },
  };
  static const J2ObjcClassInfo _InstructionList = { 1, "InstructionList", "com.graphhopper.util", NULL, 0x1, 21, methods, 3, fields, 0, NULL};
  return &_InstructionList;
}

@end

NSString *InstructionList_simpleXMLEscapeWithNSString_(NSString *str) {
  InstructionList_init();
  return [((NSString *) nil_chk([((NSString *) nil_chk(str)) replaceAll:@"&" withReplacement:@"&amp;"])) replaceAll:@"[\\<\\>]" withReplacement:@"_"];
}

void InstructionList_createWayPointBlockWithJavaLangStringBuilder_withInstruction_(InstructionList *self, JavaLangStringBuilder *output, Instruction *instruction) {
  [((JavaLangStringBuilder *) nil_chk(output)) appendWithNSString:@"\n<wpt "];
  [((JavaLangStringBuilder *) nil_chk([output appendWithNSString:@"lat=\""])) appendWithDouble:Helper_round6WithDouble_([((Instruction *) nil_chk(instruction)) getFirstLat])];
  [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([output appendWithNSString:@"\" lon=\""])) appendWithDouble:Helper_round6WithDouble_([instruction getFirstLon])])) appendWithNSString:@"\">"];
  NSString *name;
  if ([((NSString *) nil_chk([instruction getName])) isEmpty]) name = [instruction getTurnDescriptionWithTranslation:self->tr_];
  else name = [instruction getName];
  [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([output appendWithNSString:@" <name>"])) appendWithNSString:InstructionList_simpleXMLEscapeWithNSString_(name)])) appendWithNSString:@"</name>"];
  [output appendWithNSString:@"</wpt>"];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(InstructionList)
