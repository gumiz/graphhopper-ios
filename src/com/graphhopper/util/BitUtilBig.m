//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/util/BitUtilBig.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/util/BitUtil.h"
#include "com/graphhopper/util/BitUtilBig.h"
#include "java/lang/StringBuilder.h"

__attribute__((unused)) static jint BitUtilBig_toIntWithByteArray_withInt_(BitUtilBig *self, IOSByteArray *b, jint offset);

@implementation BitUtilBig

- (instancetype)init {
  return [super init];
}

- (jshort)toShortWithByteArray:(IOSByteArray *)b
                       withInt:(jint)offset {
  return (jshort) ((LShift32((IOSByteArray_Get(nil_chk(b), offset) & (jint) 0xFF), 8)) | (IOSByteArray_Get(b, offset + 1) & (jint) 0xFF));
}

- (jint)toIntWithByteArray:(IOSByteArray *)b
                   withInt:(jint)offset {
  return BitUtilBig_toIntWithByteArray_withInt_(self, b, offset);
}

- (void)fromShortWithByteArray:(IOSByteArray *)bytes
                     withShort:(jshort)value
                       withInt:(jint)offset {
  *IOSByteArray_GetRef(nil_chk(bytes), offset) = (jbyte) (RShift32(value, 8));
  *IOSByteArray_GetRef(bytes, offset + 1) = (jbyte) (value);
}

- (void)fromIntWithByteArray:(IOSByteArray *)bytes
                     withInt:(jint)value
                     withInt:(jint)offset {
  *IOSByteArray_GetRef(nil_chk(bytes), offset) = (jbyte) (RShift32(value, 24));
  *IOSByteArray_GetRef(bytes, ++offset) = (jbyte) (RShift32(value, 16));
  *IOSByteArray_GetRef(bytes, ++offset) = (jbyte) (RShift32(value, 8));
  *IOSByteArray_GetRef(bytes, ++offset) = (jbyte) (value);
}

- (jlong)toLongWithInt:(jint)int0
               withInt:(jint)int1 {
  return (LShift64((jlong) int0, 32)) | (int1 & (jlong) 0xFFFFFFFFLL);
}

- (jlong)toLongWithByteArray:(IOSByteArray *)b
                     withInt:(jint)offset {
  return (LShift64((jlong) BitUtilBig_toIntWithByteArray_withInt_(self, b, offset), 32)) | (BitUtilBig_toIntWithByteArray_withInt_(self, b, offset + 4) & (jlong) 0xFFFFFFFFLL);
}

- (void)fromLongWithByteArray:(IOSByteArray *)bytes
                     withLong:(jlong)value
                      withInt:(jint)offset {
  *IOSByteArray_GetRef(nil_chk(bytes), offset) = (jbyte) (RShift64(value, 56));
  *IOSByteArray_GetRef(bytes, ++offset) = (jbyte) (RShift64(value, 48));
  *IOSByteArray_GetRef(bytes, ++offset) = (jbyte) (RShift64(value, 40));
  *IOSByteArray_GetRef(bytes, ++offset) = (jbyte) (RShift64(value, 32));
  *IOSByteArray_GetRef(bytes, ++offset) = (jbyte) (RShift64(value, 24));
  *IOSByteArray_GetRef(bytes, ++offset) = (jbyte) (RShift64(value, 16));
  *IOSByteArray_GetRef(bytes, ++offset) = (jbyte) (RShift64(value, 8));
  *IOSByteArray_GetRef(bytes, ++offset) = (jbyte) (value);
}

- (IOSByteArray *)fromBitStringWithNSString:(NSString *)str {
  jint strLen = ((jint) [((NSString *) nil_chk(str)) length]);
  jint bLen = ((jint) [str length]) / 8;
  if (strLen % 8 != 0) bLen++;
  IOSByteArray *bytes = [IOSByteArray arrayWithLength:bLen];
  jint charI = 0;
  for (jint b = 0; b < bLen; b++) {
    jbyte res = 0;
    for (jint i = 0; i < 8; i++) {
      LShiftAssignByte(&res, 1);
      if (charI < strLen && [str charAtWithInt:charI] != '0') res |= 1;
      charI++;
    }
    *IOSByteArray_GetRef(bytes, b) = res;
  }
  return bytes;
}

- (NSString *)toBitStringWithByteArray:(IOSByteArray *)bytes {
  JavaLangStringBuilder *sb = [[[JavaLangStringBuilder alloc] initWithInt:((IOSByteArray *) nil_chk(bytes))->size_ * 8] autorelease];
  jbyte lastBit = (jbyte) (LShift32(1, 7));
  {
    IOSByteArray *a__ = bytes;
    jbyte const *b__ = a__->buffer_;
    jbyte const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      jbyte b = *b__++;
      for (jint i = 0; i < 8; i++) {
        if ((b & lastBit) == 0) [sb appendWithChar:'0'];
        else [sb appendWithChar:'1'];
        LShiftAssignByte(&b, 1);
      }
    }
  }
  return [sb description];
}

- (jlong)reversePartWithLong:(jlong)v
                     withInt:(jint)maxBits {
  jlong rest = v & (~((LShift64(1LL, maxBits)) - 1));
  return rest | [self reverseWithLong:v withInt:maxBits];
}

- (NSString *)description {
  return @"big";
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "BitUtilBig", NULL, 0x0, NULL },
    { "toShortWithByteArray:withInt:", "toShort", "S", 0x11, NULL },
    { "toIntWithByteArray:withInt:", "toInt", "I", 0x11, NULL },
    { "fromShortWithByteArray:withShort:withInt:", "fromShort", "V", 0x1, NULL },
    { "fromIntWithByteArray:withInt:withInt:", "fromInt", "V", 0x11, NULL },
    { "toLongWithInt:withInt:", "toLong", "J", 0x11, NULL },
    { "toLongWithByteArray:withInt:", "toLong", "J", 0x11, NULL },
    { "fromLongWithByteArray:withLong:withInt:", "fromLong", "V", 0x11, NULL },
    { "fromBitStringWithNSString:", "fromBitString", "[B", 0x1, NULL },
    { "toBitStringWithByteArray:", "toBitString", "Ljava.lang.String;", 0x1, NULL },
    { "reversePartWithLong:withInt:", "reversePart", "J", 0x10, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcClassInfo _BitUtilBig = { 1, "BitUtilBig", "com.graphhopper.util", NULL, 0x1, 12, methods, 0, NULL, 0, NULL};
  return &_BitUtilBig;
}

@end

jint BitUtilBig_toIntWithByteArray_withInt_(BitUtilBig *self, IOSByteArray *b, jint offset) {
  jint unseq$1 = offset;
  jint unseq$2 = ++offset;
  jint unseq$3 = ++offset;
  return (((LShift32((IOSByteArray_Get(nil_chk(b), unseq$1) & (jint) 0xFF), 24)) | (LShift32((IOSByteArray_Get(b, unseq$2) & (jint) 0xFF), 16))) | (LShift32((IOSByteArray_Get(b, unseq$3) & (jint) 0xFF), 8))) | (IOSByteArray_Get(b, ++offset) & (jint) 0xFF);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(BitUtilBig)
