//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
//

#include "J2ObjC_source.h"
#include "com/graphhopper/util/DistanceCalc.h"
#include "com/graphhopper/util/DistancePlaneProjection.h"
#include "com/graphhopper/util/DouglasPeucker.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/PointList.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Math.h"

@interface DouglasPeucker () {
 @public
  jdouble normedMaxDist_;
  id<DistanceCalc> calc_;
  jboolean approx_;
}
@end

J2OBJC_FIELD_SETTER(DouglasPeucker, calc_, id<DistanceCalc>)

@implementation DouglasPeucker

- (instancetype)init {
  if (self = [super init]) {
    [self setApproximationWithBoolean:YES];
    [self setMaxDistanceWithDouble:1];
  }
  return self;
}

- (void)setApproximationWithBoolean:(jboolean)a {
  approx_ = a;
  if (approx_) DouglasPeucker_set_calc_(self, Helper_get_DIST_PLANE_());
  else DouglasPeucker_set_calc_(self, Helper_get_DIST_EARTH_());
}

- (DouglasPeucker *)setMaxDistanceWithDouble:(jdouble)dist {
  self->normedMaxDist_ = [((id<DistanceCalc>) nil_chk(calc_)) calcNormalizedDistWithDouble:dist];
  return self;
}

- (jint)simplifyWithPointList:(PointList *)points {
  jint removed = 0;
  jint size = [((PointList *) nil_chk(points)) getSize];
  if (approx_) {
    jint delta = 500;
    jint segments = size / delta + 1;
    jint start = 0;
    for (jint i = 0; i < segments; i++) {
      removed += [self simplifyWithPointList:points withInt:start withInt:JavaLangMath_minWithInt_withInt_(size - 1, start + delta)];
      start += delta;
    }
  }
  else {
    removed = [self simplifyWithPointList:points withInt:0 withInt:size - 1];
  }
  [self compressNewWithPointList:points withInt:removed];
  return removed;
}

- (void)compressNewWithPointList:(PointList *)points
                         withInt:(jint)removed {
  jint freeIndex = -1;
  for (jint currentIndex = 0; currentIndex < [((PointList *) nil_chk(points)) getSize]; currentIndex++) {
    if (JavaLangDouble_isNaNWithDouble_([points getLatitudeWithInt:currentIndex])) {
      if (freeIndex < 0) freeIndex = currentIndex;
      continue;
    }
    else if (freeIndex < 0) {
      continue;
    }
    [points setWithInt:freeIndex withDouble:[points getLatitudeWithInt:currentIndex] withDouble:[points getLongitudeWithInt:currentIndex] withDouble:[points getElevationWithInt:currentIndex]];
    [points setWithInt:currentIndex withDouble:JavaLangDouble_NaN withDouble:JavaLangDouble_NaN withDouble:JavaLangDouble_NaN];
    jint max = currentIndex;
    jint searchIndex = freeIndex + 1;
    freeIndex = currentIndex;
    for (; searchIndex < max; searchIndex++) {
      if (JavaLangDouble_isNaNWithDouble_([points getLatitudeWithInt:searchIndex])) {
        freeIndex = searchIndex;
        break;
      }
    }
  }
  [points trimToSizeWithInt:[points getSize] - removed];
}

- (jint)simplifyWithPointList:(PointList *)points
                      withInt:(jint)fromIndex
                      withInt:(jint)lastIndex {
  if (lastIndex - fromIndex < 2) {
    return 0;
  }
  jint indexWithMaxDist = -1;
  jdouble maxDist = -1;
  jdouble firstLat = [((PointList *) nil_chk(points)) getLatitudeWithInt:fromIndex];
  jdouble firstLon = [points getLongitudeWithInt:fromIndex];
  jdouble lastLat = [points getLatitudeWithInt:lastIndex];
  jdouble lastLon = [points getLongitudeWithInt:lastIndex];
  for (jint i = fromIndex + 1; i < lastIndex; i++) {
    jdouble lat = [points getLatitudeWithInt:i];
    if (JavaLangDouble_isNaNWithDouble_(lat)) {
      continue;
    }
    jdouble lon = [points getLongitudeWithInt:i];
    jdouble dist = [((id<DistanceCalc>) nil_chk(calc_)) calcNormalizedEdgeDistanceWithDouble:lat withDouble:lon withDouble:firstLat withDouble:firstLon withDouble:lastLat withDouble:lastLon];
    if (maxDist < dist) {
      indexWithMaxDist = i;
      maxDist = dist;
    }
  }
  if (indexWithMaxDist < 0) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$ICIC", @"maximum not found in [", fromIndex, ',', lastIndex, ']')] autorelease];
  }
  jint counter = 0;
  if (maxDist < normedMaxDist_) {
    for (jint i = fromIndex + 1; i < lastIndex; i++) {
      [points setWithInt:i withDouble:JavaLangDouble_NaN withDouble:JavaLangDouble_NaN withDouble:JavaLangDouble_NaN];
      counter++;
    }
  }
  else {
    counter = [self simplifyWithPointList:points withInt:fromIndex withInt:indexWithMaxDist];
    counter += [self simplifyWithPointList:points withInt:indexWithMaxDist withInt:lastIndex];
  }
  return counter;
}

- (void)dealloc {
  RELEASE_(calc_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(DouglasPeucker *)other {
  [super copyAllFieldsTo:other];
  other->normedMaxDist_ = normedMaxDist_;
  DouglasPeucker_set_calc_(other, calc_);
  other->approx_ = approx_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "DouglasPeucker", NULL, 0x1, NULL },
    { "setApproximationWithBoolean:", "setApproximation", "V", 0x1, NULL },
    { "setMaxDistanceWithDouble:", "setMaxDistance", "Lcom.graphhopper.util.DouglasPeucker;", 0x1, NULL },
    { "simplifyWithPointList:", "simplify", "I", 0x1, NULL },
    { "compressNewWithPointList:withInt:", "compressNew", "V", 0x0, NULL },
    { "simplifyWithPointList:withInt:withInt:", "simplify", "I", 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "normedMaxDist_", NULL, 0x2, "D", NULL,  },
    { "calc_", NULL, 0x2, "Lcom.graphhopper.util.DistanceCalc;", NULL,  },
    { "approx_", NULL, 0x2, "Z", NULL,  },
  };
  static const J2ObjcClassInfo _DouglasPeucker = { 1, "DouglasPeucker", "com.graphhopper.util", NULL, 0x1, 6, methods, 3, fields, 0, NULL};
  return &_DouglasPeucker;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(DouglasPeucker)
