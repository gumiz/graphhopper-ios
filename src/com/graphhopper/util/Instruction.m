//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/util/Instruction.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/util/AngleCalc.h"
#include "com/graphhopper/util/DistanceCalc3D.h"
#include "com/graphhopper/util/GPXEntry.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/Instruction.h"
#include "com/graphhopper/util/InstructionAnnotation.h"
#include "com/graphhopper/util/PointList.h"
#include "com/graphhopper/util/Translation.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Math.h"
#include "java/lang/StringBuilder.h"
#include "java/util/Collections.h"
#include "java/util/List.h"
#include "java/util/Map.h"

@interface Instruction () {
}
@end

BOOL Instruction_initialized = NO;

@implementation Instruction

AngleCalc * Instruction_AC_;

- (instancetype)initWithInt:(jint)sign
               withNSString:(NSString *)name
  withInstructionAnnotation:(InstructionAnnotation *)ia
              withPointList:(PointList *)pl {
  if (self = [super init]) {
    self->sign_ = sign;
    Instruction_set_name_(self, name);
    Instruction_set_points_(self, pl);
    Instruction_set_annotation_(self, ia);
  }
  return self;
}

- (void)setUseRawName {
  rawName_ = YES;
}

- (InstructionAnnotation *)getAnnotation {
  return annotation_;
}

- (jint)getSign {
  return sign_;
}

- (NSString *)getName {
  return name_;
}

- (void)setNameWithNSString:(NSString *)name {
  Instruction_set_name_(self, name);
}

- (id<JavaUtilMap>)getExtraInfoJSON {
  return JavaUtilCollections_emptyMap();
}

- (void)setExtraInfoWithNSString:(NSString *)key
                          withId:(id)value {
  @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$$$", @"Key", key, @" is not a valid option")] autorelease];
}

- (jdouble)getDistance {
  return distance_;
}

- (Instruction *)setDistanceWithDouble:(jdouble)distance {
  self->distance_ = distance;
  return self;
}

- (jlong)getTime {
  return time_;
}

- (Instruction *)setTimeWithLong:(jlong)time {
  self->time_ = time;
  return self;
}

- (jdouble)getFirstLat {
  return [((PointList *) nil_chk(points_)) getLatitudeWithInt:0];
}

- (jdouble)getFirstLon {
  return [((PointList *) nil_chk(points_)) getLongitudeWithInt:0];
}

- (jdouble)getFirstEle {
  return [((PointList *) nil_chk(points_)) getElevationWithInt:0];
}

- (PointList *)getPoints {
  return points_;
}

- (jlong)fillGPXListWithJavaUtilList:(id<JavaUtilList>)list
                            withLong:(jlong)time
                     withInstruction:(Instruction *)prevInstr
                     withInstruction:(Instruction *)nextInstr
                         withBoolean:(jboolean)firstInstr {
  [self checkOne];
  jint len = [((PointList *) nil_chk(points_)) size];
  jlong prevTime = time;
  jdouble lat = [points_ getLatitudeWithInt:0];
  jdouble lon = [points_ getLongitudeWithInt:0];
  jdouble ele = JavaLangDouble_NaN;
  jboolean is3D = [points_ is3D];
  if (is3D) ele = [points_ getElevationWithInt:0];
  for (jint i = 0; i < len; i++) {
    [((id<JavaUtilList>) nil_chk(list)) addWithId:[[[GPXEntry alloc] initWithDouble:lat withDouble:lon withDouble:ele withLong:prevTime] autorelease]];
    jboolean last = i + 1 == len;
    jdouble nextLat = last ? [((Instruction *) nil_chk(nextInstr)) getFirstLat] : [points_ getLatitudeWithInt:i + 1];
    jdouble nextLon = last ? [((Instruction *) nil_chk(nextInstr)) getFirstLon] : [points_ getLongitudeWithInt:i + 1];
    jdouble nextEle = is3D ? (last ? [((Instruction *) nil_chk(nextInstr)) getFirstEle] : [points_ getElevationWithInt:i + 1]) : JavaLangDouble_NaN;
    if (is3D) prevTime = JavaLangMath_roundWithDouble_(prevTime + self->time_ * [((DistanceCalc3D *) nil_chk(Helper_get_DIST_3D_())) calcDistWithDouble:nextLat withDouble:nextLon withDouble:nextEle withDouble:lat withDouble:lon withDouble:ele] / distance_);
    else prevTime = JavaLangMath_roundWithDouble_(prevTime + self->time_ * [((DistanceCalc3D *) nil_chk(Helper_get_DIST_3D_())) calcDistWithDouble:nextLat withDouble:nextLon withDouble:lat withDouble:lon] / distance_);
    lat = nextLat;
    lon = nextLon;
    ele = nextEle;
  }
  return time + self->time_;
}

- (NSString *)description {
  JavaLangStringBuilder *sb = [[[JavaLangStringBuilder alloc] init] autorelease];
  [sb appendWithChar:'('];
  [((JavaLangStringBuilder *) nil_chk([sb appendWithInt:sign_])) appendWithChar:','];
  [((JavaLangStringBuilder *) nil_chk([sb appendWithNSString:name_])) appendWithChar:','];
  [((JavaLangStringBuilder *) nil_chk([sb appendWithDouble:distance_])) appendWithChar:','];
  [sb appendWithLong:time_];
  [sb appendWithChar:')'];
  return [sb description];
}

- (NSString *)calcDirectionWithInstruction:(Instruction *)nextI {
  jdouble azimuth = [self calcAzimuthWithInstruction:nextI];
  if (JavaLangDouble_isNaNWithDouble_(azimuth)) return @"";
  return [((AngleCalc *) nil_chk(Instruction_AC_)) azimuth2compassPointWithDouble:azimuth];
}

- (jdouble)calcAzimuthWithInstruction:(Instruction *)nextI {
  jdouble nextLat;
  jdouble nextLon;
  if ([((PointList *) nil_chk(points_)) getSize] >= 2) {
    nextLat = [points_ getLatitudeWithInt:1];
    nextLon = [points_ getLongitudeWithInt:1];
  }
  else if (nextI != nil && [points_ getSize] == 1) {
    nextLat = [nextI->points_ getLatitudeWithInt:0];
    nextLon = [nextI->points_ getLongitudeWithInt:0];
  }
  else {
    return JavaLangDouble_NaN;
  }
  jdouble lat = [points_ getLatitudeWithInt:0];
  jdouble lon = [points_ getLongitudeWithInt:0];
  return [((AngleCalc *) nil_chk(Instruction_AC_)) calcAzimuthWithDouble:lat withDouble:lon withDouble:nextLat withDouble:nextLon];
}

- (void)checkOne {
  if ([((PointList *) nil_chk(points_)) size] < 1) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$$", @"Instruction must contain at least one point ", [self description])] autorelease];
}

- (NSString *)getTurnDescriptionWithTranslation:(id<Translation>)tr {
  if (rawName_) return [self getName];
  NSString *str;
  NSString *streetName = [self getName];
  jint indi = [self getSign];
  if (indi == Instruction_CONTINUE_ON_STREET) {
    str = Helper_isEmptyWithNSString_(streetName) ? [((id<Translation>) nil_chk(tr)) trWithNSString:@"continue" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:NSObject_class_()]] : [((id<Translation>) nil_chk(tr)) trWithNSString:@"continue_onto" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ streetName } count:1 type:NSObject_class_()]];
  }
  else {
    NSString *dir = nil;
    switch (indi) {
      case Instruction_TURN_SHARP_LEFT:
      dir = [((id<Translation>) nil_chk(tr)) trWithNSString:@"turn_sharp_left" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:NSObject_class_()]];
      break;
      case Instruction_TURN_LEFT:
      dir = [((id<Translation>) nil_chk(tr)) trWithNSString:@"turn_left" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:NSObject_class_()]];
      break;
      case Instruction_TURN_SLIGHT_LEFT:
      dir = [((id<Translation>) nil_chk(tr)) trWithNSString:@"turn_slight_left" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:NSObject_class_()]];
      break;
      case Instruction_TURN_SLIGHT_RIGHT:
      dir = [((id<Translation>) nil_chk(tr)) trWithNSString:@"turn_slight_right" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:NSObject_class_()]];
      break;
      case Instruction_TURN_RIGHT:
      dir = [((id<Translation>) nil_chk(tr)) trWithNSString:@"turn_right" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:NSObject_class_()]];
      break;
      case Instruction_TURN_SHARP_RIGHT:
      dir = [((id<Translation>) nil_chk(tr)) trWithNSString:@"turn_sharp_right" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:NSObject_class_()]];
      break;
    }
    if (dir == nil) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I", @"Turn indication not found ", indi)] autorelease];
    str = Helper_isEmptyWithNSString_(streetName) ? dir : [((id<Translation>) nil_chk(tr)) trWithNSString:@"turn_onto" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ dir, streetName } count:2 type:NSObject_class_()]];
  }
  return str;
}

- (void)dealloc {
  RELEASE_(points_);
  RELEASE_(annotation_);
  RELEASE_(name_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(Instruction *)other {
  [super copyAllFieldsTo:other];
  Instruction_set_points_(other, points_);
  Instruction_set_annotation_(other, annotation_);
  other->rawName_ = rawName_;
  other->sign_ = sign_;
  Instruction_set_name_(other, name_);
  other->distance_ = distance_;
  other->time_ = time_;
}

+ (void)initialize {
  if (self == [Instruction class]) {
    JreStrongAssign(&Instruction_AC_, nil, Helper_get_ANGLE_CALC_());
    J2OBJC_SET_INITIALIZED(Instruction)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithInt:withNSString:withInstructionAnnotation:withPointList:", "Instruction", NULL, 0x1, NULL },
    { "setUseRawName", NULL, "V", 0x1, NULL },
    { "getAnnotation", NULL, "Lcom.graphhopper.util.InstructionAnnotation;", 0x1, NULL },
    { "getSign", NULL, "I", 0x1, NULL },
    { "getName", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "setNameWithNSString:", "setName", "V", 0x1, NULL },
    { "getExtraInfoJSON", NULL, "Ljava.util.Map;", 0x1, NULL },
    { "setExtraInfoWithNSString:withId:", "setExtraInfo", "V", 0x1, NULL },
    { "getDistance", NULL, "D", 0x1, NULL },
    { "setDistanceWithDouble:", "setDistance", "Lcom.graphhopper.util.Instruction;", 0x1, NULL },
    { "getTime", NULL, "J", 0x1, NULL },
    { "setTimeWithLong:", "setTime", "Lcom.graphhopper.util.Instruction;", 0x1, NULL },
    { "getFirstLat", NULL, "D", 0x0, NULL },
    { "getFirstLon", NULL, "D", 0x0, NULL },
    { "getFirstEle", NULL, "D", 0x0, NULL },
    { "getPoints", NULL, "Lcom.graphhopper.util.PointList;", 0x1, NULL },
    { "fillGPXListWithJavaUtilList:withLong:withInstruction:withInstruction:withBoolean:", "fillGPXList", "J", 0x0, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "calcDirectionWithInstruction:", "calcDirection", "Ljava.lang.String;", 0x0, NULL },
    { "calcAzimuthWithInstruction:", "calcAzimuth", "D", 0x1, NULL },
    { "checkOne", NULL, "V", 0x0, NULL },
    { "getTurnDescriptionWithTranslation:", "getTurnDescription", "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "LEAVE_ROUNDABOUT_", NULL, 0x19, "I", NULL, .constantValue.asInt = Instruction_LEAVE_ROUNDABOUT },
    { "TURN_SHARP_LEFT_", NULL, 0x19, "I", NULL, .constantValue.asInt = Instruction_TURN_SHARP_LEFT },
    { "TURN_LEFT_", NULL, 0x19, "I", NULL, .constantValue.asInt = Instruction_TURN_LEFT },
    { "TURN_SLIGHT_LEFT_", NULL, 0x19, "I", NULL, .constantValue.asInt = Instruction_TURN_SLIGHT_LEFT },
    { "CONTINUE_ON_STREET_", NULL, 0x19, "I", NULL, .constantValue.asInt = Instruction_CONTINUE_ON_STREET },
    { "TURN_SLIGHT_RIGHT_", NULL, 0x19, "I", NULL, .constantValue.asInt = Instruction_TURN_SLIGHT_RIGHT },
    { "TURN_RIGHT_", NULL, 0x19, "I", NULL, .constantValue.asInt = Instruction_TURN_RIGHT },
    { "TURN_SHARP_RIGHT_", NULL, 0x19, "I", NULL, .constantValue.asInt = Instruction_TURN_SHARP_RIGHT },
    { "FINISH_", NULL, 0x19, "I", NULL, .constantValue.asInt = Instruction_FINISH },
    { "REACHED_VIA_", NULL, 0x19, "I", NULL, .constantValue.asInt = Instruction_REACHED_VIA },
    { "USE_ROUNDABOUT_", NULL, 0x19, "I", NULL, .constantValue.asInt = Instruction_USE_ROUNDABOUT },
    { "AC_", NULL, 0x1a, "Lcom.graphhopper.util.AngleCalc;", &Instruction_AC_,  },
    { "points_", NULL, 0x14, "Lcom.graphhopper.util.PointList;", NULL,  },
    { "annotation_", NULL, 0x14, "Lcom.graphhopper.util.InstructionAnnotation;", NULL,  },
    { "rawName_", NULL, 0x4, "Z", NULL,  },
    { "sign_", NULL, 0x4, "I", NULL,  },
    { "name_", NULL, 0x4, "Ljava.lang.String;", NULL,  },
    { "distance_", NULL, 0x4, "D", NULL,  },
    { "time_", NULL, 0x4, "J", NULL,  },
  };
  static const J2ObjcClassInfo _Instruction = { 1, "Instruction", "com.graphhopper.util", NULL, 0x1, 22, methods, 19, fields, 0, NULL};
  return &_Instruction;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(Instruction)
