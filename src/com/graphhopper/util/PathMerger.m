//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/util/PathMerger.java
//

#include "IOSClass.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/PathWrapper.h"
#include "com/graphhopper/routing/Path.h"
#include "com/graphhopper/util/DouglasPeucker.h"
#include "com/graphhopper/util/Instruction.h"
#include "com/graphhopper/util/InstructionList.h"
#include "com/graphhopper/util/PathMerger.h"
#include "com/graphhopper/util/PointList.h"
#include "com/graphhopper/util/Translation.h"
#include "com/graphhopper/util/ViaInstruction.h"
#include "com/graphhopper/util/exceptions/ConnectionNotFoundException.h"
#include "java/lang/Math.h"
#include "java/util/ArrayList.h"
#include "java/util/Collections.h"
#include "java/util/List.h"
#include "java/util/Map.h"

__attribute__((unused)) static void PathMerger_calcAscendDescendWithPathWrapper_withPointList_(PathMerger *self, PathWrapper *rsp, PointList *pointList);

@interface PathMerger () {
 @public
  jboolean enableInstructions_;
  jboolean simplifyResponse_;
  DouglasPeucker *douglasPeucker_;
  jboolean calcPoints_;
}

- (void)calcAscendDescendWithPathWrapper:(PathWrapper *)rsp
                           withPointList:(PointList *)pointList;
@end

J2OBJC_FIELD_SETTER(PathMerger, douglasPeucker_, DouglasPeucker *)

BOOL PathMerger_initialized = NO;

@implementation PathMerger

DouglasPeucker * PathMerger_DP_;

- (PathMerger *)setCalcPointsWithBoolean:(jboolean)calcPoints {
  self->calcPoints_ = calcPoints;
  return self;
}

- (PathMerger *)setDouglasPeuckerWithDouglasPeucker:(DouglasPeucker *)douglasPeucker {
  PathMerger_set_douglasPeucker_(self, douglasPeucker);
  return self;
}

- (PathMerger *)setSimplifyResponseWithBoolean:(jboolean)simplifyRes {
  self->simplifyResponse_ = simplifyRes;
  return self;
}

- (PathMerger *)setEnableInstructionsWithBoolean:(jboolean)enableInstructions {
  self->enableInstructions_ = enableInstructions;
  return self;
}

- (void)doWorkWithPathWrapper:(PathWrapper *)altRsp
             withJavaUtilList:(id<JavaUtilList>)paths
              withTranslation:(id<Translation>)tr {
  jint origPoints = 0;
  jlong fullTimeInMillis = 0;
  jdouble fullWeight = 0;
  jdouble fullDistance = 0;
  jboolean allFound = YES;
  InstructionList *fullInstructions = [[[InstructionList alloc] initWithTranslation:tr] autorelease];
  PointList *fullPoints = PointList_get_EMPTY_();
  id<JavaUtilList> description_ = [[[JavaUtilArrayList alloc] init] autorelease];
  for (jint pathIndex = 0; pathIndex < [((id<JavaUtilList>) nil_chk(paths)) size]; pathIndex++) {
    Path *path = [paths getWithInt:pathIndex];
    [description_ addAllWithJavaUtilCollection:[((Path *) nil_chk(path)) getDescription]];
    fullTimeInMillis += [path getTime];
    fullDistance += [path getDistance];
    fullWeight += [path getWeight];
    if (enableInstructions_) {
      InstructionList *il = [path calcInstructionsWithTranslation:tr];
      if (![((InstructionList *) nil_chk(il)) isEmpty]) {
        if ([((PointList *) nil_chk(fullPoints)) isEmpty]) {
          PointList *pl = [((Instruction *) nil_chk([il getWithInt:0])) getPoints];
          fullPoints = [[[PointList alloc] initWithInt:[il size] * JavaLangMath_minWithInt_withInt_(10, [((PointList *) nil_chk(pl)) size]) withBoolean:[pl is3D]] autorelease];
        }
        for (Instruction * __strong i in il) {
          if (simplifyResponse_) {
            origPoints += [((PointList *) nil_chk([((Instruction *) nil_chk(i)) getPoints])) size];
            [((DouglasPeucker *) nil_chk(douglasPeucker_)) simplifyWithPointList:[i getPoints]];
          }
          [fullInstructions addWithInstruction:i];
          [fullPoints addWithPointList:[((Instruction *) nil_chk(i)) getPoints]];
        }
        if (pathIndex + 1 < [paths size]) {
          ViaInstruction *newInstr = [[[ViaInstruction alloc] initWithInstruction:[fullInstructions getWithInt:[fullInstructions size] - 1]] autorelease];
          [newInstr setViaCountWithInt:pathIndex + 1];
          [fullInstructions replaceLastWithInstruction:newInstr];
        }
      }
    }
    else if (calcPoints_) {
      PointList *tmpPoints = [path calcPoints];
      if ([((PointList *) nil_chk(fullPoints)) isEmpty]) fullPoints = [[[PointList alloc] initWithInt:[((PointList *) nil_chk(tmpPoints)) size] withBoolean:[tmpPoints is3D]] autorelease];
      if (simplifyResponse_) {
        origPoints = [((PointList *) nil_chk(tmpPoints)) getSize];
        [((DouglasPeucker *) nil_chk(douglasPeucker_)) simplifyWithPointList:tmpPoints];
      }
      [fullPoints addWithPointList:tmpPoints];
    }
    allFound = (allFound && [path isFound]);
  }
  if (![((PointList *) nil_chk(fullPoints)) isEmpty]) {
    NSString *debug = JreStrcat("$$I$IC", [((PathWrapper *) nil_chk(altRsp)) getDebugInfo], @", simplify (", origPoints, @"->", [fullPoints getSize], ')');
    [altRsp addDebugInfoWithNSString:debug];
    if (fullPoints->is3D__) PathMerger_calcAscendDescendWithPathWrapper_withPointList_(self, altRsp, fullPoints);
  }
  if (enableInstructions_) [((PathWrapper *) nil_chk(altRsp)) setInstructionsWithInstructionList:fullInstructions];
  if (!allFound) [((PathWrapper *) nil_chk(altRsp)) addErrorWithJavaLangThrowable:[[[ComGraphhopperUtilExceptionsConnectionNotFoundException alloc] initWithNSString:@"Connection between locations not found" withJavaUtilMap:JavaUtilCollections_emptyMap()] autorelease]];
  [((PathWrapper *) nil_chk([((PathWrapper *) nil_chk([((PathWrapper *) nil_chk([((PathWrapper *) nil_chk([((PathWrapper *) nil_chk(altRsp)) setDescriptionWithJavaUtilList:description_])) setPointsWithPointList:fullPoints])) setRouteWeightWithDouble:fullWeight])) setDistanceWithDouble:fullDistance])) setTimeWithLong:fullTimeInMillis];
}

- (void)calcAscendDescendWithPathWrapper:(PathWrapper *)rsp
                           withPointList:(PointList *)pointList {
  PathMerger_calcAscendDescendWithPathWrapper_withPointList_(self, rsp, pointList);
}

- (instancetype)init {
  if (self = [super init]) {
    enableInstructions_ = YES;
    simplifyResponse_ = YES;
    PathMerger_set_douglasPeucker_(self, PathMerger_DP_);
    calcPoints_ = YES;
  }
  return self;
}

- (void)dealloc {
  RELEASE_(douglasPeucker_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(PathMerger *)other {
  [super copyAllFieldsTo:other];
  other->enableInstructions_ = enableInstructions_;
  other->simplifyResponse_ = simplifyResponse_;
  PathMerger_set_douglasPeucker_(other, douglasPeucker_);
  other->calcPoints_ = calcPoints_;
}

+ (void)initialize {
  if (self == [PathMerger class]) {
    JreStrongAssignAndConsume(&PathMerger_DP_, nil, [[DouglasPeucker alloc] init]);
    J2OBJC_SET_INITIALIZED(PathMerger)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "setCalcPointsWithBoolean:", "setCalcPoints", "Lcom.graphhopper.util.PathMerger;", 0x1, NULL },
    { "setDouglasPeuckerWithDouglasPeucker:", "setDouglasPeucker", "Lcom.graphhopper.util.PathMerger;", 0x1, NULL },
    { "setSimplifyResponseWithBoolean:", "setSimplifyResponse", "Lcom.graphhopper.util.PathMerger;", 0x1, NULL },
    { "setEnableInstructionsWithBoolean:", "setEnableInstructions", "Lcom.graphhopper.util.PathMerger;", 0x1, NULL },
    { "doWorkWithPathWrapper:withJavaUtilList:withTranslation:", "doWork", "V", 0x1, NULL },
    { "calcAscendDescendWithPathWrapper:withPointList:", "calcAscendDescend", "V", 0x2, NULL },
    { "init", NULL, NULL, 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "DP_", NULL, 0x1a, "Lcom.graphhopper.util.DouglasPeucker;", &PathMerger_DP_,  },
    { "enableInstructions_", NULL, 0x2, "Z", NULL,  },
    { "simplifyResponse_", NULL, 0x2, "Z", NULL,  },
    { "douglasPeucker_", NULL, 0x2, "Lcom.graphhopper.util.DouglasPeucker;", NULL,  },
    { "calcPoints_", NULL, 0x2, "Z", NULL,  },
  };
  static const J2ObjcClassInfo _PathMerger = { 1, "PathMerger", "com.graphhopper.util", NULL, 0x1, 7, methods, 5, fields, 0, NULL};
  return &_PathMerger;
}

@end

void PathMerger_calcAscendDescendWithPathWrapper_withPointList_(PathMerger *self, PathWrapper *rsp, PointList *pointList) {
  jdouble ascendMeters = 0;
  jdouble descendMeters = 0;
  jdouble lastEle = [((PointList *) nil_chk(pointList)) getElevationWithInt:0];
  for (jint i = 1; i < [pointList size]; ++i) {
    jdouble ele = [pointList getElevationWithInt:i];
    jdouble diff = JavaLangMath_absWithDouble_(ele - lastEle);
    if (ele > lastEle) ascendMeters += diff;
    else descendMeters += diff;
    lastEle = ele;
  }
  [((PathWrapper *) nil_chk(rsp)) setAscendWithDouble:ascendMeters];
  [rsp setDescendWithDouble:descendMeters];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(PathMerger)
