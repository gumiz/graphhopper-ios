//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/util/Unzipper.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/ProgressListener.h"
#include "com/graphhopper/util/Unzipper.h"
#include "java/io/File.h"
#include "java/io/FileInputStream.h"
#include "java/io/FileOutputStream.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/util/zip/ZipEntry.h"
#include "java/util/zip/ZipInputStream.h"

@implementation Unzipper

- (void)unzipWithNSString:(NSString *)from
              withBoolean:(jboolean)remove {
  NSString *to = Helper_pruneFileEndWithNSString_(from);
  [self unzipWithNSString:from withNSString:to withBoolean:remove];
}

- (jboolean)unzipWithNSString:(NSString *)fromStr
                 withNSString:(NSString *)toStr
                  withBoolean:(jboolean)remove {
  JavaIoFile *from = [[[JavaIoFile alloc] initWithNSString:fromStr] autorelease];
  if (![from exists] || [((NSString *) nil_chk(fromStr)) isEqual:toStr]) return NO;
  [self unzipWithJavaIoInputStream:[[[JavaIoFileInputStream alloc] initWithJavaIoFile:from] autorelease] withJavaIoFile:[[[JavaIoFile alloc] initWithNSString:toStr] autorelease] withProgressListener:nil];
  if (remove) Helper_removeDirWithJavaIoFile_(from);
  return YES;
}

- (void)unzipWithJavaIoInputStream:(JavaIoInputStream *)fromIs
                    withJavaIoFile:(JavaIoFile *)toFolder
              withProgressListener:(id<ProgressListener>)progressListener {
  if (![((JavaIoFile *) nil_chk(toFolder)) exists]) [toFolder mkdirs];
  jlong sumBytes = 0;
  JavaUtilZipZipInputStream *zis = [[[JavaUtilZipZipInputStream alloc] initWithJavaIoInputStream:fromIs] autorelease];
  @try {
    JavaUtilZipZipEntry *ze = [zis getNextEntry];
    IOSByteArray *buffer = [IOSByteArray arrayWithLength:8 * 1024];
    while (ze != nil) {
      if ([((JavaUtilZipZipEntry *) nil_chk(ze)) isDirectory]) {
        [((JavaIoFile *) [[[JavaIoFile alloc] initWithJavaIoFile:toFolder withNSString:[ze getName]] autorelease]) mkdir];
      }
      else {
        jdouble factor = 1;
        if ([ze getCompressedSize] > 0 && [ze getSize] > 0) factor = (jdouble) [ze getCompressedSize] / [ze getSize];
        JavaIoFile *newFile = [[[JavaIoFile alloc] initWithJavaIoFile:toFolder withNSString:[ze getName]] autorelease];
        JavaIoFileOutputStream *fos = [[[JavaIoFileOutputStream alloc] initWithJavaIoFile:newFile] autorelease];
        @try {
          jint len;
          while ((len = [zis readWithByteArray:buffer]) > 0) {
            [fos writeWithByteArray:buffer withInt:0 withInt:len];
            sumBytes += len * factor;
            if (progressListener != nil) [progressListener updateWithLong:sumBytes];
          }
        }
        @finally {
          [fos close];
        }
      }
      ze = [zis getNextEntry];
    }
    [zis closeEntry];
  }
  @finally {
    [zis close];
  }
}

- (instancetype)init {
  return [super init];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "unzipWithNSString:withBoolean:", "unzip", "V", 0x1, "Ljava.io.IOException;" },
    { "unzipWithNSString:withNSString:withBoolean:", "unzip", "Z", 0x1, "Ljava.io.IOException;" },
    { "unzipWithJavaIoInputStream:withJavaIoFile:withProgressListener:", "unzip", "V", 0x1, "Ljava.io.IOException;" },
    { "init", NULL, NULL, 0x1, NULL },
  };
  static const J2ObjcClassInfo _Unzipper = { 1, "Unzipper", "com.graphhopper.util", NULL, 0x1, 4, methods, 0, NULL, 0, NULL};
  return &_Unzipper;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(Unzipper)
