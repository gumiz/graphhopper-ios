//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/util/PMap.java
//

#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/PMap.h"
#include "java/lang/Boolean.h"
#include "java/lang/Double.h"
#include "java/lang/Exception.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/NullPointerException.h"
#include "java/util/HashMap.h"
#include "java/util/Map.h"
#include "java/util/Set.h"

__attribute__((unused)) static id<JavaUtilMap> PMap_getMap(PMap *self);

@interface PMap () {
 @public
  id<JavaUtilMap> map_;
}

- (id<JavaUtilMap>)getMap;
@end

J2OBJC_FIELD_SETTER(PMap, map_, id<JavaUtilMap>)

@implementation PMap

- (instancetype)init {
  return [self initPMapWithInt:5];
}

- (instancetype)initPMapWithInt:(jint)capacity {
  return [self initPMapWithJavaUtilMap:[[[JavaUtilHashMap alloc] initWithInt:capacity] autorelease]];
}

- (instancetype)initWithInt:(jint)capacity {
  return [self initPMapWithInt:capacity];
}

- (instancetype)initPMapWithJavaUtilMap:(id<JavaUtilMap>)map {
  if (self = [super init]) {
    PMap_set_map_(self, map);
  }
  return self;
}

- (instancetype)initWithJavaUtilMap:(id<JavaUtilMap>)map {
  return [self initPMapWithJavaUtilMap:map];
}

- (instancetype)initWithNSString:(NSString *)propertiesString {
  if (self = [super init]) {
    PMap_setAndConsume_map_(self, [[JavaUtilHashMap alloc] initWithInt:5]);
    {
      IOSObjectArray *a__ = [((NSString *) nil_chk(propertiesString)) split:@"\\|"];
      NSString * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
      NSString * const *e__ = b__ + a__->size_;
      while (b__ < e__) {
        NSString *s = *b__++;
        s = [((NSString *) nil_chk(s)) trim];
        jint index = [((NSString *) nil_chk(s)) indexOfString:@"="];
        if (index < 0) continue;
        [self putWithNSString:[s substring:0 endIndex:index] withId:[s substring:index + 1]];
      }
    }
  }
  return self;
}

- (PMap *)putWithPMap:(PMap *)map {
  [((id<JavaUtilMap>) nil_chk(self->map_)) putAllWithJavaUtilMap:((PMap *) nil_chk(map))->map_];
  return self;
}

- (PMap *)putWithNSString:(NSString *)key
                   withId:(id)str {
  if (str == nil) @throw [[[JavaLangNullPointerException alloc] initWithNSString:@"Value cannot be null. Use remove instead."] autorelease];
  [((id<JavaUtilMap>) nil_chk(map_)) putWithId:Helper_camelCaseToUnderScoreWithNSString_(key) withId:[nil_chk(str) description]];
  return self;
}

- (PMap *)removeWithNSString:(NSString *)key {
  [((id<JavaUtilMap>) nil_chk(map_)) removeWithId:Helper_camelCaseToUnderScoreWithNSString_(key)];
  return self;
}

- (jboolean)hasWithNSString:(NSString *)key {
  return [((id<JavaUtilMap>) nil_chk(map_)) containsKeyWithId:Helper_camelCaseToUnderScoreWithNSString_(key)];
}

- (jlong)getLongWithNSString:(NSString *)key
                    withLong:(jlong)_default {
  NSString *str = [self getWithNSString:key];
  if (!Helper_isEmptyWithNSString_(str)) {
    @try {
      return JavaLangLong_parseLongWithNSString_(str);
    }
    @catch (JavaLangException *ex) {
    }
  }
  return _default;
}

- (jint)getIntWithNSString:(NSString *)key
                   withInt:(jint)_default {
  NSString *str = [self getWithNSString:key];
  if (!Helper_isEmptyWithNSString_(str)) {
    @try {
      return JavaLangInteger_parseIntWithNSString_(str);
    }
    @catch (JavaLangException *ex) {
    }
  }
  return _default;
}

- (jboolean)getBoolWithNSString:(NSString *)key
                    withBoolean:(jboolean)_default {
  NSString *str = [self getWithNSString:key];
  if (!Helper_isEmptyWithNSString_(str)) {
    @try {
      return JavaLangBoolean_parseBooleanWithNSString_(str);
    }
    @catch (JavaLangException *ex) {
    }
  }
  return _default;
}

- (jdouble)getDoubleWithNSString:(NSString *)key
                      withDouble:(jdouble)_default {
  NSString *str = [self getWithNSString:key];
  if (!Helper_isEmptyWithNSString_(str)) {
    @try {
      return JavaLangDouble_parseDoubleWithNSString_(str);
    }
    @catch (JavaLangException *ex) {
    }
  }
  return _default;
}

- (NSString *)getWithNSString:(NSString *)key
                 withNSString:(NSString *)_default {
  NSString *str = [self getWithNSString:key];
  if (Helper_isEmptyWithNSString_(str)) return _default;
  return str;
}

- (NSString *)getWithNSString:(NSString *)key {
  if (Helper_isEmptyWithNSString_(key)) return @"";
  NSString *val = [((id<JavaUtilMap>) nil_chk(map_)) getWithId:Helper_camelCaseToUnderScoreWithNSString_(key)];
  if (val == nil) return @"";
  return val;
}

- (id<JavaUtilMap>)toMap {
  return [[[JavaUtilHashMap alloc] initWithJavaUtilMap:map_] autorelease];
}

- (id<JavaUtilMap>)getMap {
  return PMap_getMap(self);
}

- (PMap *)mergeWithPMap:(PMap *)read {
  return [self mergeWithJavaUtilMap:PMap_getMap(nil_chk(read))];
}

- (PMap *)mergeWithJavaUtilMap:(id<JavaUtilMap>)map {
  for (id<JavaUtilMap_Entry> __strong e in nil_chk([((id<JavaUtilMap>) nil_chk(map)) entrySet])) {
    if (Helper_isEmptyWithNSString_([((id<JavaUtilMap_Entry>) nil_chk(e)) getKey])) continue;
    [self putWithNSString:[e getKey] withId:[e getValue]];
  }
  return self;
}

- (jboolean)isEmpty {
  return [((id<JavaUtilMap>) nil_chk(map_)) isEmpty];
}

- (NSString *)description {
  return [((id<JavaUtilMap>) nil_chk(PMap_getMap(self))) description];
}

- (void)dealloc {
  RELEASE_(map_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(PMap *)other {
  [super copyAllFieldsTo:other];
  PMap_set_map_(other, map_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "PMap", NULL, 0x1, NULL },
    { "initWithInt:", "PMap", NULL, 0x1, NULL },
    { "initWithJavaUtilMap:", "PMap", NULL, 0x1, NULL },
    { "initWithNSString:", "PMap", NULL, 0x1, NULL },
    { "putWithPMap:", "put", "Lcom.graphhopper.util.PMap;", 0x1, NULL },
    { "putWithNSString:withId:", "put", "Lcom.graphhopper.util.PMap;", 0x1, NULL },
    { "removeWithNSString:", "remove", "Lcom.graphhopper.util.PMap;", 0x1, NULL },
    { "hasWithNSString:", "has", "Z", 0x1, NULL },
    { "getLongWithNSString:withLong:", "getLong", "J", 0x1, NULL },
    { "getIntWithNSString:withInt:", "getInt", "I", 0x1, NULL },
    { "getBoolWithNSString:withBoolean:", "getBool", "Z", 0x1, NULL },
    { "getDoubleWithNSString:withDouble:", "getDouble", "D", 0x1, NULL },
    { "getWithNSString:withNSString:", "get", "Ljava.lang.String;", 0x1, NULL },
    { "getWithNSString:", "get", "Ljava.lang.String;", 0x0, NULL },
    { "toMap", NULL, "Ljava.util.Map;", 0x1, NULL },
    { "getMap", NULL, "Ljava.util.Map;", 0x2, NULL },
    { "mergeWithPMap:", "merge", "Lcom.graphhopper.util.PMap;", 0x1, NULL },
    { "mergeWithJavaUtilMap:", "merge", "Lcom.graphhopper.util.PMap;", 0x0, NULL },
    { "isEmpty", NULL, "Z", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "map_", NULL, 0x12, "Ljava.util.Map;", NULL,  },
  };
  static const J2ObjcClassInfo _PMap = { 1, "PMap", "com.graphhopper.util", NULL, 0x1, 20, methods, 1, fields, 0, NULL};
  return &_PMap;
}

@end

id<JavaUtilMap> PMap_getMap(PMap *self) {
  return self->map_;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(PMap)
