//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/util/shapes/Circle.java
//

#include "J2ObjC_source.h"
#include "com/graphhopper/util/DistanceCalc.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/shapes/BBox.h"
#include "com/graphhopper/util/shapes/Circle.h"
#include "com/graphhopper/util/shapes/Shape.h"
#include "java/lang/UnsupportedOperationException.h"

__attribute__((unused)) static jdouble Circle_normDistWithDouble_withDouble_(Circle *self, jdouble lat1, jdouble lon1);

@interface Circle () {
 @public
  jdouble radiusInKm_;
  jdouble lat_;
  jdouble lon_;
  jdouble normedDist_;
  BBox *bbox_;
  id<DistanceCalc> calc_;
}

- (jdouble)normDistWithDouble:(jdouble)lat1
                   withDouble:(jdouble)lon1;
@end

J2OBJC_FIELD_SETTER(Circle, bbox_, BBox *)
J2OBJC_FIELD_SETTER(Circle, calc_, id<DistanceCalc>)

@implementation Circle

- (instancetype)initWithDouble:(jdouble)lat
                    withDouble:(jdouble)lon
                    withDouble:(jdouble)radiusInMeter {
  return [self initCircleWithDouble:lat withDouble:lon withDouble:radiusInMeter withDistanceCalc:Helper_get_DIST_EARTH_()];
}

- (instancetype)initCircleWithDouble:(jdouble)lat
                          withDouble:(jdouble)lon
                          withDouble:(jdouble)radiusInMeter
                    withDistanceCalc:(id<DistanceCalc>)calc {
  if (self = [super init]) {
    Circle_set_calc_(self, Helper_get_DIST_EARTH_());
    Circle_set_calc_(self, calc);
    self->lat_ = lat;
    self->lon_ = lon;
    self->radiusInKm_ = radiusInMeter;
    self->normedDist_ = [((id<DistanceCalc>) nil_chk(calc)) calcNormalizedDistWithDouble:radiusInMeter];
    Circle_set_bbox_(self, [calc createBBoxWithDouble:lat withDouble:lon withDouble:radiusInMeter]);
  }
  return self;
}

- (instancetype)initWithDouble:(jdouble)lat
                    withDouble:(jdouble)lon
                    withDouble:(jdouble)radiusInMeter
              withDistanceCalc:(id<DistanceCalc>)calc {
  return [self initCircleWithDouble:lat withDouble:lon withDouble:radiusInMeter withDistanceCalc:calc];
}

- (jdouble)getLat {
  return lat_;
}

- (jdouble)getLon {
  return lon_;
}

- (jboolean)containsWithDouble:(jdouble)lat1
                    withDouble:(jdouble)lon1 {
  return Circle_normDistWithDouble_withDouble_(self, lat1, lon1) <= normedDist_;
}

- (BBox *)getBounds {
  return bbox_;
}

- (jdouble)normDistWithDouble:(jdouble)lat1
                   withDouble:(jdouble)lon1 {
  return Circle_normDistWithDouble_withDouble_(self, lat1, lon1);
}

- (jboolean)intersectWithShape:(id<Shape>)o {
  if ([o isKindOfClass:[Circle class]]) {
    return [self intersectWithCircle:(Circle *) check_class_cast(o, [Circle class])];
  }
  else if ([o isKindOfClass:[BBox class]]) {
    return [self intersectWithBBox:(BBox *) check_class_cast(o, [BBox class])];
  }
  return [((id<Shape>) nil_chk(o)) intersectWithShape:self];
}

- (jboolean)containsWithShape:(id<Shape>)o {
  if ([o isKindOfClass:[Circle class]]) {
    return [self containsWithCircle:(Circle *) check_class_cast(o, [Circle class])];
  }
  else if ([o isKindOfClass:[BBox class]]) {
    return [self containsWithBBox:(BBox *) check_class_cast(o, [BBox class])];
  }
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"unsupported shape"] autorelease];
}

- (jboolean)intersectWithBBox:(BBox *)b {
  if (lat_ > ((BBox *) nil_chk(b))->maxLat_) {
    if (lon_ < b->minLon_) {
      return Circle_normDistWithDouble_withDouble_(self, b->maxLat_, b->minLon_) <= normedDist_;
    }
    if (lon_ > b->maxLon_) {
      return Circle_normDistWithDouble_withDouble_(self, b->maxLat_, b->maxLon_) <= normedDist_;
    }
    return b->maxLat_ - ((BBox *) nil_chk(bbox_))->minLat_ > 0;
  }
  if (lat_ < b->minLat_) {
    if (lon_ < b->minLon_) {
      return Circle_normDistWithDouble_withDouble_(self, b->minLat_, b->minLon_) <= normedDist_;
    }
    if (lon_ > b->maxLon_) {
      return Circle_normDistWithDouble_withDouble_(self, b->minLat_, b->maxLon_) <= normedDist_;
    }
    return ((BBox *) nil_chk(bbox_))->maxLat_ - b->minLat_ > 0;
  }
  if (lon_ < b->minLon_) {
    return ((BBox *) nil_chk(bbox_))->maxLon_ - b->minLon_ > 0;
  }
  if (lon_ > b->maxLon_) {
    return b->maxLon_ - ((BBox *) nil_chk(bbox_))->minLon_ > 0;
  }
  return YES;
}

- (jboolean)intersectWithCircle:(Circle *)c {
  if (![((BBox *) nil_chk([self getBounds])) intersectWithBBox:[((Circle *) nil_chk(c)) getBounds]]) {
    return NO;
  }
  return Circle_normDistWithDouble_withDouble_(self, c->lat_, c->lon_) <= [((id<DistanceCalc>) nil_chk(calc_)) calcNormalizedDistWithDouble:radiusInKm_ + c->radiusInKm_];
}

- (jboolean)containsWithBBox:(BBox *)b {
  if ([((BBox *) nil_chk(bbox_)) containsWithBBox:b]) {
    return [self containsWithDouble:((BBox *) nil_chk(b))->maxLat_ withDouble:b->minLon_] && [self containsWithDouble:b->minLat_ withDouble:b->minLon_] && [self containsWithDouble:b->maxLat_ withDouble:b->maxLon_] && [self containsWithDouble:b->minLat_ withDouble:b->maxLon_];
  }
  return NO;
}

- (jboolean)containsWithCircle:(Circle *)c {
  jdouble res = radiusInKm_ - ((Circle *) nil_chk(c))->radiusInKm_;
  if (res < 0) {
    return NO;
  }
  return [((id<DistanceCalc>) nil_chk(calc_)) calcDistWithDouble:lat_ withDouble:lon_ withDouble:c->lat_ withDouble:c->lon_] <= res;
}

- (NSString *)description {
  return JreStrcat("DCD$D", lat_, ',', lon_, @", radius:", radiusInKm_);
}

- (void)dealloc {
  RELEASE_(bbox_);
  RELEASE_(calc_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(Circle *)other {
  [super copyAllFieldsTo:other];
  other->radiusInKm_ = radiusInKm_;
  other->lat_ = lat_;
  other->lon_ = lon_;
  other->normedDist_ = normedDist_;
  Circle_set_bbox_(other, bbox_);
  Circle_set_calc_(other, calc_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithDouble:withDouble:withDouble:", "Circle", NULL, 0x1, NULL },
    { "initWithDouble:withDouble:withDouble:withDistanceCalc:", "Circle", NULL, 0x1, NULL },
    { "getLat", NULL, "D", 0x1, NULL },
    { "getLon", NULL, "D", 0x1, NULL },
    { "containsWithDouble:withDouble:", "contains", "Z", 0x1, NULL },
    { "getBounds", NULL, "Lcom.graphhopper.util.shapes.BBox;", 0x1, NULL },
    { "normDistWithDouble:withDouble:", "normDist", "D", 0x2, NULL },
    { "intersectWithShape:", "intersect", "Z", 0x1, NULL },
    { "containsWithShape:", "contains", "Z", 0x1, NULL },
    { "intersectWithBBox:", "intersect", "Z", 0x1, NULL },
    { "intersectWithCircle:", "intersect", "Z", 0x1, NULL },
    { "containsWithBBox:", "contains", "Z", 0x1, NULL },
    { "containsWithCircle:", "contains", "Z", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "radiusInKm_", NULL, 0x12, "D", NULL,  },
    { "lat_", NULL, 0x12, "D", NULL,  },
    { "lon_", NULL, 0x12, "D", NULL,  },
    { "normedDist_", NULL, 0x12, "D", NULL,  },
    { "bbox_", NULL, 0x12, "Lcom.graphhopper.util.shapes.BBox;", NULL,  },
    { "calc_", NULL, 0x2, "Lcom.graphhopper.util.DistanceCalc;", NULL,  },
  };
  static const J2ObjcClassInfo _Circle = { 1, "Circle", "com.graphhopper.util.shapes", NULL, 0x1, 14, methods, 6, fields, 0, NULL};
  return &_Circle;
}

@end

jdouble Circle_normDistWithDouble_withDouble_(Circle *self, jdouble lat1, jdouble lon1) {
  return [((id<DistanceCalc>) nil_chk(self->calc_)) calcNormalizedDistWithDouble:self->lat_ withDouble:self->lon_ withDouble:lat1 withDouble:lon1];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(Circle)
