//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
//

#include "J2ObjC_source.h"
#include "com/graphhopper/util/DistanceCalcEarth.h"
#include "com/graphhopper/util/shapes/BBox.h"
#include "com/graphhopper/util/shapes/GHPoint.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Math.h"

__attribute__((unused)) static jdouble DistanceCalcEarth_calcShrinkFactorWithDouble_withDouble_(DistanceCalcEarth *self, jdouble a_lat_deg, jdouble b_lat_deg);

@interface DistanceCalcEarth ()

- (jdouble)calcShrinkFactorWithDouble:(jdouble)a_lat_deg
                           withDouble:(jdouble)b_lat_deg;
@end

@implementation DistanceCalcEarth

- (jdouble)calcDistWithDouble:(jdouble)fromLat
                   withDouble:(jdouble)fromLon
                   withDouble:(jdouble)toLat
                   withDouble:(jdouble)toLon {
  jdouble normedDist = [self calcNormalizedDistWithDouble:fromLat withDouble:fromLon withDouble:toLat withDouble:toLon];
  return DistanceCalcEarth_R * 2 * JavaLangMath_asinWithDouble_(JavaLangMath_sqrtWithDouble_(normedDist));
}

- (jdouble)calcDenormalizedDistWithDouble:(jdouble)normedDist {
  return DistanceCalcEarth_R * 2 * JavaLangMath_asinWithDouble_(JavaLangMath_sqrtWithDouble_(normedDist));
}

- (jdouble)calcNormalizedDistWithDouble:(jdouble)dist {
  jdouble tmp = JavaLangMath_sinWithDouble_(dist / 2 / DistanceCalcEarth_R);
  return tmp * tmp;
}

- (jdouble)calcNormalizedDistWithDouble:(jdouble)fromLat
                             withDouble:(jdouble)fromLon
                             withDouble:(jdouble)toLat
                             withDouble:(jdouble)toLon {
  jdouble sinDeltaLat = JavaLangMath_sinWithDouble_(JavaLangMath_toRadiansWithDouble_(toLat - fromLat) / 2);
  jdouble sinDeltaLon = JavaLangMath_sinWithDouble_(JavaLangMath_toRadiansWithDouble_(toLon - fromLon) / 2);
  return sinDeltaLat * sinDeltaLat + sinDeltaLon * sinDeltaLon * JavaLangMath_cosWithDouble_(JavaLangMath_toRadiansWithDouble_(fromLat)) * JavaLangMath_cosWithDouble_(JavaLangMath_toRadiansWithDouble_(toLat));
}

- (jdouble)calcCircumferenceWithDouble:(jdouble)lat {
  return 2 * JavaLangMath_PI * DistanceCalcEarth_R * JavaLangMath_cosWithDouble_(JavaLangMath_toRadiansWithDouble_(lat));
}

- (jboolean)isDateLineCrossOverWithDouble:(jdouble)lon1
                               withDouble:(jdouble)lon2 {
  return JavaLangMath_absWithDouble_(lon1 - lon2) > 180.0;
}

- (BBox *)createBBoxWithDouble:(jdouble)lat
                    withDouble:(jdouble)lon
                    withDouble:(jdouble)radiusInMeter {
  if (radiusInMeter <= 0) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$D$DCD", @"Distance must not be zero or negative! ", radiusInMeter, @" lat,lon:", lat, ',', lon)] autorelease];
  jdouble dLon = (360 / ([self calcCircumferenceWithDouble:lat] / radiusInMeter));
  jdouble dLat = (360 / (DistanceCalcEarth_C / radiusInMeter));
  return [[[BBox alloc] initWithDouble:lon - dLon withDouble:lon + dLon withDouble:lat - dLat withDouble:lat + dLat] autorelease];
}

- (jdouble)calcNormalizedEdgeDistanceWithDouble:(jdouble)r_lat_deg
                                     withDouble:(jdouble)r_lon_deg
                                     withDouble:(jdouble)a_lat_deg
                                     withDouble:(jdouble)a_lon_deg
                                     withDouble:(jdouble)b_lat_deg
                                     withDouble:(jdouble)b_lon_deg {
  return [self calcNormalizedEdgeDistanceNewWithDouble:r_lat_deg withDouble:r_lon_deg withDouble:a_lat_deg withDouble:a_lon_deg withDouble:b_lat_deg withDouble:b_lon_deg withBoolean:NO];
}

- (jdouble)calcNormalizedEdgeDistanceNewWithDouble:(jdouble)r_lat_deg
                                        withDouble:(jdouble)r_lon_deg
                                        withDouble:(jdouble)a_lat_deg
                                        withDouble:(jdouble)a_lon_deg
                                        withDouble:(jdouble)b_lat_deg
                                        withDouble:(jdouble)b_lon_deg
                                       withBoolean:(jboolean)reduceToSegment {
  jdouble shrinkFactor = DistanceCalcEarth_calcShrinkFactorWithDouble_withDouble_(self, a_lat_deg, b_lat_deg);
  jdouble a_lat = a_lat_deg;
  jdouble a_lon = a_lon_deg * shrinkFactor;
  jdouble b_lat = b_lat_deg;
  jdouble b_lon = b_lon_deg * shrinkFactor;
  jdouble r_lat = r_lat_deg;
  jdouble r_lon = r_lon_deg * shrinkFactor;
  jdouble delta_lon = b_lon - a_lon;
  jdouble delta_lat = b_lat - a_lat;
  if (delta_lat == 0) return [self calcNormalizedDistWithDouble:a_lat_deg withDouble:r_lon_deg withDouble:r_lat_deg withDouble:r_lon_deg];
  if (delta_lon == 0) return [self calcNormalizedDistWithDouble:r_lat_deg withDouble:a_lon_deg withDouble:r_lat_deg withDouble:r_lon_deg];
  jdouble norm = delta_lon * delta_lon + delta_lat * delta_lat;
  jdouble factor = ((r_lon - a_lon) * delta_lon + (r_lat - a_lat) * delta_lat) / norm;
  if (reduceToSegment) {
    if (factor > 1) factor = 1;
    else if (factor < 0) factor = 0;
  }
  jdouble c_lon = a_lon + factor * delta_lon;
  jdouble c_lat = a_lat + factor * delta_lat;
  return [self calcNormalizedDistWithDouble:c_lat withDouble:c_lon / shrinkFactor withDouble:r_lat_deg withDouble:r_lon_deg];
}

- (jdouble)calcShrinkFactorWithDouble:(jdouble)a_lat_deg
                           withDouble:(jdouble)b_lat_deg {
  return DistanceCalcEarth_calcShrinkFactorWithDouble_withDouble_(self, a_lat_deg, b_lat_deg);
}

- (GHPoint *)calcCrossingPointToEdgeWithDouble:(jdouble)r_lat_deg
                                    withDouble:(jdouble)r_lon_deg
                                    withDouble:(jdouble)a_lat_deg
                                    withDouble:(jdouble)a_lon_deg
                                    withDouble:(jdouble)b_lat_deg
                                    withDouble:(jdouble)b_lon_deg {
  jdouble shrinkFactor = DistanceCalcEarth_calcShrinkFactorWithDouble_withDouble_(self, a_lat_deg, b_lat_deg);
  jdouble a_lat = a_lat_deg;
  jdouble a_lon = a_lon_deg * shrinkFactor;
  jdouble b_lat = b_lat_deg;
  jdouble b_lon = b_lon_deg * shrinkFactor;
  jdouble r_lat = r_lat_deg;
  jdouble r_lon = r_lon_deg * shrinkFactor;
  jdouble delta_lon = b_lon - a_lon;
  jdouble delta_lat = b_lat - a_lat;
  if (delta_lat == 0) return [[[GHPoint alloc] initWithDouble:a_lat_deg withDouble:r_lon_deg] autorelease];
  if (delta_lon == 0) return [[[GHPoint alloc] initWithDouble:r_lat_deg withDouble:a_lon_deg] autorelease];
  jdouble norm = delta_lon * delta_lon + delta_lat * delta_lat;
  jdouble factor = ((r_lon - a_lon) * delta_lon + (r_lat - a_lat) * delta_lat) / norm;
  jdouble c_lon = a_lon + factor * delta_lon;
  jdouble c_lat = a_lat + factor * delta_lat;
  return [[[GHPoint alloc] initWithDouble:c_lat withDouble:c_lon / shrinkFactor] autorelease];
}

- (jboolean)validEdgeDistanceWithDouble:(jdouble)r_lat_deg
                             withDouble:(jdouble)r_lon_deg
                             withDouble:(jdouble)a_lat_deg
                             withDouble:(jdouble)a_lon_deg
                             withDouble:(jdouble)b_lat_deg
                             withDouble:(jdouble)b_lon_deg {
  jdouble shrinkFactor = DistanceCalcEarth_calcShrinkFactorWithDouble_withDouble_(self, a_lat_deg, b_lat_deg);
  jdouble a_lat = a_lat_deg;
  jdouble a_lon = a_lon_deg * shrinkFactor;
  jdouble b_lat = b_lat_deg;
  jdouble b_lon = b_lon_deg * shrinkFactor;
  jdouble r_lat = r_lat_deg;
  jdouble r_lon = r_lon_deg * shrinkFactor;
  jdouble ar_x = r_lon - a_lon;
  jdouble ar_y = r_lat - a_lat;
  jdouble ab_x = b_lon - a_lon;
  jdouble ab_y = b_lat - a_lat;
  jdouble ab_ar = ar_x * ab_x + ar_y * ab_y;
  jdouble rb_x = b_lon - r_lon;
  jdouble rb_y = b_lat - r_lat;
  jdouble ab_rb = rb_x * ab_x + rb_y * ab_y;
  return ab_ar > 0 && ab_rb > 0;
}

- (GHPoint *)projectCoordinateWithDouble:(jdouble)latInDeg
                              withDouble:(jdouble)lonInDeg
                              withDouble:(jdouble)distanceInMeter
                              withDouble:(jdouble)headingClockwiseFromNorth {
  jdouble angularDistance = distanceInMeter / DistanceCalcEarth_R;
  jdouble latInRadians = JavaLangMath_toRadiansWithDouble_(latInDeg);
  jdouble lonInRadians = JavaLangMath_toRadiansWithDouble_(lonInDeg);
  jdouble headingInRadians = JavaLangMath_toRadiansWithDouble_(headingClockwiseFromNorth);
  jdouble projectedLat = JavaLangMath_asinWithDouble_(JavaLangMath_sinWithDouble_(latInRadians) * JavaLangMath_cosWithDouble_(angularDistance) + JavaLangMath_cosWithDouble_(latInRadians) * JavaLangMath_sinWithDouble_(angularDistance) * JavaLangMath_cosWithDouble_(headingInRadians));
  jdouble projectedLon = lonInRadians + JavaLangMath_atan2WithDouble_withDouble_(JavaLangMath_sinWithDouble_(headingInRadians) * JavaLangMath_sinWithDouble_(angularDistance) * JavaLangMath_cosWithDouble_(latInRadians), JavaLangMath_cosWithDouble_(angularDistance) - JavaLangMath_sinWithDouble_(latInRadians) * JavaLangMath_sinWithDouble_(projectedLat));
  projectedLon = fmod((projectedLon + 3 * JavaLangMath_PI), (2 * JavaLangMath_PI)) - JavaLangMath_PI;
  projectedLat = JavaLangMath_toDegreesWithDouble_(projectedLat);
  projectedLon = JavaLangMath_toDegreesWithDouble_(projectedLon);
  return [[[GHPoint alloc] initWithDouble:projectedLat withDouble:projectedLon] autorelease];
}

- (jboolean)isCrossBoundaryWithDouble:(jdouble)lon1
                           withDouble:(jdouble)lon2 {
  return JavaLangMath_absWithDouble_(lon1 - lon2) > 300;
}

- (NSString *)description {
  return @"EXACT";
}

- (instancetype)init {
  return [super init];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "calcDistWithDouble:withDouble:withDouble:withDouble:", "calcDist", "D", 0x1, NULL },
    { "calcDenormalizedDistWithDouble:", "calcDenormalizedDist", "D", 0x1, NULL },
    { "calcNormalizedDistWithDouble:", "calcNormalizedDist", "D", 0x1, NULL },
    { "calcNormalizedDistWithDouble:withDouble:withDouble:withDouble:", "calcNormalizedDist", "D", 0x1, NULL },
    { "calcCircumferenceWithDouble:", "calcCircumference", "D", 0x1, NULL },
    { "isDateLineCrossOverWithDouble:withDouble:", "isDateLineCrossOver", "Z", 0x1, NULL },
    { "createBBoxWithDouble:withDouble:withDouble:", "createBBox", "Lcom.graphhopper.util.shapes.BBox;", 0x1, NULL },
    { "calcNormalizedEdgeDistanceWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:", "calcNormalizedEdgeDistance", "D", 0x1, NULL },
    { "calcNormalizedEdgeDistanceNewWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withBoolean:", "calcNormalizedEdgeDistanceNew", "D", 0x1, NULL },
    { "calcShrinkFactorWithDouble:withDouble:", "calcShrinkFactor", "D", 0x2, NULL },
    { "calcCrossingPointToEdgeWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:", "calcCrossingPointToEdge", "Lcom.graphhopper.util.shapes.GHPoint;", 0x1, NULL },
    { "validEdgeDistanceWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:", "validEdgeDistance", "Z", 0x1, NULL },
    { "projectCoordinateWithDouble:withDouble:withDouble:withDouble:", "projectCoordinate", "Lcom.graphhopper.util.shapes.GHPoint;", 0x1, NULL },
    { "isCrossBoundaryWithDouble:withDouble:", "isCrossBoundary", "Z", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "init", NULL, NULL, 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "R_", NULL, 0x19, "D", NULL, .constantValue.asDouble = DistanceCalcEarth_R },
    { "R_EQ_", NULL, 0x19, "D", NULL, .constantValue.asDouble = DistanceCalcEarth_R_EQ },
    { "C_", NULL, 0x19, "D", NULL, .constantValue.asDouble = DistanceCalcEarth_C },
    { "KM_MILE_", NULL, 0x19, "D", NULL, .constantValue.asDouble = DistanceCalcEarth_KM_MILE },
  };
  static const J2ObjcClassInfo _DistanceCalcEarth = { 1, "DistanceCalcEarth", "com.graphhopper.util", NULL, 0x1, 16, methods, 4, fields, 0, NULL};
  return &_DistanceCalcEarth;
}

@end

jdouble DistanceCalcEarth_calcShrinkFactorWithDouble_withDouble_(DistanceCalcEarth *self, jdouble a_lat_deg, jdouble b_lat_deg) {
  return JavaLangMath_cosWithDouble_(JavaLangMath_toRadiansWithDouble_((a_lat_deg + b_lat_deg) / 2));
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(DistanceCalcEarth)
