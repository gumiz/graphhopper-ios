//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/util/AngleCalc.java
//

#include "J2ObjC_source.h"
#include "com/graphhopper/util/AngleCalc.h"
#include "com/graphhopper/util/Helper.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Math.h"

@interface AngleCalc () {
}
@end

@implementation AngleCalc

+ (jdouble)atan2WithDouble:(jdouble)y
                withDouble:(jdouble)x {
  return AngleCalc_atan2WithDouble_withDouble_(y, x);
}

- (jdouble)calcOrientationWithDouble:(jdouble)lat1
                          withDouble:(jdouble)lon1
                          withDouble:(jdouble)lat2
                          withDouble:(jdouble)lon2 {
  jdouble shrinkFactor = JavaLangMath_cosWithDouble_(JavaLangMath_toRadiansWithDouble_((lat1 + lat2) / 2));
  return JavaLangMath_atan2WithDouble_withDouble_((lat2 - lat1), shrinkFactor * (lon2 - lon1));
}

- (jdouble)convertAzimuth2xaxisAngleWithDouble:(jdouble)azimuth {
  if (JavaLangDouble_compareWithDouble_withDouble_(azimuth, 360) > 0 || JavaLangDouble_compareWithDouble_withDouble_(azimuth, 0) < 0) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$D$", @"Azimuth ", azimuth, @" must be in (0, 360)")] autorelease];
  }
  jdouble angleXY = AngleCalc_PI_2 - azimuth / 180. * JavaLangMath_PI;
  if (angleXY < -JavaLangMath_PI) angleXY += 2 * JavaLangMath_PI;
  if (angleXY > JavaLangMath_PI) angleXY -= 2 * JavaLangMath_PI;
  return angleXY;
}

- (jdouble)alignOrientationWithDouble:(jdouble)baseOrientation
                           withDouble:(jdouble)orientation {
  jdouble resultOrientation;
  if (baseOrientation >= 0) {
    if (orientation < -JavaLangMath_PI + baseOrientation) resultOrientation = orientation + 2 * JavaLangMath_PI;
    else resultOrientation = orientation;
  }
  else if (orientation > +JavaLangMath_PI + baseOrientation) resultOrientation = orientation - 2 * JavaLangMath_PI;
  else resultOrientation = orientation;
  return resultOrientation;
}

- (jdouble)calcAzimuthWithDouble:(jdouble)lat1
                      withDouble:(jdouble)lon1
                      withDouble:(jdouble)lat2
                      withDouble:(jdouble)lon2 {
  jdouble orientation = -[self calcOrientationWithDouble:lat1 withDouble:lon1 withDouble:lat2 withDouble:lon2];
  orientation = Helper_round4WithDouble_(orientation + JavaLangMath_PI / 2);
  if (orientation < 0) orientation += 2 * JavaLangMath_PI;
  return JavaLangMath_toDegreesWithDouble_(orientation);
}

- (NSString *)azimuth2compassPointWithDouble:(jdouble)azimuth {
  NSString *cp;
  jdouble slice = 360.0 / 16;
  if (azimuth < slice) {
    cp = @"N";
  }
  else if (azimuth < slice * 3) {
    cp = @"NE";
  }
  else if (azimuth < slice * 5) {
    cp = @"E";
  }
  else if (azimuth < slice * 7) {
    cp = @"SE";
  }
  else if (azimuth < slice * 9) {
    cp = @"S";
  }
  else if (azimuth < slice * 11) {
    cp = @"SW";
  }
  else if (azimuth < slice * 13) {
    cp = @"W";
  }
  else if (azimuth < slice * 15) {
    cp = @"NW";
  }
  else {
    cp = @"N";
  }
  return cp;
}

- (instancetype)init {
  return [super init];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "atan2WithDouble:withDouble:", "atan2", "D", 0x18, NULL },
    { "calcOrientationWithDouble:withDouble:withDouble:withDouble:", "calcOrientation", "D", 0x1, NULL },
    { "convertAzimuth2xaxisAngleWithDouble:", "convertAzimuth2xaxisAngle", "D", 0x1, NULL },
    { "alignOrientationWithDouble:withDouble:", "alignOrientation", "D", 0x1, NULL },
    { "calcAzimuthWithDouble:withDouble:withDouble:withDouble:", "calcAzimuth", "D", 0x0, NULL },
    { "azimuth2compassPointWithDouble:", "azimuth2compassPoint", "Ljava.lang.String;", 0x0, NULL },
    { "init", NULL, NULL, 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "PI_4_", NULL, 0x1a, "D", NULL, .constantValue.asDouble = AngleCalc_PI_4 },
    { "PI_2_", NULL, 0x1a, "D", NULL, .constantValue.asDouble = AngleCalc_PI_2 },
    { "PI3_4_", NULL, 0x1a, "D", NULL, .constantValue.asDouble = AngleCalc_PI3_4 },
  };
  static const J2ObjcClassInfo _AngleCalc = { 1, "AngleCalc", "com.graphhopper.util", NULL, 0x1, 7, methods, 3, fields, 0, NULL};
  return &_AngleCalc;
}

@end

jdouble AngleCalc_atan2WithDouble_withDouble_(jdouble y, jdouble x) {
  AngleCalc_init();
  jdouble absY = JavaLangMath_absWithDouble_(y) + 1e-10;
  jdouble r, angle;
  if (x < 0.0) {
    r = (x + absY) / (absY - x);
    angle = AngleCalc_PI3_4;
  }
  else {
    r = (x - absY) / (x + absY);
    angle = AngleCalc_PI_4;
  }
  angle += (0.1963 * r * r - 0.9817) * r;
  if (y < 0.0) return -angle;
  return angle;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AngleCalc)
