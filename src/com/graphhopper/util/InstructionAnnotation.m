//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/util/InstructionAnnotation.java
//

#include "IOSClass.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/util/InstructionAnnotation.h"

__attribute__((unused)) static void InstructionAnnotation_setEmpty(InstructionAnnotation *self);

@interface InstructionAnnotation () {
 @public
  jboolean empty_;
  jint importance_;
  NSString *message_;
}
- (instancetype)init;

- (void)setEmpty;
@end

J2OBJC_FIELD_SETTER(InstructionAnnotation, message_, NSString *)

BOOL InstructionAnnotation_initialized = NO;

@implementation InstructionAnnotation

InstructionAnnotation * InstructionAnnotation_EMPTY_;

- (instancetype)init {
  if (self = [super init]) {
    InstructionAnnotation_setEmpty(self);
  }
  return self;
}

- (instancetype)initWithInt:(jint)importance
               withNSString:(NSString *)message {
  if (self = [super init]) {
    if ([((NSString *) nil_chk(message)) isEmpty] && importance == 0) {
      InstructionAnnotation_setEmpty(self);
    }
    else {
      self->empty_ = NO;
      self->importance_ = importance;
      InstructionAnnotation_set_message_(self, message);
    }
  }
  return self;
}

- (void)setEmpty {
  InstructionAnnotation_setEmpty(self);
}

- (jboolean)isEmpty {
  return empty_;
}

- (jint)getImportance {
  return importance_;
}

- (NSString *)getMessage {
  return message_;
}

- (NSString *)description {
  return JreStrcat("I$$", importance_, @": ", [self getMessage]);
}

- (NSUInteger)hash {
  jint hash_ = 3;
  hash_ = 83 * hash_ + self->importance_;
  hash_ = 83 * hash_ + (self->message_ != nil ? ((jint) [self->message_ hash]) : 0);
  return hash_;
}

- (jboolean)isEqual:(id)obj {
  if (obj == nil) return NO;
  if ([self getClass] != [nil_chk(obj) getClass]) return NO;
  InstructionAnnotation *other = (InstructionAnnotation *) check_class_cast(obj, [InstructionAnnotation class]);
  if (self->importance_ != other->importance_) return NO;
  if ((self->message_ == nil) ? (other->message_ != nil) : ![self->message_ isEqual:other->message_]) return NO;
  return YES;
}

- (void)dealloc {
  RELEASE_(message_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(InstructionAnnotation *)other {
  [super copyAllFieldsTo:other];
  other->empty_ = empty_;
  other->importance_ = importance_;
  InstructionAnnotation_set_message_(other, message_);
}

+ (void)initialize {
  if (self == [InstructionAnnotation class]) {
    JreStrongAssignAndConsume(&InstructionAnnotation_EMPTY_, nil, [[InstructionAnnotation alloc] init]);
    J2OBJC_SET_INITIALIZED(InstructionAnnotation)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "InstructionAnnotation", NULL, 0x2, NULL },
    { "initWithInt:withNSString:", "InstructionAnnotation", NULL, 0x1, NULL },
    { "setEmpty", NULL, "V", 0x2, NULL },
    { "isEmpty", NULL, "Z", 0x1, NULL },
    { "getImportance", NULL, "I", 0x1, NULL },
    { "getMessage", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "hash", "hashCode", "I", 0x1, NULL },
    { "isEqual:", "equals", "Z", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "EMPTY_", NULL, 0x19, "Lcom.graphhopper.util.InstructionAnnotation;", &InstructionAnnotation_EMPTY_,  },
    { "empty_", NULL, 0x2, "Z", NULL,  },
    { "importance_", NULL, 0x2, "I", NULL,  },
    { "message_", NULL, 0x2, "Ljava.lang.String;", NULL,  },
  };
  static const J2ObjcClassInfo _InstructionAnnotation = { 1, "InstructionAnnotation", "com.graphhopper.util", NULL, 0x1, 9, methods, 4, fields, 0, NULL};
  return &_InstructionAnnotation;
}

@end

void InstructionAnnotation_setEmpty(InstructionAnnotation *self) {
  self->empty_ = YES;
  self->importance_ = 0;
  InstructionAnnotation_set_message_(self, @"");
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(InstructionAnnotation)
