//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/GHResponse.java
//

#include "J2ObjC_source.h"
#include "com/graphhopper/GHResponse.h"
#include "com/graphhopper/PathWrapper.h"
#include "com/graphhopper/util/PMap.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/Throwable.h"
#include "java/util/ArrayList.h"
#include "java/util/List.h"

@interface GHResponse () {
 @public
  id<JavaUtilList> errors_;
  PMap *hintsMap_;
  id<JavaUtilList> pathWrappers_;
  NSString *debugInfo_;
}
@end

J2OBJC_FIELD_SETTER(GHResponse, errors_, id<JavaUtilList>)
J2OBJC_FIELD_SETTER(GHResponse, hintsMap_, PMap *)
J2OBJC_FIELD_SETTER(GHResponse, pathWrappers_, id<JavaUtilList>)
J2OBJC_FIELD_SETTER(GHResponse, debugInfo_, NSString *)

@implementation GHResponse

- (instancetype)init {
  if (self = [super init]) {
    GHResponse_setAndConsume_errors_(self, [[JavaUtilArrayList alloc] initWithInt:4]);
    GHResponse_setAndConsume_hintsMap_(self, [[PMap alloc] init]);
    GHResponse_setAndConsume_pathWrappers_(self, [[JavaUtilArrayList alloc] initWithInt:5]);
    GHResponse_set_debugInfo_(self, @"");
  }
  return self;
}

- (void)addWithPathWrapper:(PathWrapper *)altResponse {
  [((id<JavaUtilList>) nil_chk(pathWrappers_)) addWithId:altResponse];
}

- (PathWrapper *)getBest {
  if ([((id<JavaUtilList>) nil_chk(pathWrappers_)) isEmpty]) @throw [[[JavaLangRuntimeException alloc] initWithNSString:@"Cannot fetch best response if list is empty"] autorelease];
  return [pathWrappers_ getWithInt:0];
}

- (id<JavaUtilList>)getAll {
  return pathWrappers_;
}

- (jboolean)hasAlternatives {
  return [((id<JavaUtilList>) nil_chk(pathWrappers_)) size] > 1;
}

- (void)addDebugInfoWithNSString:(NSString *)debugInfo {
  if (debugInfo == nil) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Debug information has to be none null"] autorelease];
  if (![((NSString *) nil_chk(self->debugInfo_)) isEmpty]) GHResponse_set_debugInfo_(self, JreStrcat("$$", self->debugInfo_, @"; "));
  GHResponse_set_debugInfo_(self, JreStrcat("$$", self->debugInfo_, debugInfo));
}

- (NSString *)getDebugInfo {
  NSString *str = debugInfo_;
  for (PathWrapper * __strong ar in nil_chk(pathWrappers_)) {
    if (![((NSString *) nil_chk(str)) isEmpty]) str = JreStrcat("$$", str, @"; ");
    str = JreStrcat("$$", str, [((PathWrapper *) nil_chk(ar)) getDebugInfo]);
  }
  return str;
}

- (jboolean)hasErrors {
  if (![((id<JavaUtilList>) nil_chk(errors_)) isEmpty]) return YES;
  for (PathWrapper * __strong ar in nil_chk(pathWrappers_)) {
    if ([((PathWrapper *) nil_chk(ar)) hasErrors]) return YES;
  }
  return NO;
}

- (id<JavaUtilList>)getErrors {
  id<JavaUtilList> list = [[[JavaUtilArrayList alloc] init] autorelease];
  [list addAllWithJavaUtilCollection:errors_];
  for (PathWrapper * __strong ar in nil_chk(pathWrappers_)) {
    [list addAllWithJavaUtilCollection:[((PathWrapper *) nil_chk(ar)) getErrors]];
  }
  return list;
}

- (GHResponse *)addErrorsWithJavaUtilList:(id<JavaUtilList>)errors {
  [((id<JavaUtilList>) nil_chk(self->errors_)) addAllWithJavaUtilCollection:errors];
  return self;
}

- (GHResponse *)addErrorWithJavaLangThrowable:(JavaLangThrowable *)error {
  [((id<JavaUtilList>) nil_chk(self->errors_)) addWithId:error];
  return self;
}

- (NSString *)description {
  NSString *str = @"";
  for (PathWrapper * __strong a in nil_chk(pathWrappers_)) {
    str = JreStrcat("$$", str, JreStrcat("$$", @"; ", [((PathWrapper *) nil_chk(a)) description]));
  }
  if ([pathWrappers_ isEmpty]) str = @"no paths";
  if (![((id<JavaUtilList>) nil_chk(errors_)) isEmpty]) str = JreStrcat("$$", str, JreStrcat("$$", @", main errors: ", [errors_ description]));
  return str;
}

- (PMap *)getHints {
  return hintsMap_;
}

- (void)dealloc {
  RELEASE_(errors_);
  RELEASE_(hintsMap_);
  RELEASE_(pathWrappers_);
  RELEASE_(debugInfo_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(GHResponse *)other {
  [super copyAllFieldsTo:other];
  GHResponse_set_errors_(other, errors_);
  GHResponse_set_hintsMap_(other, hintsMap_);
  GHResponse_set_pathWrappers_(other, pathWrappers_);
  GHResponse_set_debugInfo_(other, debugInfo_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "GHResponse", NULL, 0x1, NULL },
    { "addWithPathWrapper:", "add", "V", 0x1, NULL },
    { "getBest", NULL, "Lcom.graphhopper.PathWrapper;", 0x1, NULL },
    { "getAll", NULL, "Ljava.util.List;", 0x1, NULL },
    { "hasAlternatives", NULL, "Z", 0x1, NULL },
    { "addDebugInfoWithNSString:", "addDebugInfo", "V", 0x1, NULL },
    { "getDebugInfo", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "hasErrors", NULL, "Z", 0x1, NULL },
    { "getErrors", NULL, "Ljava.util.List;", 0x1, NULL },
    { "addErrorsWithJavaUtilList:", "addErrors", "Lcom.graphhopper.GHResponse;", 0x1, NULL },
    { "addErrorWithJavaLangThrowable:", "addError", "Lcom.graphhopper.GHResponse;", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "getHints", NULL, "Lcom.graphhopper.util.PMap;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "errors_", NULL, 0x12, "Ljava.util.List;", NULL,  },
    { "hintsMap_", NULL, 0x12, "Lcom.graphhopper.util.PMap;", NULL,  },
    { "pathWrappers_", NULL, 0x12, "Ljava.util.List;", NULL,  },
    { "debugInfo_", NULL, 0x2, "Ljava.lang.String;", NULL,  },
  };
  static const J2ObjcClassInfo _GHResponse = { 1, "GHResponse", "com.graphhopper", NULL, 0x1, 13, methods, 4, fields, 0, NULL};
  return &_GHResponse;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GHResponse)
