//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
//

#include "J2ObjC_source.h"
#include "com/graphhopper/routing/AbstractRoutingAlgorithm.h"
#include "com/graphhopper/routing/DijkstraBidirectionRef.h"
#include "com/graphhopper/routing/Path.h"
#include "com/graphhopper/routing/PathBidirRef.h"
#include "com/graphhopper/routing/util/TraversalMode.h"
#include "com/graphhopper/routing/weighting/Weighting.h"
#include "com/graphhopper/storage/Graph.h"
#include "com/graphhopper/storage/SPTEntry.h"
#include "com/graphhopper/util/EdgeExplorer.h"
#include "com/graphhopper/util/EdgeIterator.h"
#include "com/graphhopper/util/EdgeIteratorState.h"
#include "com/graphhopper/util/GHUtility.h"
#include "com/graphhopper/util/Parameters.h"
#include "gnu/trove/map/TIntObjectMap.h"
#include "gnu/trove/map/hash/TIntObjectHashMap.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Math.h"
#include "java/util/PriorityQueue.h"

@interface DijkstraBidirectionRef () {
 @public
  JavaUtilPriorityQueue *openSetFrom_;
  JavaUtilPriorityQueue *openSetTo_;
  jboolean updateBestPath__;
}
@end

J2OBJC_FIELD_SETTER(DijkstraBidirectionRef, openSetFrom_, JavaUtilPriorityQueue *)
J2OBJC_FIELD_SETTER(DijkstraBidirectionRef, openSetTo_, JavaUtilPriorityQueue *)

@implementation DijkstraBidirectionRef

- (instancetype)initWithGraph:(id<Graph>)graph
withComGraphhopperRoutingWeightingWeighting:(id<ComGraphhopperRoutingWeightingWeighting>)weighting
        withTraversalModeEnum:(TraversalModeEnum *)tMode {
  if (self = [super initWithGraph:graph withComGraphhopperRoutingWeightingWeighting:weighting withTraversalModeEnum:tMode]) {
    updateBestPath__ = YES;
    jint size = JavaLangMath_minWithInt_withInt_(JavaLangMath_maxWithInt_withInt_(200, [((id<Graph>) nil_chk(graph)) getNodes] / 10), 2000);
    [self initCollectionsWithInt:size];
  }
  return self;
}

- (void)initCollectionsWithInt:(jint)size {
  DijkstraBidirectionRef_setAndConsume_openSetFrom_(self, [[JavaUtilPriorityQueue alloc] initWithInt:size]);
  DijkstraBidirectionRef_setAndConsume_bestWeightMapFrom_(self, [[GnuTroveMapHashTIntObjectHashMap alloc] initWithInt:size]);
  DijkstraBidirectionRef_setAndConsume_openSetTo_(self, [[JavaUtilPriorityQueue alloc] initWithInt:size / 10]);
  DijkstraBidirectionRef_setAndConsume_bestWeightMapTo_(self, [[GnuTroveMapHashTIntObjectHashMap alloc] initWithInt:size]);
}

- (void)initFromWithInt:(jint)from
             withDouble:(jdouble)weight {
  DijkstraBidirectionRef_set_currFrom_(self, [self createSPTEntryWithInt:from withDouble:weight]);
  [((JavaUtilPriorityQueue *) nil_chk(openSetFrom_)) addWithId:currFrom_];
  if (![((TraversalModeEnum *) nil_chk(traversalMode_)) isEdgeBased]) {
    [((id<GnuTroveMapTIntObjectMap>) nil_chk(bestWeightMapFrom_)) putWithInt:from withId:currFrom_];
    if (currTo_ != nil) {
      DijkstraBidirectionRef_set_bestWeightMapOther_(self, bestWeightMapTo_);
      [self updateBestPathWithEdgeIteratorState:GHUtility_getEdgeWithGraph_withInt_withInt_(graph_, from, currTo_->adjNode_) withSPTEntry:currTo_ withInt:from];
    }
  }
  else if (currTo_ != nil && currTo_->adjNode_ == from) {
    Path_set_sptEntry_(nil_chk(bestPath_), currFrom_);
    PathBidirRef_set_edgeTo_(bestPath_, currTo_);
    finishedFrom_ = YES;
    finishedTo_ = YES;
  }
}

- (void)initToWithInt:(jint)to
           withDouble:(jdouble)weight {
  DijkstraBidirectionRef_set_currTo_(self, [self createSPTEntryWithInt:to withDouble:weight]);
  [((JavaUtilPriorityQueue *) nil_chk(openSetTo_)) addWithId:currTo_];
  if (![((TraversalModeEnum *) nil_chk(traversalMode_)) isEdgeBased]) {
    [((id<GnuTroveMapTIntObjectMap>) nil_chk(bestWeightMapTo_)) putWithInt:to withId:currTo_];
    if (currFrom_ != nil) {
      DijkstraBidirectionRef_set_bestWeightMapOther_(self, bestWeightMapFrom_);
      [self updateBestPathWithEdgeIteratorState:GHUtility_getEdgeWithGraph_withInt_withInt_(graph_, currFrom_->adjNode_, to) withSPTEntry:currFrom_ withInt:to];
    }
  }
  else if (currFrom_ != nil && currFrom_->adjNode_ == to) {
    Path_set_sptEntry_(nil_chk(bestPath_), currFrom_);
    PathBidirRef_set_edgeTo_(bestPath_, currTo_);
    finishedFrom_ = YES;
    finishedTo_ = YES;
  }
}

- (Path *)createAndInitPath {
  DijkstraBidirectionRef_setAndConsume_bestPath_(self, [[PathBidirRef alloc] initWithGraph:graph_ withComGraphhopperRoutingWeightingWeighting:weighting_]);
  return bestPath_;
}

- (Path *)extractPath {
  if ([self finished]) return [((PathBidirRef *) nil_chk(bestPath_)) extract];
  return bestPath_;
}

- (jdouble)getCurrentFromWeight {
  return ((SPTEntry *) nil_chk(currFrom_))->weight_;
}

- (jdouble)getCurrentToWeight {
  return ((SPTEntry *) nil_chk(currTo_))->weight_;
}

- (jboolean)fillEdgesFrom {
  if ([((JavaUtilPriorityQueue *) nil_chk(openSetFrom_)) isEmpty]) return NO;
  DijkstraBidirectionRef_set_currFrom_(self, [openSetFrom_ poll]);
  DijkstraBidirectionRef_set_bestWeightMapOther_(self, bestWeightMapTo_);
  [self fillEdgesWithSPTEntry:currFrom_ withJavaUtilPriorityQueue:openSetFrom_ withGnuTroveMapTIntObjectMap:bestWeightMapFrom_ withEdgeExplorer:outEdgeExplorer_ withBoolean:NO];
  visitedCountFrom_++;
  return YES;
}

- (jboolean)fillEdgesTo {
  if ([((JavaUtilPriorityQueue *) nil_chk(openSetTo_)) isEmpty]) return NO;
  DijkstraBidirectionRef_set_currTo_(self, [openSetTo_ poll]);
  DijkstraBidirectionRef_set_bestWeightMapOther_(self, bestWeightMapFrom_);
  [self fillEdgesWithSPTEntry:currTo_ withJavaUtilPriorityQueue:openSetTo_ withGnuTroveMapTIntObjectMap:bestWeightMapTo_ withEdgeExplorer:inEdgeExplorer_ withBoolean:YES];
  visitedCountTo_++;
  return YES;
}

- (jboolean)finished {
  if (finishedFrom_ || finishedTo_) return YES;
  return ((SPTEntry *) nil_chk(currFrom_))->weight_ + ((SPTEntry *) nil_chk(currTo_))->weight_ >= [((PathBidirRef *) nil_chk(bestPath_)) getWeight];
}

- (void)fillEdgesWithSPTEntry:(SPTEntry *)currEdge
    withJavaUtilPriorityQueue:(JavaUtilPriorityQueue *)prioQueue
 withGnuTroveMapTIntObjectMap:(id<GnuTroveMapTIntObjectMap>)shortestWeightMap
             withEdgeExplorer:(id<EdgeExplorer>)explorer
                  withBoolean:(jboolean)reverse {
  id<EdgeIterator> iter = [((id<EdgeExplorer>) nil_chk(explorer)) setBaseNodeWithInt:((SPTEntry *) nil_chk(currEdge))->adjNode_];
  while ([((id<EdgeIterator>) nil_chk(iter)) next]) {
    if (![self acceptWithEdgeIterator:iter withInt:currEdge->edge_]) continue;
    jint traversalId = [((TraversalModeEnum *) nil_chk(traversalMode_)) createTraversalIdWithEdgeIteratorState:iter withBoolean:reverse];
    jdouble tmpWeight = [((id<ComGraphhopperRoutingWeightingWeighting>) nil_chk(weighting_)) calcWeightWithEdgeIteratorState:iter withBoolean:reverse withInt:currEdge->edge_] + currEdge->weight_;
    if (JavaLangDouble_isInfiniteWithDouble_(tmpWeight)) continue;
    SPTEntry *ee = [((id<GnuTroveMapTIntObjectMap>) nil_chk(shortestWeightMap)) getWithInt:traversalId];
    if (ee == nil) {
      ee = [[[SPTEntry alloc] initWithInt:[iter getEdge] withInt:[iter getAdjNode] withDouble:tmpWeight] autorelease];
      SPTEntry_set_parent_(ee, currEdge);
      [shortestWeightMap putWithInt:traversalId withId:ee];
      [((JavaUtilPriorityQueue *) nil_chk(prioQueue)) addWithId:ee];
    }
    else if (ee->weight_ > tmpWeight) {
      [((JavaUtilPriorityQueue *) nil_chk(prioQueue)) removeWithId:ee];
      ee->edge_ = [iter getEdge];
      ee->weight_ = tmpWeight;
      SPTEntry_set_parent_(ee, currEdge);
      [prioQueue addWithId:ee];
    }
    else continue;
    if (updateBestPath__) [self updateBestPathWithEdgeIteratorState:iter withSPTEntry:ee withInt:traversalId];
  }
}

- (void)updateBestPathWithEdgeIteratorState:(id<EdgeIteratorState>)edgeState
                               withSPTEntry:(SPTEntry *)entryCurrent
                                    withInt:(jint)traversalId {
  SPTEntry *entryOther = [((id<GnuTroveMapTIntObjectMap>) nil_chk(bestWeightMapOther_)) getWithInt:traversalId];
  if (entryOther == nil) return;
  jboolean reverse = bestWeightMapFrom_ == bestWeightMapOther_;
  jdouble newWeight = ((SPTEntry *) nil_chk(entryCurrent))->weight_ + ((SPTEntry *) nil_chk(entryOther))->weight_;
  if ([((TraversalModeEnum *) nil_chk(traversalMode_)) isEdgeBased]) {
    if (entryOther->edge_ != entryCurrent->edge_) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$$", @"cannot happen for edge based execution of ", [self getName])] autorelease];
    if (entryOther->adjNode_ != entryCurrent->adjNode_) {
      entryCurrent = entryCurrent->parent_;
      newWeight -= [((id<ComGraphhopperRoutingWeightingWeighting>) nil_chk(weighting_)) calcWeightWithEdgeIteratorState:edgeState withBoolean:reverse withInt:EdgeIterator_NO_EDGE];
    }
    else if (![traversalMode_ hasUTurnSupport]) return;
  }
  if (newWeight < [((PathBidirRef *) nil_chk(bestPath_)) getWeight]) {
    [bestPath_ setSwitchToFromWithBoolean:reverse];
    [bestPath_ setSPTEntryWithSPTEntry:entryCurrent];
    [bestPath_ setWeightWithDouble:newWeight];
    [bestPath_ setSPTEntryToWithSPTEntry:entryOther];
  }
}

- (id<GnuTroveMapTIntObjectMap>)getBestFromMap {
  return bestWeightMapFrom_;
}

- (id<GnuTroveMapTIntObjectMap>)getBestToMap {
  return bestWeightMapTo_;
}

- (void)setBestOtherMapWithGnuTroveMapTIntObjectMap:(id<GnuTroveMapTIntObjectMap>)other {
  DijkstraBidirectionRef_set_bestWeightMapOther_(self, other);
}

- (void)setFromDataStructuresWithDijkstraBidirectionRef:(DijkstraBidirectionRef *)dijkstra {
  DijkstraBidirectionRef_set_openSetFrom_(self, ((DijkstraBidirectionRef *) nil_chk(dijkstra))->openSetFrom_);
  DijkstraBidirectionRef_set_bestWeightMapFrom_(self, dijkstra->bestWeightMapFrom_);
  finishedFrom_ = dijkstra->finishedFrom_;
  DijkstraBidirectionRef_set_currFrom_(self, dijkstra->currFrom_);
  visitedCountFrom_ = dijkstra->visitedCountFrom_;
}

- (void)setToDataStructuresWithDijkstraBidirectionRef:(DijkstraBidirectionRef *)dijkstra {
  DijkstraBidirectionRef_set_openSetTo_(self, ((DijkstraBidirectionRef *) nil_chk(dijkstra))->openSetTo_);
  DijkstraBidirectionRef_set_bestWeightMapTo_(self, dijkstra->bestWeightMapTo_);
  finishedTo_ = dijkstra->finishedTo_;
  DijkstraBidirectionRef_set_currTo_(self, dijkstra->currTo_);
  visitedCountTo_ = dijkstra->visitedCountTo_;
}

- (void)setUpdateBestPathWithBoolean:(jboolean)b {
  updateBestPath__ = b;
}

- (void)setBestPathWithPathBidirRef:(PathBidirRef *)bestPath {
  DijkstraBidirectionRef_set_bestPath_(self, bestPath);
}

- (NSString *)getName {
  return Parameters_Algorithms_get_DIJKSTRA_BI_();
}

- (void)dealloc {
  RELEASE_(bestWeightMapFrom_);
  RELEASE_(bestWeightMapTo_);
  RELEASE_(bestWeightMapOther_);
  RELEASE_(currFrom_);
  RELEASE_(currTo_);
  RELEASE_(bestPath_);
  RELEASE_(openSetFrom_);
  RELEASE_(openSetTo_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(DijkstraBidirectionRef *)other {
  [super copyAllFieldsTo:other];
  DijkstraBidirectionRef_set_bestWeightMapFrom_(other, bestWeightMapFrom_);
  DijkstraBidirectionRef_set_bestWeightMapTo_(other, bestWeightMapTo_);
  DijkstraBidirectionRef_set_bestWeightMapOther_(other, bestWeightMapOther_);
  DijkstraBidirectionRef_set_currFrom_(other, currFrom_);
  DijkstraBidirectionRef_set_currTo_(other, currTo_);
  DijkstraBidirectionRef_set_bestPath_(other, bestPath_);
  DijkstraBidirectionRef_set_openSetFrom_(other, openSetFrom_);
  DijkstraBidirectionRef_set_openSetTo_(other, openSetTo_);
  other->updateBestPath__ = updateBestPath__;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGraph:withComGraphhopperRoutingWeightingWeighting:withTraversalModeEnum:", "DijkstraBidirectionRef", NULL, 0x1, NULL },
    { "initCollectionsWithInt:", "initCollections", "V", 0x4, NULL },
    { "initFromWithInt:withDouble:", "initFrom", "V", 0x1, NULL },
    { "initToWithInt:withDouble:", "initTo", "V", 0x1, NULL },
    { "createAndInitPath", NULL, "Lcom.graphhopper.routing.Path;", 0x4, NULL },
    { "extractPath", NULL, "Lcom.graphhopper.routing.Path;", 0x4, NULL },
    { "getCurrentFromWeight", NULL, "D", 0x4, NULL },
    { "getCurrentToWeight", NULL, "D", 0x4, NULL },
    { "fillEdgesFrom", NULL, "Z", 0x1, NULL },
    { "fillEdgesTo", NULL, "Z", 0x1, NULL },
    { "finished", NULL, "Z", 0x1, NULL },
    { "fillEdgesWithSPTEntry:withJavaUtilPriorityQueue:withGnuTroveMapTIntObjectMap:withEdgeExplorer:withBoolean:", "fillEdges", "V", 0x0, NULL },
    { "updateBestPathWithEdgeIteratorState:withSPTEntry:withInt:", "updateBestPath", "V", 0x4, NULL },
    { "getBestFromMap", NULL, "Lgnu.trove.map.TIntObjectMap;", 0x0, NULL },
    { "getBestToMap", NULL, "Lgnu.trove.map.TIntObjectMap;", 0x0, NULL },
    { "setBestOtherMapWithGnuTroveMapTIntObjectMap:", "setBestOtherMap", "V", 0x0, NULL },
    { "setFromDataStructuresWithDijkstraBidirectionRef:", "setFromDataStructures", "V", 0x0, NULL },
    { "setToDataStructuresWithDijkstraBidirectionRef:", "setToDataStructures", "V", 0x0, NULL },
    { "setUpdateBestPathWithBoolean:", "setUpdateBestPath", "V", 0x0, NULL },
    { "setBestPathWithPathBidirRef:", "setBestPath", "V", 0x0, NULL },
    { "getName", NULL, "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "bestWeightMapFrom_", NULL, 0x4, "Lgnu.trove.map.TIntObjectMap;", NULL,  },
    { "bestWeightMapTo_", NULL, 0x4, "Lgnu.trove.map.TIntObjectMap;", NULL,  },
    { "bestWeightMapOther_", NULL, 0x4, "Lgnu.trove.map.TIntObjectMap;", NULL,  },
    { "currFrom_", NULL, 0x4, "Lcom.graphhopper.storage.SPTEntry;", NULL,  },
    { "currTo_", NULL, 0x4, "Lcom.graphhopper.storage.SPTEntry;", NULL,  },
    { "bestPath_", NULL, 0x4, "Lcom.graphhopper.routing.PathBidirRef;", NULL,  },
    { "openSetFrom_", NULL, 0x2, "Ljava.util.PriorityQueue;", NULL,  },
    { "openSetTo_", NULL, 0x2, "Ljava.util.PriorityQueue;", NULL,  },
    { "updateBestPath__", "updateBestPath", 0x2, "Z", NULL,  },
  };
  static const J2ObjcClassInfo _DijkstraBidirectionRef = { 1, "DijkstraBidirectionRef", "com.graphhopper.routing", NULL, 0x1, 21, methods, 9, fields, 0, NULL};
  return &_DijkstraBidirectionRef;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(DijkstraBidirectionRef)
