//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
//

#include "J2ObjC_source.h"
#include "com/graphhopper/reader/ReaderWay.h"
#include "com/graphhopper/routing/util/AbstractFlagEncoder.h"
#include "com/graphhopper/routing/util/BikeCommonFlagEncoder.h"
#include "com/graphhopper/routing/util/BikeFlagEncoder.h"
#include "com/graphhopper/util/PMap.h"
#include "java/util/Set.h"

@implementation BikeFlagEncoder

- (instancetype)init {
  return [self initBikeFlagEncoderWithInt:4 withDouble:2 withInt:0];
}

- (instancetype)initWithNSString:(NSString *)propertiesString {
  return [self initBikeFlagEncoderWithPMap:[[[PMap alloc] initWithNSString:propertiesString] autorelease]];
}

- (instancetype)initBikeFlagEncoderWithPMap:(PMap *)properties {
  if (self = [self initBikeFlagEncoderWithInt:(jint) [((PMap *) nil_chk(properties)) getLongWithNSString:@"speed_bits" withLong:4] withDouble:[properties getLongWithNSString:@"speed_factor" withLong:2] withInt:[properties getBoolWithNSString:@"turn_costs" withBoolean:NO] ? 1 : 0]) {
    AbstractFlagEncoder_set_properties_(self, properties);
    [self setBlockFordsWithBoolean:[properties getBoolWithNSString:@"block_fords" withBoolean:YES]];
  }
  return self;
}

- (instancetype)initWithPMap:(PMap *)properties {
  return [self initBikeFlagEncoderWithPMap:properties];
}

- (instancetype)initBikeFlagEncoderWithInt:(jint)speedBits
                                withDouble:(jdouble)speedFactor
                                   withInt:(jint)maxTurnCosts {
  if (self = [super initWithInt:speedBits withDouble:speedFactor withInt:maxTurnCosts]) {
    [self addPushingSectionWithNSString:@"path"];
    [self addPushingSectionWithNSString:@"footway"];
    [self addPushingSectionWithNSString:@"pedestrian"];
    [self addPushingSectionWithNSString:@"steps"];
    [((id<JavaUtilSet>) nil_chk(avoidHighwayTags_)) addWithId:@"trunk"];
    [avoidHighwayTags_ addWithId:@"trunk_link"];
    [avoidHighwayTags_ addWithId:@"primary"];
    [avoidHighwayTags_ addWithId:@"primary_link"];
    [avoidHighwayTags_ addWithId:@"secondary"];
    [avoidHighwayTags_ addWithId:@"secondary_link"];
    [((id<JavaUtilSet>) nil_chk(preferHighwayTags_)) addWithId:@"service"];
    [preferHighwayTags_ addWithId:@"tertiary"];
    [preferHighwayTags_ addWithId:@"tertiary_link"];
    [preferHighwayTags_ addWithId:@"residential"];
    [preferHighwayTags_ addWithId:@"unclassified"];
    [((id<JavaUtilSet>) nil_chk(absoluteBarriers_)) addWithId:@"kissing_gate"];
    [self setSpecificClassBicycleWithNSString:@"touring"];
    [self init__];
  }
  return self;
}

- (instancetype)initWithInt:(jint)speedBits
                 withDouble:(jdouble)speedFactor
                    withInt:(jint)maxTurnCosts {
  return [self initBikeFlagEncoderWithInt:speedBits withDouble:speedFactor withInt:maxTurnCosts];
}

- (jint)getVersion {
  return 1;
}

- (jboolean)isPushingSectionWithReaderWay:(ReaderWay *)way {
  NSString *highway = [((ReaderWay *) nil_chk(way)) getTagWithNSString:@"highway"];
  NSString *trackType = [way getTagWithNSString:@"tracktype"];
  return [super isPushingSectionWithReaderWay:way] || ([@"track" isEqual:highway] && trackType != nil && ![@"grade1" isEqual:trackType]);
}

- (NSString *)description {
  return @"bike";
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "BikeFlagEncoder", NULL, 0x1, NULL },
    { "initWithNSString:", "BikeFlagEncoder", NULL, 0x1, NULL },
    { "initWithPMap:", "BikeFlagEncoder", NULL, 0x1, NULL },
    { "initWithInt:withDouble:withInt:", "BikeFlagEncoder", NULL, 0x1, NULL },
    { "getVersion", NULL, "I", 0x1, NULL },
    { "isPushingSectionWithReaderWay:", "isPushingSection", "Z", 0x0, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcClassInfo _BikeFlagEncoder = { 1, "BikeFlagEncoder", "com.graphhopper.routing.util", NULL, 0x1, 7, methods, 0, NULL, 0, NULL};
  return &_BikeFlagEncoder;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(BikeFlagEncoder)
