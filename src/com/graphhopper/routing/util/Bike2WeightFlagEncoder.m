//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
//

#include "J2ObjC_source.h"
#include "com/graphhopper/reader/ReaderWay.h"
#include "com/graphhopper/routing/util/AbstractFlagEncoder.h"
#include "com/graphhopper/routing/util/Bike2WeightFlagEncoder.h"
#include "com/graphhopper/routing/util/BikeCommonFlagEncoder.h"
#include "com/graphhopper/routing/util/EncodedDoubleValue.h"
#include "com/graphhopper/util/BitUtil.h"
#include "com/graphhopper/util/EdgeIteratorState.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/PMap.h"
#include "com/graphhopper/util/PointList.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"

@interface Bike2WeightFlagEncoder () {
 @public
  EncodedDoubleValue *reverseSpeedEncoder_;
}
@end

J2OBJC_FIELD_SETTER(Bike2WeightFlagEncoder, reverseSpeedEncoder_, EncodedDoubleValue *)

@implementation Bike2WeightFlagEncoder

- (instancetype)init {
  return [super init];
}

- (instancetype)initWithNSString:(NSString *)propertiesStr {
  return [super initWithPMap:[[[PMap alloc] initWithNSString:propertiesStr] autorelease]];
}

- (instancetype)initWithPMap:(PMap *)properties {
  return [super initWithPMap:properties];
}

- (instancetype)initWithInt:(jint)speedBits
                 withDouble:(jdouble)speedFactor
                    withInt:(jint)maxTurnCosts {
  return [super initWithInt:speedBits withDouble:speedFactor withInt:maxTurnCosts];
}

- (jint)getVersion {
  return 1;
}

- (jint)defineWayBitsWithInt:(jint)index
                     withInt:(jint)shift {
  shift = [super defineWayBitsWithInt:index withInt:shift];
  Bike2WeightFlagEncoder_setAndConsume_reverseSpeedEncoder_(self, [[EncodedDoubleValue alloc] initWithNSString:@"Reverse Speed" withInt:shift withInt:speedBits_ withDouble:speedFactor_ withLong:[self getHighwaySpeedWithNSString:@"cycleway"] withInt:maxPossibleSpeed_]);
  shift += [reverseSpeedEncoder_ getBits];
  return shift;
}

- (jdouble)getReverseSpeedWithLong:(jlong)flags {
  return [((EncodedDoubleValue *) nil_chk(reverseSpeedEncoder_)) getDoubleValueWithLong:flags];
}

- (jlong)setReverseSpeedWithLong:(jlong)flags
                      withDouble:(jdouble)speed {
  if (speed < 0) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$D$$", @"Speed cannot be negative: ", speed, @", flags:", [((BitUtil *) nil_chk(BitUtil_get_LITTLE_())) toBitStringWithLong:flags])] autorelease];
  if (speed < ((EncodedDoubleValue *) nil_chk(speedEncoder_))->factor_ / 2) return [self setLowSpeedWithLong:flags withDouble:speed withBoolean:YES];
  if (speed > [self getMaxSpeed]) speed = [self getMaxSpeed];
  return [((EncodedDoubleValue *) nil_chk(reverseSpeedEncoder_)) setDoubleValueWithLong:flags withDouble:speed];
}

- (jlong)handleSpeedWithReaderWay:(ReaderWay *)way
                       withDouble:(jdouble)speed
                         withLong:(jlong)flags {
  flags = [super handleSpeedWithReaderWay:way withDouble:speed withLong:flags];
  if ([self isBackwardWithLong:flags]) flags = [self setReverseSpeedWithLong:flags withDouble:speed];
  if ([self isForwardWithLong:flags]) flags = [self setSpeedWithLong:flags withDouble:speed];
  return flags;
}

- (jlong)setLowSpeedWithLong:(jlong)flags
                  withDouble:(jdouble)speed
                 withBoolean:(jboolean)reverse {
  if (reverse) return [self setBoolWithLong:[((EncodedDoubleValue *) nil_chk(reverseSpeedEncoder_)) setDoubleValueWithLong:flags withDouble:0] withInt:AbstractFlagEncoder_K_BACKWARD withBoolean:NO];
  return [self setBoolWithLong:[((EncodedDoubleValue *) nil_chk(speedEncoder_)) setDoubleValueWithLong:flags withDouble:0] withInt:AbstractFlagEncoder_K_FORWARD withBoolean:NO];
}

- (jlong)flagsDefaultWithBoolean:(jboolean)forward
                     withBoolean:(jboolean)backward {
  jlong flags = [super flagsDefaultWithBoolean:forward withBoolean:backward];
  if (backward) return [((EncodedDoubleValue *) nil_chk(reverseSpeedEncoder_)) setDefaultValueWithLong:flags];
  return flags;
}

- (jlong)setPropertiesWithDouble:(jdouble)speed
                     withBoolean:(jboolean)forward
                     withBoolean:(jboolean)backward {
  jlong flags = [super setPropertiesWithDouble:speed withBoolean:forward withBoolean:backward];
  if (backward) return [self setReverseSpeedWithLong:flags withDouble:speed];
  return flags;
}

- (jlong)reverseFlagsWithLong:(jlong)flags {
  flags = [super reverseFlagsWithLong:flags];
  jdouble otherValue = [((EncodedDoubleValue *) nil_chk(reverseSpeedEncoder_)) getDoubleValueWithLong:flags];
  flags = [self setReverseSpeedWithLong:flags withDouble:[((EncodedDoubleValue *) nil_chk(speedEncoder_)) getDoubleValueWithLong:flags]];
  return [self setSpeedWithLong:flags withDouble:otherValue];
}

- (void)applyWayTagsWithReaderWay:(ReaderWay *)way
            withEdgeIteratorState:(id<EdgeIteratorState>)edge {
  PointList *pl = [((id<EdgeIteratorState>) nil_chk(edge)) fetchWayGeometryWithInt:3];
  if (![((PointList *) nil_chk(pl)) is3D]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"To support speed calculation based on elevation data it is necessary to enable import of it."] autorelease];
  jlong flags = [edge getFlags];
  if ([((ReaderWay *) nil_chk(way)) hasTagWithNSString:@"tunnel" withId:@"yes"] || [way hasTagWithNSString:@"bridge" withId:@"yes"] || [way hasTagWithNSString:@"highway" withId:@"steps"]) {
  }
  else {
    jdouble incEleSum = 0, incDist2DSum = 0;
    jdouble decEleSum = 0, decDist2DSum = 0;
    jdouble prevEle = [pl getElevationWithInt:0];
    jdouble fullDist2D = [edge getDistance];
    if (JavaLangDouble_isInfiniteWithDouble_(fullDist2D)) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$J", @"Infinite distance should not happen due to #435. way ID=", [way getId])] autorelease];
    if (fullDist2D < 1) return;
    jdouble eleDelta = [pl getElevationWithInt:[pl size] - 1] - prevEle;
    if (eleDelta > 0.1) {
      incEleSum = eleDelta;
      incDist2DSum = fullDist2D;
    }
    else if (eleDelta < -0.1) {
      decEleSum = -eleDelta;
      decDist2DSum = fullDist2D;
    }
    jdouble fwdIncline = incDist2DSum > 1 ? incEleSum / incDist2DSum : 0;
    jdouble fwdDecline = decDist2DSum > 1 ? decEleSum / decDist2DSum : 0;
    jdouble restDist2D = fullDist2D - incDist2DSum - decDist2DSum;
    jdouble maxSpeed = [self getHighwaySpeedWithNSString:@"cycleway"];
    if ([self isForwardWithLong:flags]) {
      jdouble speed = [self getSpeedWithLong:flags];
      jdouble fwdFaster = 1 + 2 * Helper_keepInWithDouble_withDouble_withDouble_(fwdDecline, 0, 0.2);
      fwdFaster = fwdFaster * fwdFaster;
      jdouble fwdSlower = 1 - 5 * Helper_keepInWithDouble_withDouble_withDouble_(fwdIncline, 0, 0.2);
      fwdSlower = fwdSlower * fwdSlower;
      speed = speed * (fwdSlower * incDist2DSum + fwdFaster * decDist2DSum + 1 * restDist2D) / fullDist2D;
      flags = [self setSpeedWithLong:flags withDouble:Helper_keepInWithDouble_withDouble_withDouble_(speed, BikeCommonFlagEncoder_PUSHING_SECTION_SPEED / 2, maxSpeed)];
    }
    if ([self isBackwardWithLong:flags]) {
      jdouble speedReverse = [self getReverseSpeedWithLong:flags];
      jdouble bwFaster = 1 + 2 * Helper_keepInWithDouble_withDouble_withDouble_(fwdIncline, 0, 0.2);
      bwFaster = bwFaster * bwFaster;
      jdouble bwSlower = 1 - 5 * Helper_keepInWithDouble_withDouble_withDouble_(fwdDecline, 0, 0.2);
      bwSlower = bwSlower * bwSlower;
      speedReverse = speedReverse * (bwFaster * incDist2DSum + bwSlower * decDist2DSum + 1 * restDist2D) / fullDist2D;
      flags = [self setReverseSpeedWithLong:flags withDouble:Helper_keepInWithDouble_withDouble_withDouble_(speedReverse, BikeCommonFlagEncoder_PUSHING_SECTION_SPEED / 2, maxSpeed)];
    }
  }
  [edge setFlagsWithLong:flags];
}

- (NSString *)description {
  return @"bike2";
}

- (void)dealloc {
  RELEASE_(reverseSpeedEncoder_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(Bike2WeightFlagEncoder *)other {
  [super copyAllFieldsTo:other];
  Bike2WeightFlagEncoder_set_reverseSpeedEncoder_(other, reverseSpeedEncoder_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "Bike2WeightFlagEncoder", NULL, 0x1, NULL },
    { "initWithNSString:", "Bike2WeightFlagEncoder", NULL, 0x1, NULL },
    { "initWithPMap:", "Bike2WeightFlagEncoder", NULL, 0x1, NULL },
    { "initWithInt:withDouble:withInt:", "Bike2WeightFlagEncoder", NULL, 0x1, NULL },
    { "getVersion", NULL, "I", 0x1, NULL },
    { "defineWayBitsWithInt:withInt:", "defineWayBits", "I", 0x1, NULL },
    { "getReverseSpeedWithLong:", "getReverseSpeed", "D", 0x1, NULL },
    { "setReverseSpeedWithLong:withDouble:", "setReverseSpeed", "J", 0x1, NULL },
    { "handleSpeedWithReaderWay:withDouble:withLong:", "handleSpeed", "J", 0x1, NULL },
    { "setLowSpeedWithLong:withDouble:withBoolean:", "setLowSpeed", "J", 0x4, NULL },
    { "flagsDefaultWithBoolean:withBoolean:", "flagsDefault", "J", 0x1, NULL },
    { "setPropertiesWithDouble:withBoolean:withBoolean:", "setProperties", "J", 0x1, NULL },
    { "reverseFlagsWithLong:", "reverseFlags", "J", 0x1, NULL },
    { "applyWayTagsWithReaderWay:withEdgeIteratorState:", "applyWayTags", "V", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "reverseSpeedEncoder_", NULL, 0x2, "Lcom.graphhopper.routing.util.EncodedDoubleValue;", NULL,  },
  };
  static const J2ObjcClassInfo _Bike2WeightFlagEncoder = { 1, "Bike2WeightFlagEncoder", "com.graphhopper.routing.util", NULL, 0x1, 15, methods, 1, fields, 0, NULL};
  return &_Bike2WeightFlagEncoder;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(Bike2WeightFlagEncoder)
