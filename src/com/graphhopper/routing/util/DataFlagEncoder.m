//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/reader/ReaderRelation.h"
#include "com/graphhopper/reader/ReaderWay.h"
#include "com/graphhopper/routing/util/AbstractFlagEncoder.h"
#include "com/graphhopper/routing/util/DataFlagEncoder.h"
#include "com/graphhopper/routing/util/EncodedDoubleValue.h"
#include "com/graphhopper/routing/util/EncodedValue.h"
#include "com/graphhopper/routing/util/FlagEncoder.h"
#include "com/graphhopper/routing/weighting/GenericWeighting.h"
#include "com/graphhopper/util/ConfigMap.h"
#include "com/graphhopper/util/EdgeIteratorState.h"
#include "com/graphhopper/util/PMap.h"
#include "java/lang/Double.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/HashMap.h"
#include "java/util/List.h"
#include "java/util/Map.h"
#include "java/util/Set.h"

__attribute__((unused)) static jboolean DataFlagEncoder_isBit0EmptyWithLong_(DataFlagEncoder *self, jlong flags);

@interface DataFlagEncoder () {
 @public
  id<JavaUtilMap> surfaceMap_;
  id<JavaUtilMap> highwayMap_;
  id<JavaUtilList> transportModeList_;
  id<JavaUtilMap> transportModeMap_;
  jint transportModeTunnelValue_;
  jint transportModeBridgeValue_;
  jlong bit0_;
  EncodedDoubleValue *carFwdMaxspeedEncoder_;
  EncodedDoubleValue *carBwdMaxspeedEncoder_;
  EncodedValue *surfaceEncoder_;
  EncodedValue *highwayEncoder_;
  EncodedValue *transportModeEncoder_;
}

/**
 @brief Interpret flags in forward direction if bit0 is empty.
 This method is used when accessing direction dependent values and avoid reverse flags, see #728.
 */
- (jboolean)isBit0EmptyWithLong:(jlong)flags;
@end

J2OBJC_FIELD_SETTER(DataFlagEncoder, surfaceMap_, id<JavaUtilMap>)
J2OBJC_FIELD_SETTER(DataFlagEncoder, highwayMap_, id<JavaUtilMap>)
J2OBJC_FIELD_SETTER(DataFlagEncoder, transportModeList_, id<JavaUtilList>)
J2OBJC_FIELD_SETTER(DataFlagEncoder, transportModeMap_, id<JavaUtilMap>)
J2OBJC_FIELD_SETTER(DataFlagEncoder, carFwdMaxspeedEncoder_, EncodedDoubleValue *)
J2OBJC_FIELD_SETTER(DataFlagEncoder, carBwdMaxspeedEncoder_, EncodedDoubleValue *)
J2OBJC_FIELD_SETTER(DataFlagEncoder, surfaceEncoder_, EncodedValue *)
J2OBJC_FIELD_SETTER(DataFlagEncoder, highwayEncoder_, EncodedValue *)
J2OBJC_FIELD_SETTER(DataFlagEncoder, transportModeEncoder_, EncodedValue *)

BOOL DataFlagEncoder_initialized = NO;

@implementation DataFlagEncoder

id<JavaUtilMap> DataFlagEncoder_DEFAULT_SPEEDS_;

- (instancetype)init {
  if (self = [super initWithInt:5 withDouble:5 withInt:0]) {
    DataFlagEncoder_setAndConsume_surfaceMap_(self, [[JavaUtilHashMap alloc] init]);
    DataFlagEncoder_setAndConsume_highwayMap_(self, [[JavaUtilHashMap alloc] init]);
    DataFlagEncoder_setAndConsume_transportModeList_(self, [[JavaUtilArrayList alloc] init]);
    DataFlagEncoder_setAndConsume_transportModeMap_(self, [[JavaUtilHashMap alloc] init]);
    maxPossibleSpeed_ = 140;
    id<JavaUtilList> highwayList = JavaUtilArrays_asListWithNSObjectArray_([IOSObjectArray arrayWithObjects:(id[]){ @"_default", @"motorway", @"motorway_link", @"motorroad", @"trunk", @"trunk_link", @"primary", @"primary_link", @"secondary", @"secondary_link", @"tertiary", @"tertiary_link", @"unclassified", @"residential", @"living_street", @"service", @"road", @"track", @"forestry", @"cycleway", @"steps", @"path", @"footway", @"pedestrian", @"ferry", @"shuttle_train" } count:26 type:NSString_class_()]);
    jint counter = 0;
    for (NSString * __strong hw in nil_chk(highwayList)) {
      [highwayMap_ putWithId:hw withId:JavaLangInteger_valueOfWithInt_(counter++)];
    }
    [transportModeList_ addAllWithJavaUtilCollection:JavaUtilArrays_asListWithNSObjectArray_([IOSObjectArray arrayWithObjects:(id[]){ @"_default", @"bridge", @"tunnel", @"ford", @"aerialway" } count:5 type:NSString_class_()])];
    counter = 0;
    for (NSString * __strong tm in transportModeList_) {
      [transportModeMap_ putWithId:tm withId:JavaLangInteger_valueOfWithInt_(counter++)];
    }
    transportModeTunnelValue_ = [((JavaLangInteger *) nil_chk([transportModeMap_ getWithId:@"tunnel"])) intValue];
    transportModeBridgeValue_ = [((JavaLangInteger *) nil_chk([transportModeMap_ getWithId:@"bridge"])) intValue];
    id<JavaUtilList> surfaceList = JavaUtilArrays_asListWithNSObjectArray_([IOSObjectArray arrayWithObjects:(id[]){ @"_default", @"asphalt", @"unpaved", @"paved", @"gravel", @"ground", @"dirt", @"grass", @"concrete", @"paving_stones", @"sand", @"compacted", @"cobblestone", @"mud", @"ice" } count:15 type:NSString_class_()]);
    counter = 0;
    for (NSString * __strong s in nil_chk(surfaceList)) {
      [surfaceMap_ putWithId:s withId:JavaLangInteger_valueOfWithInt_(counter++)];
    }
  }
  return self;
}

- (jint)defineWayBitsWithInt:(jint)index
                     withInt:(jint)shift {
  bit0_ = LShift64(1LL, shift);
  shift++;
  shift = [super defineWayBitsWithInt:index withInt:shift];
  DataFlagEncoder_setAndConsume_carFwdMaxspeedEncoder_(self, [[EncodedDoubleValue alloc] initWithNSString:@"car fwd maxspeed" withInt:shift withInt:speedBits_ withDouble:speedFactor_ withLong:0 withInt:maxPossibleSpeed_ withBoolean:YES]);
  shift += [carFwdMaxspeedEncoder_ getBits];
  DataFlagEncoder_setAndConsume_carBwdMaxspeedEncoder_(self, [[EncodedDoubleValue alloc] initWithNSString:@"car bwd maxspeed" withInt:shift withInt:speedBits_ withDouble:speedFactor_ withLong:0 withInt:maxPossibleSpeed_ withBoolean:YES]);
  shift += [carBwdMaxspeedEncoder_ getBits];
  DataFlagEncoder_setAndConsume_highwayEncoder_(self, [[EncodedValue alloc] initWithNSString:@"highway" withInt:shift withInt:5 withDouble:1 withLong:0 withInt:[((id<JavaUtilMap>) nil_chk(highwayMap_)) size] withBoolean:YES]);
  shift += [highwayEncoder_ getBits];
  DataFlagEncoder_setAndConsume_surfaceEncoder_(self, [[EncodedValue alloc] initWithNSString:@"surface" withInt:shift withInt:4 withDouble:1 withLong:0 withInt:[((id<JavaUtilMap>) nil_chk(surfaceMap_)) size] withBoolean:YES]);
  shift += [surfaceEncoder_ getBits];
  DataFlagEncoder_setAndConsume_transportModeEncoder_(self, [[EncodedValue alloc] initWithNSString:@"transport mode" withInt:shift withInt:3 withDouble:1 withLong:0 withInt:[((id<JavaUtilMap>) nil_chk(transportModeMap_)) size] withBoolean:YES]);
  shift += [transportModeEncoder_ getBits];
  return shift;
}

- (jlong)handleRelationTagsWithReaderRelation:(ReaderRelation *)relation
                                     withLong:(jlong)oldRelationFlags {
  return 0;
}

- (jlong)acceptWayWithReaderWay:(ReaderWay *)way {
  if ([self getHighwayValueWithReaderWay:way] == 0) return 0;
  return acceptBit_;
}

- (jint)getHighwayValueWithReaderWay:(ReaderWay *)way {
  NSString *highwayValue = [((ReaderWay *) nil_chk(way)) getTagWithNSString:@"highway"];
  JavaLangInteger *hwValue = [((id<JavaUtilMap>) nil_chk(highwayMap_)) getWithId:highwayValue];
  if ([way hasTagWithNSString:@"impassable" withId:@"yes"] || [way hasTagWithNSString:@"status" withId:@"impassable"]) hwValue = JavaLangInteger_valueOfWithInt_(0);
  if (hwValue == nil) {
    hwValue = JavaLangInteger_valueOfWithInt_(0);
    if ([way hasTagWithNSString:@"route" withJavaUtilSet:ferries_]) {
      NSString *motorcarTag = [way getTagWithNSString:@"motorcar"];
      if (motorcarTag == nil) motorcarTag = [way getTagWithNSString:@"motor_vehicle"];
      if ((motorcarTag == nil && ![way hasTagWithNSString:@"foot" withNSStringArray:[IOSObjectArray arrayWithLength:0 type:NSString_class_()]] && ![way hasTagWithNSString:@"bicycle" withNSStringArray:[IOSObjectArray arrayWithLength:0 type:NSString_class_()]]) || [@"yes" isEqual:motorcarTag]) hwValue = [highwayMap_ getWithId:@"ferry"];
    }
  }
  return [((JavaLangInteger *) nil_chk(hwValue)) intValue];
}

- (jlong)handleWayTagsWithReaderWay:(ReaderWay *)way
                           withLong:(jlong)allowed
                           withLong:(jlong)relationFlags {
  if (![self isAcceptWithLong:allowed]) return 0;
  @try {
    jint hwValue = [self getHighwayValueWithReaderWay:way];
    if (hwValue == 0) return 0;
    jlong flags = 0;
    if ([self isFerryWithLong:allowed]) {
      hwValue = [((JavaLangInteger *) nil_chk([((id<JavaUtilMap>) nil_chk(highwayMap_)) getWithId:@"ferry"])) intValue];
    }
    flags = [((EncodedValue *) nil_chk(highwayEncoder_)) setValueWithLong:0 withLong:hwValue];
    jdouble maxSpeed = [self parseSpeedWithNSString:[((ReaderWay *) nil_chk(way)) getTagWithNSString:@"maxspeed"]];
    jdouble fwdSpeed = [self parseSpeedWithNSString:[way getTagWithNSString:@"maxspeed:forward"]];
    if (fwdSpeed < 0 || (maxSpeed > 0 && maxSpeed < fwdSpeed)) fwdSpeed = maxSpeed;
    jdouble bwdSpeed = [self parseSpeedWithNSString:[way getTagWithNSString:@"maxspeed:backward"]];
    if (bwdSpeed < 0 || (maxSpeed > 0 && maxSpeed < bwdSpeed)) bwdSpeed = maxSpeed;
    if (fwdSpeed > 0) flags = [((EncodedDoubleValue *) nil_chk(carFwdMaxspeedEncoder_)) setDoubleValueWithLong:flags withDouble:fwdSpeed];
    if (bwdSpeed > 0) flags = [((EncodedDoubleValue *) nil_chk(carBwdMaxspeedEncoder_)) setDoubleValueWithLong:flags withDouble:bwdSpeed];
    NSString *surfaceValue = [way getTagWithNSString:@"surface"];
    JavaLangInteger *sValue = [((id<JavaUtilMap>) nil_chk(surfaceMap_)) getWithId:surfaceValue];
    if (sValue == nil) sValue = JavaLangInteger_valueOfWithInt_(0);
    flags = [((EncodedValue *) nil_chk(surfaceEncoder_)) setValueWithLong:flags withLong:[((JavaLangInteger *) nil_chk(sValue)) intValue]];
    jint tmValue = 0;
    for (NSString * __strong tm in nil_chk(transportModeList_)) {
      if ([way hasTagWithNSString:tm withNSStringArray:[IOSObjectArray arrayWithLength:0 type:NSString_class_()]]) {
        tmValue = [((JavaLangInteger *) nil_chk([((id<JavaUtilMap>) nil_chk(transportModeMap_)) getWithId:tm])) intValue];
        break;
      }
    }
    flags = [((EncodedValue *) nil_chk(transportModeEncoder_)) setValueWithLong:flags withLong:tmValue];
    jboolean isRoundabout = [way hasTagWithNSString:@"junction" withId:@"roundabout"];
    if (isRoundabout) flags = [self setBoolWithLong:flags withInt:FlagEncoder_K_ROUNDABOUT withBoolean:YES];
    jboolean isOneway = [way hasTagWithNSString:@"oneway" withJavaUtilSet:oneways_] || [way hasTagWithNSString:@"vehicle:backward" withNSStringArray:[IOSObjectArray arrayWithLength:0 type:NSString_class_()]] || [way hasTagWithNSString:@"vehicle:forward" withNSStringArray:[IOSObjectArray arrayWithLength:0 type:NSString_class_()]] || [way hasTagWithNSString:@"motor_vehicle:backward" withNSStringArray:[IOSObjectArray arrayWithLength:0 type:NSString_class_()]] || [way hasTagWithNSString:@"motor_vehicle:forward" withNSStringArray:[IOSObjectArray arrayWithLength:0 type:NSString_class_()]];
    if (isOneway || isRoundabout) {
      jboolean isBackward = [way hasTagWithNSString:@"oneway" withId:@"-1"] || [way hasTagWithNSString:@"vehicle:forward" withId:@"no"] || [way hasTagWithNSString:@"motor_vehicle:forward" withId:@"no"];
      if (isBackward) flags |= backwardBit_;
      else flags |= forwardBit_;
    }
    else flags |= directionBitMask_;
    if (!DataFlagEncoder_isBit0EmptyWithLong_(self, flags)) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"bit0 has to be empty on creation"] autorelease];
    return flags;
  }
  @catch (JavaLangException *ex) {
    @throw [[[JavaLangRuntimeException alloc] initWithNSString:JreStrcat("$$", @"Error while parsing way ", [((ReaderWay *) nil_chk(way)) description]) withJavaLangThrowable:ex] autorelease];
  }
}

- (jlong)reverseFlagsWithLong:(jlong)flags {
  return flags ^ bit0_;
}

- (jboolean)isBit0EmptyWithLong:(jlong)flags {
  return DataFlagEncoder_isBit0EmptyWithLong_(self, flags);
}

- (jint)getHighwayWithEdgeIteratorState:(id<EdgeIteratorState>)edge {
  return (jint) [((EncodedValue *) nil_chk(highwayEncoder_)) getValueWithLong:[((id<EdgeIteratorState>) nil_chk(edge)) getFlags]];
}

- (NSString *)getHighwayAsStringWithEdgeIteratorState:(id<EdgeIteratorState>)edge {
  jint val = [self getHighwayWithEdgeIteratorState:edge];
  for (id<JavaUtilMap_Entry> __strong e in nil_chk([((id<JavaUtilMap>) nil_chk(highwayMap_)) entrySet])) {
    if ([((JavaLangInteger *) nil_chk([((id<JavaUtilMap_Entry>) nil_chk(e)) getValue])) intValue] == val) return [e getKey];
  }
  return nil;
}

- (IOSDoubleArray *)getHighwaySpeedMapWithJavaUtilMap:(id<JavaUtilMap>)map {
  IOSDoubleArray *res = [IOSDoubleArray arrayWithLength:[((id<JavaUtilMap>) nil_chk(highwayMap_)) size]];
  for (id<JavaUtilMap_Entry> __strong e in nil_chk([((id<JavaUtilMap>) nil_chk(map)) entrySet])) {
    JavaLangInteger *integ = [highwayMap_ getWithId:[((id<JavaUtilMap_Entry>) nil_chk(e)) getKey]];
    if (integ == nil) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$$", @"Graph not prepared for highway=", [e getKey])] autorelease];
    if ([((JavaLangDouble *) nil_chk([e getValue])) doubleValue] < 0) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$@$$", @"Negative speed ", [e getValue], @" not allowed. highway=", [e getKey])] autorelease];
    *IOSDoubleArray_GetRef(res, [((JavaLangInteger *) nil_chk(integ)) intValue]) = [((JavaLangDouble *) nil_chk([e getValue])) doubleValue];
  }
  return res;
}

- (jint)getSurfaceWithEdgeIteratorState:(id<EdgeIteratorState>)edge {
  return (jint) [((EncodedValue *) nil_chk(surfaceEncoder_)) getValueWithLong:[((id<EdgeIteratorState>) nil_chk(edge)) getFlags]];
}

- (NSString *)getSurfaceAsStringWithEdgeIteratorState:(id<EdgeIteratorState>)edge {
  jint val = [self getSurfaceWithEdgeIteratorState:edge];
  for (id<JavaUtilMap_Entry> __strong e in nil_chk([((id<JavaUtilMap>) nil_chk(surfaceMap_)) entrySet])) {
    if ([((JavaLangInteger *) nil_chk([((id<JavaUtilMap_Entry>) nil_chk(e)) getValue])) intValue] == val) return [e getKey];
  }
  return nil;
}

- (jint)getTransportModeWithEdgeIteratorState:(id<EdgeIteratorState>)edge {
  return (jint) [((EncodedValue *) nil_chk(transportModeEncoder_)) getValueWithLong:[((id<EdgeIteratorState>) nil_chk(edge)) getFlags]];
}

- (jboolean)isTransportModeTunnelWithEdgeIteratorState:(id<EdgeIteratorState>)edge {
  return [((EncodedValue *) nil_chk(transportModeEncoder_)) getValueWithLong:[((id<EdgeIteratorState>) nil_chk(edge)) getFlags]] == self->transportModeTunnelValue_;
}

- (jboolean)isTransportModeBridgeWithEdgeIteratorState:(id<EdgeIteratorState>)edge {
  return [((EncodedValue *) nil_chk(transportModeEncoder_)) getValueWithLong:[((id<EdgeIteratorState>) nil_chk(edge)) getFlags]] == self->transportModeBridgeValue_;
}

- (NSString *)getTransportModeAsStringWithEdgeIteratorState:(id<EdgeIteratorState>)edge {
  jint val = [self getTransportModeWithEdgeIteratorState:edge];
  for (id<JavaUtilMap_Entry> __strong e in nil_chk([((id<JavaUtilMap>) nil_chk(transportModeMap_)) entrySet])) {
    if ([((JavaLangInteger *) nil_chk([((id<JavaUtilMap_Entry>) nil_chk(e)) getValue])) intValue] == val) return [e getKey];
  }
  return nil;
}

- (IOSDoubleArray *)getTransportModeMapWithJavaUtilMap:(id<JavaUtilMap>)map {
  IOSDoubleArray *res = [IOSDoubleArray arrayWithLength:[((id<JavaUtilMap>) nil_chk(transportModeMap_)) size]];
  for (id<JavaUtilMap_Entry> __strong e in nil_chk([((id<JavaUtilMap>) nil_chk(map)) entrySet])) {
    JavaLangInteger *integ = [transportModeMap_ getWithId:[((id<JavaUtilMap_Entry>) nil_chk(e)) getKey]];
    if (integ == nil) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$$", @"Graph not prepared for transport_mode=", [e getKey])] autorelease];
    if ([((JavaLangDouble *) nil_chk([e getValue])) doubleValue] < 0) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$@$$", @"Negative speed ", [e getValue], @" not allowed. transport_mode=", [e getKey])] autorelease];
    *IOSDoubleArray_GetRef(res, [((JavaLangInteger *) nil_chk(integ)) intValue]) = [((JavaLangDouble *) nil_chk([e getValue])) doubleValue];
  }
  return res;
}

- (jboolean)isRoundaboutWithEdgeIteratorState:(id<EdgeIteratorState>)edge {
  return ([((id<EdgeIteratorState>) nil_chk(edge)) getFlags] & roundaboutBit_) != 0;
}

- (jint)getAccessTypeWithNSString:(NSString *)accessStr {
  return 0;
}

- (jboolean)isForwardWithEdgeIteratorState:(id<EdgeIteratorState>)edge
                                   withInt:(jint)accessType {
  jlong flags = [((id<EdgeIteratorState>) nil_chk(edge)) getFlags];
  return (flags & (DataFlagEncoder_isBit0EmptyWithLong_(self, flags) ? forwardBit_ : backwardBit_)) != 0;
}

- (jboolean)isForwardWithLong:(jlong)flags {
  return (flags & (DataFlagEncoder_isBit0EmptyWithLong_(self, flags) ? forwardBit_ : backwardBit_)) != 0;
}

- (jboolean)isBackwardWithEdgeIteratorState:(id<EdgeIteratorState>)edge
                                    withInt:(jint)accessType {
  jlong flags = [((id<EdgeIteratorState>) nil_chk(edge)) getFlags];
  return (flags & (DataFlagEncoder_isBit0EmptyWithLong_(self, flags) ? backwardBit_ : forwardBit_)) != 0;
}

- (jboolean)isBackwardWithLong:(jlong)flags {
  return (flags & (DataFlagEncoder_isBit0EmptyWithLong_(self, flags) ? backwardBit_ : forwardBit_)) != 0;
}

- (jdouble)getMaxspeedWithEdgeIteratorState:(id<EdgeIteratorState>)edge
                                    withInt:(jint)accessType
                                withBoolean:(jboolean)reverse {
  jlong flags = [((id<EdgeIteratorState>) nil_chk(edge)) getFlags];
  if (!DataFlagEncoder_isBit0EmptyWithLong_(self, flags)) reverse = !reverse;
  jdouble val;
  if (reverse) val = [((EncodedDoubleValue *) nil_chk(carBwdMaxspeedEncoder_)) getDoubleValueWithLong:flags];
  else val = [((EncodedDoubleValue *) nil_chk(carFwdMaxspeedEncoder_)) getDoubleValueWithLong:flags];
  if (val < 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$I$Z", @"maxspeed cannot be negative, edge:", [edge getEdge], @", access type", accessType, @", reverse:", reverse)] autorelease];
  if (val == 0) return -1;
  return val;
}

- (jlong)flagsDefaultWithBoolean:(jboolean)forward
                     withBoolean:(jboolean)backward {
  return [self setAccessWithLong:0 withBoolean:forward withBoolean:backward];
}

- (jlong)setAccessWithLong:(jlong)flags
               withBoolean:(jboolean)forward
               withBoolean:(jboolean)backward {
  jboolean isForward = DataFlagEncoder_isBit0EmptyWithLong_(self, flags);
  if (!isForward) {
    jboolean tmp = forward;
    forward = backward;
    backward = tmp;
  }
  flags = forward ? flags | forwardBit_ : flags & ~forwardBit_;
  flags = backward ? flags | backwardBit_ : flags & ~backwardBit_;
  return flags;
}

- (jlong)setSpeedWithLong:(jlong)flags
               withDouble:(jdouble)speed {
  @throw [[[JavaLangRuntimeException alloc] initWithNSString:@"do not call setSpeed"] autorelease];
}

- (jlong)setLowSpeedWithLong:(jlong)flags
                  withDouble:(jdouble)speed
                 withBoolean:(jboolean)reverse {
  @throw [[[JavaLangRuntimeException alloc] initWithNSString:@"do not call setLowSpeed"] autorelease];
}

- (jdouble)getSpeedWithLong:(jlong)flags {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Calculate speed via more customizable Weighting.calcMillis method"] autorelease];
}

- (jlong)setReverseSpeedWithLong:(jlong)flags
                      withDouble:(jdouble)speed {
  @throw [[[JavaLangRuntimeException alloc] initWithNSString:@"do not call setReverseSpeed"] autorelease];
}

- (jdouble)getReverseSpeedWithLong:(jlong)flags {
  @throw [[[JavaLangRuntimeException alloc] initWithNSString:@"do not call getReverseSpeed"] autorelease];
}

- (jlong)setPropertiesWithDouble:(jdouble)speed
                     withBoolean:(jboolean)forward
                     withBoolean:(jboolean)backward {
  @throw [[[JavaLangRuntimeException alloc] initWithNSString:@"do not call setProperties"] autorelease];
}

- (jdouble)getMaxSpeedWithReaderWay:(ReaderWay *)way {
  @throw [[[JavaLangRuntimeException alloc] initWithNSString:@"do not call getMaxSpeed(ReaderWay)"] autorelease];
}

- (jdouble)getMaxSpeed {
  @throw [[[JavaLangRuntimeException alloc] initWithNSString:@"do not call getMaxSpeed"] autorelease];
}

- (jdouble)getMaxPossibleSpeed {
  return maxPossibleSpeed_;
}

- (jboolean)supportsWithIOSClass:(IOSClass *)feature {
  jboolean ret = [super supportsWithIOSClass:feature];
  if (ret) return YES;
  return [ComGraphhopperRoutingWeightingGenericWeighting_class_() isAssignableFrom:feature];
}

- (jint)getVersion {
  return 1;
}

- (NSString *)description {
  return @"generic";
}

- (ConfigMap *)readStringMapWithPMap:(PMap *)weightingMap {
  id<JavaUtilMap> map = [[[JavaUtilHashMap alloc] init] autorelease];
  for (id<JavaUtilMap_Entry> __strong e in nil_chk([((id<JavaUtilMap>) nil_chk(DataFlagEncoder_DEFAULT_SPEEDS_)) entrySet])) {
    [map putWithId:[((id<JavaUtilMap_Entry>) nil_chk(e)) getKey] withId:JavaLangDouble_valueOfWithDouble_([((PMap *) nil_chk(weightingMap)) getDoubleWithNSString:JreStrcat("$$", @"highways.", [e getKey]) withDouble:[((JavaLangDouble *) nil_chk([e getValue])) doubleValue]])];
  }
  ConfigMap *cMap = [[[ConfigMap alloc] init] autorelease];
  [cMap putWithNSString:@"highways" withId:map];
  return cMap;
}

- (void)dealloc {
  RELEASE_(surfaceMap_);
  RELEASE_(highwayMap_);
  RELEASE_(transportModeList_);
  RELEASE_(transportModeMap_);
  RELEASE_(carFwdMaxspeedEncoder_);
  RELEASE_(carBwdMaxspeedEncoder_);
  RELEASE_(surfaceEncoder_);
  RELEASE_(highwayEncoder_);
  RELEASE_(transportModeEncoder_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(DataFlagEncoder *)other {
  [super copyAllFieldsTo:other];
  DataFlagEncoder_set_surfaceMap_(other, surfaceMap_);
  DataFlagEncoder_set_highwayMap_(other, highwayMap_);
  DataFlagEncoder_set_transportModeList_(other, transportModeList_);
  DataFlagEncoder_set_transportModeMap_(other, transportModeMap_);
  other->transportModeTunnelValue_ = transportModeTunnelValue_;
  other->transportModeBridgeValue_ = transportModeBridgeValue_;
  other->bit0_ = bit0_;
  DataFlagEncoder_set_carFwdMaxspeedEncoder_(other, carFwdMaxspeedEncoder_);
  DataFlagEncoder_set_carBwdMaxspeedEncoder_(other, carBwdMaxspeedEncoder_);
  DataFlagEncoder_set_surfaceEncoder_(other, surfaceEncoder_);
  DataFlagEncoder_set_highwayEncoder_(other, highwayEncoder_);
  DataFlagEncoder_set_transportModeEncoder_(other, transportModeEncoder_);
}

+ (void)initialize {
  if (self == [DataFlagEncoder class]) {
    JreStrongAssignAndConsume(&DataFlagEncoder_DEFAULT_SPEEDS_, nil, [[DataFlagEncoder_$1 alloc] init]);
    J2OBJC_SET_INITIALIZED(DataFlagEncoder)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "DataFlagEncoder", NULL, 0x1, NULL },
    { "defineWayBitsWithInt:withInt:", "defineWayBits", "I", 0x1, NULL },
    { "handleRelationTagsWithReaderRelation:withLong:", "handleRelationTags", "J", 0x1, NULL },
    { "acceptWayWithReaderWay:", "acceptWay", "J", 0x1, NULL },
    { "getHighwayValueWithReaderWay:", "getHighwayValue", "I", 0x0, NULL },
    { "handleWayTagsWithReaderWay:withLong:withLong:", "handleWayTags", "J", 0x1, NULL },
    { "reverseFlagsWithLong:", "reverseFlags", "J", 0x1, NULL },
    { "isBit0EmptyWithLong:", "isBit0Empty", "Z", 0x2, NULL },
    { "getHighwayWithEdgeIteratorState:", "getHighway", "I", 0x1, NULL },
    { "getHighwayAsStringWithEdgeIteratorState:", "getHighwayAsString", "Ljava.lang.String;", 0x1, NULL },
    { "getHighwaySpeedMapWithJavaUtilMap:", "getHighwaySpeedMap", "[D", 0x1, NULL },
    { "getSurfaceWithEdgeIteratorState:", "getSurface", "I", 0x1, NULL },
    { "getSurfaceAsStringWithEdgeIteratorState:", "getSurfaceAsString", "Ljava.lang.String;", 0x1, NULL },
    { "getTransportModeWithEdgeIteratorState:", "getTransportMode", "I", 0x1, NULL },
    { "isTransportModeTunnelWithEdgeIteratorState:", "isTransportModeTunnel", "Z", 0x1, NULL },
    { "isTransportModeBridgeWithEdgeIteratorState:", "isTransportModeBridge", "Z", 0x1, NULL },
    { "getTransportModeAsStringWithEdgeIteratorState:", "getTransportModeAsString", "Ljava.lang.String;", 0x1, NULL },
    { "getTransportModeMapWithJavaUtilMap:", "getTransportModeMap", "[D", 0x1, NULL },
    { "isRoundaboutWithEdgeIteratorState:", "isRoundabout", "Z", 0x1, NULL },
    { "getAccessTypeWithNSString:", "getAccessType", "I", 0x1, NULL },
    { "isForwardWithEdgeIteratorState:withInt:", "isForward", "Z", 0x11, NULL },
    { "isForwardWithLong:", "isForward", "Z", 0x11, NULL },
    { "isBackwardWithEdgeIteratorState:withInt:", "isBackward", "Z", 0x11, NULL },
    { "isBackwardWithLong:", "isBackward", "Z", 0x11, NULL },
    { "getMaxspeedWithEdgeIteratorState:withInt:withBoolean:", "getMaxspeed", "D", 0x1, NULL },
    { "flagsDefaultWithBoolean:withBoolean:", "flagsDefault", "J", 0x1, NULL },
    { "setAccessWithLong:withBoolean:withBoolean:", "setAccess", "J", 0x1, NULL },
    { "setSpeedWithLong:withDouble:", "setSpeed", "J", 0x1, NULL },
    { "setLowSpeedWithLong:withDouble:withBoolean:", "setLowSpeed", "J", 0x4, NULL },
    { "getSpeedWithLong:", "getSpeed", "D", 0x1, NULL },
    { "setReverseSpeedWithLong:withDouble:", "setReverseSpeed", "J", 0x1, NULL },
    { "getReverseSpeedWithLong:", "getReverseSpeed", "D", 0x1, NULL },
    { "setPropertiesWithDouble:withBoolean:withBoolean:", "setProperties", "J", 0x1, NULL },
    { "getMaxSpeedWithReaderWay:", "getMaxSpeed", "D", 0x4, NULL },
    { "getMaxSpeed", NULL, "D", 0x1, NULL },
    { "getMaxPossibleSpeed", NULL, "D", 0x1, NULL },
    { "supportsWithIOSClass:", "supports", "Z", 0x1, NULL },
    { "getVersion", NULL, "I", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "readStringMapWithPMap:", "readStringMap", "Lcom.graphhopper.util.ConfigMap;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "DEFAULT_SPEEDS_", NULL, 0x1a, "Ljava.util.Map;", &DataFlagEncoder_DEFAULT_SPEEDS_,  },
    { "surfaceMap_", NULL, 0x12, "Ljava.util.Map;", NULL,  },
    { "highwayMap_", NULL, 0x12, "Ljava.util.Map;", NULL,  },
    { "transportModeList_", NULL, 0x12, "Ljava.util.List;", NULL,  },
    { "transportModeMap_", NULL, 0x12, "Ljava.util.Map;", NULL,  },
    { "transportModeTunnelValue_", NULL, 0x12, "I", NULL,  },
    { "transportModeBridgeValue_", NULL, 0x12, "I", NULL,  },
    { "bit0_", NULL, 0x2, "J", NULL,  },
    { "carFwdMaxspeedEncoder_", NULL, 0x2, "Lcom.graphhopper.routing.util.EncodedDoubleValue;", NULL,  },
    { "carBwdMaxspeedEncoder_", NULL, 0x2, "Lcom.graphhopper.routing.util.EncodedDoubleValue;", NULL,  },
    { "surfaceEncoder_", NULL, 0x2, "Lcom.graphhopper.routing.util.EncodedValue;", NULL,  },
    { "highwayEncoder_", NULL, 0x2, "Lcom.graphhopper.routing.util.EncodedValue;", NULL,  },
    { "transportModeEncoder_", NULL, 0x2, "Lcom.graphhopper.routing.util.EncodedValue;", NULL,  },
  };
  static const J2ObjcClassInfo _DataFlagEncoder = { 1, "DataFlagEncoder", "com.graphhopper.routing.util", NULL, 0x1, 40, methods, 13, fields, 0, NULL};
  return &_DataFlagEncoder;
}

@end

jboolean DataFlagEncoder_isBit0EmptyWithLong_(DataFlagEncoder *self, jlong flags) {
  return (flags & self->bit0_) == 0;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(DataFlagEncoder)

@implementation DataFlagEncoder_$1

- (instancetype)init {
  if (self = [super init]) {
    {
      [self putWithId:@"motorway" withId:JavaLangDouble_valueOfWithDouble_(100.0)];
      [self putWithId:@"motorway_link" withId:JavaLangDouble_valueOfWithDouble_(70.0)];
      [self putWithId:@"motorroad" withId:JavaLangDouble_valueOfWithDouble_(90.0)];
      [self putWithId:@"trunk" withId:JavaLangDouble_valueOfWithDouble_(70.0)];
      [self putWithId:@"trunk_link" withId:JavaLangDouble_valueOfWithDouble_(65.0)];
      [self putWithId:@"primary" withId:JavaLangDouble_valueOfWithDouble_(65.0)];
      [self putWithId:@"primary_link" withId:JavaLangDouble_valueOfWithDouble_(60.0)];
      [self putWithId:@"secondary" withId:JavaLangDouble_valueOfWithDouble_(60.0)];
      [self putWithId:@"secondary_link" withId:JavaLangDouble_valueOfWithDouble_(50.0)];
      [self putWithId:@"tertiary" withId:JavaLangDouble_valueOfWithDouble_(50.0)];
      [self putWithId:@"tertiary_link" withId:JavaLangDouble_valueOfWithDouble_(40.0)];
      [self putWithId:@"unclassified" withId:JavaLangDouble_valueOfWithDouble_(30.0)];
      [self putWithId:@"residential" withId:JavaLangDouble_valueOfWithDouble_(30.0)];
      [self putWithId:@"living_street" withId:JavaLangDouble_valueOfWithDouble_(5.0)];
      [self putWithId:@"service" withId:JavaLangDouble_valueOfWithDouble_(20.0)];
      [self putWithId:@"road" withId:JavaLangDouble_valueOfWithDouble_(20.0)];
      [self putWithId:@"forestry" withId:JavaLangDouble_valueOfWithDouble_(15.0)];
      [self putWithId:@"track" withId:JavaLangDouble_valueOfWithDouble_(15.0)];
    }
  }
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", NULL, NULL, 0x0, NULL },
  };
  static const char *superclass_type_args[] = {"Ljava.lang.String;", "Ljava.lang.Double;"};
  static const J2ObjcClassInfo _DataFlagEncoder_$1 = { 1, "$1", "com.graphhopper.routing.util", "DataFlagEncoder", 0x8000, 1, methods, 0, NULL, 2, superclass_type_args};
  return &_DataFlagEncoder_$1;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(DataFlagEncoder_$1)
