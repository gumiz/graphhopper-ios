//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/reader/ReaderNode.h"
#include "com/graphhopper/reader/ReaderRelation.h"
#include "com/graphhopper/reader/ReaderWay.h"
#include "com/graphhopper/routing/util/AbstractFlagEncoder.h"
#include "com/graphhopper/routing/util/EncodingManager.h"
#include "com/graphhopper/routing/util/FlagEncoder.h"
#include "com/graphhopper/routing/util/FlagEncoderFactory.h"
#include "com/graphhopper/routing/weighting/TurnWeighting.h"
#include "com/graphhopper/storage/Directory.h"
#include "com/graphhopper/storage/RAMDirectory.h"
#include "com/graphhopper/storage/StorableProperties.h"
#include "com/graphhopper/util/EdgeIteratorState.h"
#include "com/graphhopper/util/PMap.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/StringBuilder.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/List.h"

__attribute__((unused)) static void EncodingManager_registerEncoderWithAbstractFlagEncoder_(EncodingManager *self, AbstractFlagEncoder *encoder);
__attribute__((unused)) static id<FlagEncoder> EncodingManager_getEncoderWithNSString_withBoolean_(EncodingManager *self, NSString *name, jboolean throwExc);

@interface EncodingManager () {
 @public
  id<JavaUtilList> edgeEncoders_;
  jint bitsForEdgeFlags_;
  jint bitsForTurnFlags_;
  jint nextWayBit_;
  jint nextNodeBit_;
  jint nextRelBit_;
  jint nextTurnBit_;
  jboolean enableInstructions_;
  NSString *preferredLanguage_;
}

- (void)registerEncoderWithAbstractFlagEncoder:(AbstractFlagEncoder *)encoder;

- (id<FlagEncoder>)getEncoderWithNSString:(NSString *)name
                              withBoolean:(jboolean)throwExc;
@end

J2OBJC_FIELD_SETTER(EncodingManager, edgeEncoders_, id<JavaUtilList>)
J2OBJC_FIELD_SETTER(EncodingManager, preferredLanguage_, NSString *)

@implementation EncodingManager

NSString * EncodingManager_ERR_ = @"Encoders are requesting %s bits, more than %s bits of %s flags. ";
NSString * EncodingManager_WAY_ERR_ = @"Decrease the number of vehicles or increase the flags to take long via graph.bytes_for_flags=8";

- (instancetype)initWithNSString:(NSString *)flagEncodersStr {
  return [self initEncodingManagerWithNSString:flagEncodersStr withInt:4];
}

- (instancetype)initEncodingManagerWithNSString:(NSString *)flagEncodersStr
                                        withInt:(jint)bytesForEdgeFlags {
  return [self initEncodingManagerWithFlagEncoderFactory:FlagEncoderFactory_get_DEFAULT_() withNSString:flagEncodersStr withInt:bytesForEdgeFlags];
}

- (instancetype)initWithNSString:(NSString *)flagEncodersStr
                         withInt:(jint)bytesForEdgeFlags {
  return [self initEncodingManagerWithNSString:flagEncodersStr withInt:bytesForEdgeFlags];
}

- (instancetype)initEncodingManagerWithFlagEncoderFactory:(id<FlagEncoderFactory>)factory
                                             withNSString:(NSString *)flagEncodersStr
                                                  withInt:(jint)bytesForEdgeFlags {
  return [self initEncodingManagerWithJavaUtilList:EncodingManager_parseEncoderStringWithFlagEncoderFactory_withNSString_(factory, flagEncodersStr) withInt:bytesForEdgeFlags];
}

- (instancetype)initWithFlagEncoderFactory:(id<FlagEncoderFactory>)factory
                              withNSString:(NSString *)flagEncodersStr
                                   withInt:(jint)bytesForEdgeFlags {
  return [self initEncodingManagerWithFlagEncoderFactory:factory withNSString:flagEncodersStr withInt:bytesForEdgeFlags];
}

- (instancetype)initWithFlagEncoderArray:(IOSObjectArray *)flagEncoders {
  return [self initEncodingManagerWithJavaUtilList:JavaUtilArrays_asListWithNSObjectArray_(flagEncoders)];
}

- (instancetype)initEncodingManagerWithJavaUtilList:(id<JavaUtilList>)flagEncoders {
  return [self initEncodingManagerWithJavaUtilList:flagEncoders withInt:4];
}

- (instancetype)initWithJavaUtilList:(id<JavaUtilList>)flagEncoders {
  return [self initEncodingManagerWithJavaUtilList:flagEncoders];
}

- (instancetype)initEncodingManagerWithJavaUtilList:(id<JavaUtilList>)flagEncoders
                                            withInt:(jint)bytesForEdgeFlags {
  if (self = [super init]) {
    EncodingManager_setAndConsume_edgeEncoders_(self, [[JavaUtilArrayList alloc] init]);
    bitsForTurnFlags_ = 8 * 4;
    nextWayBit_ = 0;
    nextNodeBit_ = 0;
    nextRelBit_ = 0;
    nextTurnBit_ = 0;
    enableInstructions_ = YES;
    EncodingManager_set_preferredLanguage_(self, @"");
    if (bytesForEdgeFlags != 4 && bytesForEdgeFlags != 8) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"For 'edge flags' currently only 4 or 8 bytes supported"] autorelease];
    self->bitsForEdgeFlags_ = bytesForEdgeFlags * 8;
    for (id<FlagEncoder> __strong flagEncoder in nil_chk(flagEncoders)) {
      EncodingManager_registerEncoderWithAbstractFlagEncoder_(self, (AbstractFlagEncoder *) check_class_cast(flagEncoder, [AbstractFlagEncoder class]));
    }
    if ([edgeEncoders_ isEmpty]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"No vehicles found"] autorelease];
  }
  return self;
}

- (instancetype)initWithJavaUtilList:(id<JavaUtilList>)flagEncoders
                             withInt:(jint)bytesForEdgeFlags {
  return [self initEncodingManagerWithJavaUtilList:flagEncoders withInt:bytesForEdgeFlags];
}

+ (id<JavaUtilList>)parseEncoderStringWithFlagEncoderFactory:(id<FlagEncoderFactory>)factory
                                                withNSString:(NSString *)encoderList {
  return EncodingManager_parseEncoderStringWithFlagEncoderFactory_withNSString_(factory, encoderList);
}

+ (NSString *)fixWayNameWithNSString:(NSString *)str {
  return EncodingManager_fixWayNameWithNSString_(str);
}

+ (EncodingManager *)createWithFlagEncoderFactory:(id<FlagEncoderFactory>)factory
                                     withNSString:(NSString *)ghLoc {
  return EncodingManager_createWithFlagEncoderFactory_withNSString_(factory, ghLoc);
}

- (jint)getBytesForFlags {
  return bitsForEdgeFlags_ / 8;
}

- (void)registerEncoderWithAbstractFlagEncoder:(AbstractFlagEncoder *)encoder {
  EncodingManager_registerEncoderWithAbstractFlagEncoder_(self, encoder);
}

- (jboolean)supportsWithNSString:(NSString *)encoder {
  return EncodingManager_getEncoderWithNSString_withBoolean_(self, encoder, NO) != nil;
}

- (id<FlagEncoder>)getEncoderWithNSString:(NSString *)name {
  return EncodingManager_getEncoderWithNSString_withBoolean_(self, name, YES);
}

- (id<FlagEncoder>)getEncoderWithNSString:(NSString *)name
                              withBoolean:(jboolean)throwExc {
  return EncodingManager_getEncoderWithNSString_withBoolean_(self, name, throwExc);
}

- (jlong)acceptWayWithReaderWay:(ReaderWay *)way {
  jlong includeWay = 0;
  for (AbstractFlagEncoder * __strong encoder in nil_chk(edgeEncoders_)) {
    includeWay |= [((AbstractFlagEncoder *) nil_chk(encoder)) acceptWayWithReaderWay:way];
  }
  return includeWay;
}

- (jlong)handleRelationTagsWithReaderRelation:(ReaderRelation *)relation
                                     withLong:(jlong)oldRelationFlags {
  jlong flags = 0;
  for (AbstractFlagEncoder * __strong encoder in nil_chk(edgeEncoders_)) {
    flags |= [((AbstractFlagEncoder *) nil_chk(encoder)) handleRelationTagsWithReaderRelation:relation withLong:oldRelationFlags];
  }
  return flags;
}

- (jlong)handleWayTagsWithReaderWay:(ReaderWay *)way
                           withLong:(jlong)includeWay
                           withLong:(jlong)relationFlags {
  jlong flags = 0;
  for (AbstractFlagEncoder * __strong encoder in nil_chk(edgeEncoders_)) {
    flags |= [encoder handleWayTagsWithReaderWay:way withLong:includeWay withLong:relationFlags & [((AbstractFlagEncoder *) nil_chk(encoder)) getRelBitMask]];
  }
  return flags;
}

- (NSString *)description {
  JavaLangStringBuilder *str = [[[JavaLangStringBuilder alloc] init] autorelease];
  for (id<FlagEncoder> __strong encoder in nil_chk(edgeEncoders_)) {
    if ([str sequenceLength] > 0) [str appendWithNSString:@","];
    [str appendWithNSString:[((id<FlagEncoder>) nil_chk(encoder)) description]];
  }
  return [str description];
}

- (NSString *)toDetailsString {
  JavaLangStringBuilder *str = [[[JavaLangStringBuilder alloc] init] autorelease];
  for (AbstractFlagEncoder * __strong encoder in nil_chk(edgeEncoders_)) {
    if ([str sequenceLength] > 0) [str appendWithNSString:@","];
    [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([str appendWithNSString:[((AbstractFlagEncoder *) nil_chk(encoder)) description]])) appendWithNSString:@"|"])) appendWithNSString:[encoder getPropertiesString]])) appendWithNSString:@"|version="])) appendWithInt:[encoder getVersion]];
  }
  return [str description];
}

- (jlong)flagsDefaultWithBoolean:(jboolean)forward
                     withBoolean:(jboolean)backward {
  jlong flags = 0;
  for (AbstractFlagEncoder * __strong encoder in nil_chk(edgeEncoders_)) {
    flags |= [((AbstractFlagEncoder *) nil_chk(encoder)) flagsDefaultWithBoolean:forward withBoolean:backward];
  }
  return flags;
}

- (jlong)reverseFlagsWithLong:(jlong)flags {
  jint len = [((id<JavaUtilList>) nil_chk(edgeEncoders_)) size];
  for (jint i = 0; i < len; i++) {
    flags = [((AbstractFlagEncoder *) nil_chk([edgeEncoders_ getWithInt:i])) reverseFlagsWithLong:flags];
  }
  return flags;
}

- (NSUInteger)hash {
  jint hash_ = 5;
  hash_ = 53 * hash_ + (self->edgeEncoders_ != nil ? ((jint) [self->edgeEncoders_ hash]) : 0);
  return hash_;
}

- (jboolean)isEqual:(id)obj {
  if (obj == nil) return NO;
  if ([self getClass] != [nil_chk(obj) getClass]) return NO;
  EncodingManager *other = (EncodingManager *) check_class_cast(obj, [EncodingManager class]);
  if (self->edgeEncoders_ != other->edgeEncoders_ && (self->edgeEncoders_ == nil || ![self->edgeEncoders_ isEqual:other->edgeEncoders_])) {
    return NO;
  }
  return YES;
}

- (jlong)handleNodeTagsWithReaderNode:(ReaderNode *)node {
  jlong flags = 0;
  for (AbstractFlagEncoder * __strong encoder in nil_chk(edgeEncoders_)) {
    flags |= [((AbstractFlagEncoder *) nil_chk(encoder)) handleNodeTagsWithReaderNode:node];
  }
  return flags;
}

- (EncodingManager *)setEnableInstructionsWithBoolean:(jboolean)enableInstructions {
  self->enableInstructions_ = enableInstructions;
  return self;
}

- (EncodingManager *)setPreferredLanguageWithNSString:(NSString *)preferredLanguage {
  if (preferredLanguage == nil) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"preferred language cannot be null"] autorelease];
  EncodingManager_set_preferredLanguage_(self, preferredLanguage);
  return self;
}

- (void)applyWayTagsWithReaderWay:(ReaderWay *)way
            withEdgeIteratorState:(id<EdgeIteratorState>)edge {
  if (enableInstructions_) {
    NSString *name = @"";
    if (![((NSString *) nil_chk(preferredLanguage_)) isEmpty]) name = EncodingManager_fixWayNameWithNSString_([((ReaderWay *) nil_chk(way)) getTagWithNSString:JreStrcat("$$", @"name:", preferredLanguage_)]);
    if ([((NSString *) nil_chk(name)) isEmpty]) name = EncodingManager_fixWayNameWithNSString_([((ReaderWay *) nil_chk(way)) getTagWithNSString:@"name"]);
    NSString *refName = EncodingManager_fixWayNameWithNSString_([((ReaderWay *) nil_chk(way)) getTagWithNSString:@"ref"]);
    if (![((NSString *) nil_chk(refName)) isEmpty]) {
      if ([((NSString *) nil_chk(name)) isEmpty]) name = refName;
      else name = JreStrcat("$$", name, JreStrcat("$$", @", ", refName));
    }
    [((id<EdgeIteratorState>) nil_chk(edge)) setNameWithNSString:name];
  }
  for (AbstractFlagEncoder * __strong encoder in nil_chk(edgeEncoders_)) {
    [((AbstractFlagEncoder *) nil_chk(encoder)) applyWayTagsWithReaderWay:way withEdgeIteratorState:edge];
  }
}

- (id<JavaUtilList>)fetchEdgeEncoders {
  id<JavaUtilList> list = [[[JavaUtilArrayList alloc] init] autorelease];
  [list addAllWithJavaUtilCollection:edgeEncoders_];
  return list;
}

- (jboolean)needsTurnCostsSupport {
  for (id<FlagEncoder> __strong encoder in nil_chk(edgeEncoders_)) {
    if ([((id<FlagEncoder>) nil_chk(encoder)) supportsWithIOSClass:ComGraphhopperRoutingWeightingTurnWeighting_class_()]) return YES;
  }
  return NO;
}

- (void)dealloc {
  RELEASE_(edgeEncoders_);
  RELEASE_(preferredLanguage_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(EncodingManager *)other {
  [super copyAllFieldsTo:other];
  EncodingManager_set_edgeEncoders_(other, edgeEncoders_);
  other->bitsForEdgeFlags_ = bitsForEdgeFlags_;
  other->bitsForTurnFlags_ = bitsForTurnFlags_;
  other->nextWayBit_ = nextWayBit_;
  other->nextNodeBit_ = nextNodeBit_;
  other->nextRelBit_ = nextRelBit_;
  other->nextTurnBit_ = nextTurnBit_;
  other->enableInstructions_ = enableInstructions_;
  EncodingManager_set_preferredLanguage_(other, preferredLanguage_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithNSString:", "EncodingManager", NULL, 0x1, NULL },
    { "initWithNSString:withInt:", "EncodingManager", NULL, 0x1, NULL },
    { "initWithFlagEncoderFactory:withNSString:withInt:", "EncodingManager", NULL, 0x1, NULL },
    { "initWithFlagEncoderArray:", "EncodingManager", NULL, 0x81, NULL },
    { "initWithJavaUtilList:", "EncodingManager", NULL, 0x1, NULL },
    { "initWithJavaUtilList:withInt:", "EncodingManager", NULL, 0x1, NULL },
    { "parseEncoderStringWithFlagEncoderFactory:withNSString:", "parseEncoderString", "Ljava.util.List;", 0x8, NULL },
    { "fixWayNameWithNSString:", "fixWayName", "Ljava.lang.String;", 0x8, NULL },
    { "createWithFlagEncoderFactory:withNSString:", "create", "Lcom.graphhopper.routing.util.EncodingManager;", 0x9, NULL },
    { "getBytesForFlags", NULL, "I", 0x1, NULL },
    { "registerEncoderWithAbstractFlagEncoder:", "registerEncoder", "V", 0x2, NULL },
    { "supportsWithNSString:", "supports", "Z", 0x1, NULL },
    { "getEncoderWithNSString:", "getEncoder", "Lcom.graphhopper.routing.util.FlagEncoder;", 0x1, NULL },
    { "getEncoderWithNSString:withBoolean:", "getEncoder", "Lcom.graphhopper.routing.util.FlagEncoder;", 0x2, NULL },
    { "acceptWayWithReaderWay:", "acceptWay", "J", 0x1, NULL },
    { "handleRelationTagsWithReaderRelation:withLong:", "handleRelationTags", "J", 0x1, NULL },
    { "handleWayTagsWithReaderWay:withLong:withLong:", "handleWayTags", "J", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "toDetailsString", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "flagsDefaultWithBoolean:withBoolean:", "flagsDefault", "J", 0x1, NULL },
    { "reverseFlagsWithLong:", "reverseFlags", "J", 0x1, NULL },
    { "hash", "hashCode", "I", 0x1, NULL },
    { "isEqual:", "equals", "Z", 0x1, NULL },
    { "handleNodeTagsWithReaderNode:", "handleNodeTags", "J", 0x1, NULL },
    { "setEnableInstructionsWithBoolean:", "setEnableInstructions", "Lcom.graphhopper.routing.util.EncodingManager;", 0x1, NULL },
    { "setPreferredLanguageWithNSString:", "setPreferredLanguage", "Lcom.graphhopper.routing.util.EncodingManager;", 0x1, NULL },
    { "applyWayTagsWithReaderWay:withEdgeIteratorState:", "applyWayTags", "V", 0x1, NULL },
    { "fetchEdgeEncoders", NULL, "Ljava.util.List;", 0x1, NULL },
    { "needsTurnCostsSupport", NULL, "Z", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "ERR_", NULL, 0x1a, "Ljava.lang.String;", &EncodingManager_ERR_,  },
    { "WAY_ERR_", NULL, 0x1a, "Ljava.lang.String;", &EncodingManager_WAY_ERR_,  },
    { "edgeEncoders_", NULL, 0x12, "Ljava.util.List;", NULL,  },
    { "bitsForEdgeFlags_", NULL, 0x12, "I", NULL,  },
    { "bitsForTurnFlags_", NULL, 0x12, "I", NULL,  },
    { "nextWayBit_", NULL, 0x2, "I", NULL,  },
    { "nextNodeBit_", NULL, 0x2, "I", NULL,  },
    { "nextRelBit_", NULL, 0x2, "I", NULL,  },
    { "nextTurnBit_", NULL, 0x2, "I", NULL,  },
    { "enableInstructions_", NULL, 0x2, "Z", NULL,  },
    { "preferredLanguage_", NULL, 0x2, "Ljava.lang.String;", NULL,  },
  };
  static const J2ObjcClassInfo _EncodingManager = { 1, "EncodingManager", "com.graphhopper.routing.util", NULL, 0x1, 29, methods, 11, fields, 0, NULL};
  return &_EncodingManager;
}

@end

id<JavaUtilList> EncodingManager_parseEncoderStringWithFlagEncoderFactory_withNSString_(id<FlagEncoderFactory> factory, NSString *encoderList) {
  EncodingManager_init();
  if ([((NSString *) nil_chk(encoderList)) contains:@":"]) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"EncodingManager does no longer use reflection instantiate encoders directly."] autorelease];
  if (![encoderList isEqual:[encoderList lowercaseString]]) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$$", @"Since 0.7 EncodingManager does no longer accept upper case profiles: ", encoderList)] autorelease];
  IOSObjectArray *entries = [encoderList split:@","];
  id<JavaUtilList> resultEncoders = [[[JavaUtilArrayList alloc] init] autorelease];
  {
    IOSObjectArray *a__ = entries;
    NSString * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    NSString * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      NSString *entry_ = *b__++;
      entry_ = [((NSString *) nil_chk([((NSString *) nil_chk(entry_)) trim])) lowercaseString];
      if ([((NSString *) nil_chk(entry_)) isEmpty]) continue;
      NSString *entryVal = @"";
      if ([entry_ contains:@"|"]) {
        entryVal = entry_;
        entry_ = IOSObjectArray_Get(nil_chk([entry_ split:@"\\|"]), 0);
      }
      PMap *configuration = [[[PMap alloc] initWithNSString:entryVal] autorelease];
      id<FlagEncoder> fe = [((id<FlagEncoderFactory>) nil_chk(factory)) createFlagEncoderWithNSString:entry_ withPMap:configuration];
      if ([configuration hasWithNSString:@"version"] && [((id<FlagEncoder>) nil_chk(fe)) getVersion] != [configuration getIntWithNSString:@"version" withInt:-1]) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$$$J$I", @"Encoder ", entry_, @" was used in version ", [configuration getLongWithNSString:@"version" withLong:-1], @", but current version is ", [fe getVersion])] autorelease];
      [resultEncoders addWithId:fe];
    }
  }
  return resultEncoders;
}

NSString *EncodingManager_fixWayNameWithNSString_(NSString *str) {
  EncodingManager_init();
  if (str == nil) return @"";
  return [((NSString *) nil_chk(str)) replaceAll:@";[ ]*" withReplacement:@", "];
}

EncodingManager *EncodingManager_createWithFlagEncoderFactory_withNSString_(id<FlagEncoderFactory> factory, NSString *ghLoc) {
  EncodingManager_init();
  id<Directory> dir = [[[RAMDirectory alloc] initWithNSString:ghLoc withBoolean:YES] autorelease];
  StorableProperties *properties = [[[StorableProperties alloc] initWithDirectory:dir] autorelease];
  if (![properties loadExisting]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$$", @"Cannot load properties to fetch EncodingManager configuration at: ", [dir getLocation])] autorelease];
  [properties checkVersionsWithBoolean:NO];
  NSString *acceptStr = [properties getWithNSString:@"graph.flag_encoders"];
  if ([((NSString *) nil_chk(acceptStr)) isEmpty]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$$", @"EncodingManager was not configured. And no one was found in the graph: ", [dir getLocation])] autorelease];
  jint bytesForFlags = 4;
  if ([@"8" isEqual:[properties getWithNSString:@"graph.bytes_for_flags"]]) bytesForFlags = 8;
  return [[[EncodingManager alloc] initWithFlagEncoderFactory:factory withNSString:acceptStr withInt:bytesForFlags] autorelease];
}

void EncodingManager_registerEncoderWithAbstractFlagEncoder_(EncodingManager *self, AbstractFlagEncoder *encoder) {
  if ([((AbstractFlagEncoder *) nil_chk(encoder)) isRegistered]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$$$", @"You must not register a FlagEncoder (", [encoder description], @") twice!")] autorelease];
  for (id<FlagEncoder> __strong fe in nil_chk(self->edgeEncoders_)) {
    if ([((NSString *) nil_chk([((id<FlagEncoder>) nil_chk(fe)) description])) isEqual:[encoder description]]) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$$", @"Cannot register edge encoder. Name already exists: ", [fe description])] autorelease];
  }
  [encoder setRegisteredWithBoolean:YES];
  jint encoderCount = [self->edgeEncoders_ size];
  jint usedBits = [encoder defineNodeBitsWithInt:encoderCount withInt:self->nextNodeBit_];
  if (usedBits > self->bitsForEdgeFlags_) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:NSString_formatWithNSString_withNSObjectArray_(EncodingManager_ERR_, [IOSObjectArray arrayWithObjects:(id[]){ JavaLangInteger_valueOfWithInt_(usedBits), JavaLangInteger_valueOfWithInt_(self->bitsForEdgeFlags_), @"node" } count:3 type:NSObject_class_()])] autorelease];
  [encoder setNodeBitMaskWithInt:usedBits - self->nextNodeBit_ withInt:self->nextNodeBit_];
  self->nextNodeBit_ = usedBits;
  usedBits = [encoder defineWayBitsWithInt:encoderCount withInt:self->nextWayBit_];
  if (usedBits > self->bitsForEdgeFlags_) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$$", NSString_formatWithNSString_withNSObjectArray_(EncodingManager_ERR_, [IOSObjectArray arrayWithObjects:(id[]){ JavaLangInteger_valueOfWithInt_(usedBits), JavaLangInteger_valueOfWithInt_(self->bitsForEdgeFlags_), @"way" } count:3 type:NSObject_class_()]), EncodingManager_WAY_ERR_)] autorelease];
  [encoder setWayBitMaskWithInt:usedBits - self->nextWayBit_ withInt:self->nextWayBit_];
  self->nextWayBit_ = usedBits;
  usedBits = [encoder defineRelationBitsWithInt:encoderCount withInt:self->nextRelBit_];
  if (usedBits > self->bitsForEdgeFlags_) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:NSString_formatWithNSString_withNSObjectArray_(EncodingManager_ERR_, [IOSObjectArray arrayWithObjects:(id[]){ JavaLangInteger_valueOfWithInt_(usedBits), JavaLangInteger_valueOfWithInt_(self->bitsForEdgeFlags_), @"relation" } count:3 type:NSObject_class_()])] autorelease];
  [encoder setRelBitMaskWithInt:usedBits - self->nextRelBit_ withInt:self->nextRelBit_];
  self->nextRelBit_ = usedBits;
  usedBits = [encoder defineTurnBitsWithInt:encoderCount withInt:self->nextTurnBit_];
  if (usedBits > self->bitsForTurnFlags_) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:NSString_formatWithNSString_withNSObjectArray_(EncodingManager_ERR_, [IOSObjectArray arrayWithObjects:(id[]){ JavaLangInteger_valueOfWithInt_(usedBits), JavaLangInteger_valueOfWithInt_(self->bitsForTurnFlags_), @"turn" } count:3 type:NSObject_class_()])] autorelease];
  self->nextTurnBit_ = usedBits;
  [self->edgeEncoders_ addWithId:encoder];
}

id<FlagEncoder> EncodingManager_getEncoderWithNSString_withBoolean_(EncodingManager *self, NSString *name, jboolean throwExc) {
  for (id<FlagEncoder> __strong encoder in nil_chk(self->edgeEncoders_)) {
    if ([((NSString *) nil_chk(name)) equalsIgnoreCase:[((id<FlagEncoder>) nil_chk(encoder)) description]]) return encoder;
  }
  if (throwExc) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$$$$", @"Encoder for ", name, @" not found. Existing: ", [self toDetailsString])] autorelease];
  return nil;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EncodingManager)
