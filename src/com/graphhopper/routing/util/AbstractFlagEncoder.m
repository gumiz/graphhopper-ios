//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/reader/ConditionalTagInspector.h"
#include "com/graphhopper/reader/ReaderNode.h"
#include "com/graphhopper/reader/ReaderRelation.h"
#include "com/graphhopper/reader/ReaderWay.h"
#include "com/graphhopper/reader/osm/conditional/ConditionalOSMTagInspector.h"
#include "com/graphhopper/reader/osm/conditional/DateRangeParser.h"
#include "com/graphhopper/routing/util/AbstractFlagEncoder.h"
#include "com/graphhopper/routing/util/EncodedDoubleValue.h"
#include "com/graphhopper/routing/util/EncodedValue.h"
#include "com/graphhopper/routing/util/FlagEncoder.h"
#include "com/graphhopper/routing/weighting/TurnWeighting.h"
#include "com/graphhopper/util/BitUtil.h"
#include "com/graphhopper/util/DistanceCalcEarth.h"
#include "com/graphhopper/util/EdgeExplorer.h"
#include "com/graphhopper/util/EdgeIteratorState.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/InstructionAnnotation.h"
#include "com/graphhopper/util/PMap.h"
#include "com/graphhopper/util/Translation.h"
#include "java/lang/Double.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/Math.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/util/ArrayList.h"
#include "java/util/Calendar.h"
#include "java/util/HashSet.h"
#include "java/util/List.h"
#include "java/util/Set.h"
#include "org/slf4j/Logger.h"
#include "org/slf4j/LoggerFactory.h"

#pragma clang diagnostic ignored "-Wprotocol"

@interface AbstractFlagEncoder () {
 @public
  jint maxTurnCosts_;
  jlong nodeBitMask_;
  jlong wayBitMask_;
  jlong relBitMask_;
  EncodedValue *turnCostEncoder_;
  jlong turnRestrictionBit_;
  jboolean blockByDefault_;
  jboolean blockFords_;
  jboolean registered_;
  id<ConditionalTagInspector> conditionalTagInspector_;
}
@end

J2OBJC_FIELD_SETTER(AbstractFlagEncoder, turnCostEncoder_, EncodedValue *)
J2OBJC_FIELD_SETTER(AbstractFlagEncoder, conditionalTagInspector_, id<ConditionalTagInspector>)

BOOL AbstractFlagEncoder_initialized = NO;

@implementation AbstractFlagEncoder

id<OrgSlf4jLogger> AbstractFlagEncoder_logger_;

- (instancetype)initAbstractFlagEncoderWithPMap:(PMap *)properties {
  if (self = [super init]) {
    AbstractFlagEncoder_setAndConsume_restrictions_(self, [[JavaUtilArrayList alloc] initWithInt:5]);
    AbstractFlagEncoder_setAndConsume_intendedValues_(self, [[JavaUtilHashSet alloc] initWithInt:5]);
    AbstractFlagEncoder_setAndConsume_restrictedValues_(self, [[JavaUtilHashSet alloc] initWithInt:5]);
    AbstractFlagEncoder_setAndConsume_ferries_(self, [[JavaUtilHashSet alloc] initWithInt:5]);
    AbstractFlagEncoder_setAndConsume_oneways_(self, [[JavaUtilHashSet alloc] initWithInt:5]);
    AbstractFlagEncoder_setAndConsume_absoluteBarriers_(self, [[JavaUtilHashSet alloc] initWithInt:5]);
    AbstractFlagEncoder_setAndConsume_potentialBarriers_(self, [[JavaUtilHashSet alloc] initWithInt:5]);
    blockByDefault_ = YES;
    blockFords_ = YES;
    @throw [[[JavaLangRuntimeException alloc] initWithNSString:@"This method must be overridden in derived classes"] autorelease];
  }
  return self;
}

- (instancetype)initWithPMap:(PMap *)properties {
  return [self initAbstractFlagEncoderWithPMap:properties];
}

- (instancetype)initWithNSString:(NSString *)propertiesStr {
  return [self initAbstractFlagEncoderWithPMap:[[[PMap alloc] initWithNSString:propertiesStr] autorelease]];
}

- (instancetype)initWithInt:(jint)speedBits
                 withDouble:(jdouble)speedFactor
                    withInt:(jint)maxTurnCosts {
  if (self = [super init]) {
    AbstractFlagEncoder_setAndConsume_restrictions_(self, [[JavaUtilArrayList alloc] initWithInt:5]);
    AbstractFlagEncoder_setAndConsume_intendedValues_(self, [[JavaUtilHashSet alloc] initWithInt:5]);
    AbstractFlagEncoder_setAndConsume_restrictedValues_(self, [[JavaUtilHashSet alloc] initWithInt:5]);
    AbstractFlagEncoder_setAndConsume_ferries_(self, [[JavaUtilHashSet alloc] initWithInt:5]);
    AbstractFlagEncoder_setAndConsume_oneways_(self, [[JavaUtilHashSet alloc] initWithInt:5]);
    AbstractFlagEncoder_setAndConsume_absoluteBarriers_(self, [[JavaUtilHashSet alloc] initWithInt:5]);
    AbstractFlagEncoder_setAndConsume_potentialBarriers_(self, [[JavaUtilHashSet alloc] initWithInt:5]);
    blockByDefault_ = YES;
    blockFords_ = YES;
    self->maxTurnCosts_ = maxTurnCosts <= 0 ? 0 : maxTurnCosts;
    self->speedBits_ = speedBits;
    self->speedFactor_ = speedFactor;
    [oneways_ addWithId:@"yes"];
    [oneways_ addWithId:@"true"];
    [oneways_ addWithId:@"1"];
    [oneways_ addWithId:@"-1"];
    [ferries_ addWithId:@"shuttle_train"];
    [ferries_ addWithId:@"ferry"];
  }
  return self;
}

- (void)init__ {
  AbstractFlagEncoder_setAndConsume_conditionalTagInspector_(self, [[ComGraphhopperReaderOsmConditionalConditionalOSMTagInspector alloc] initWithId:ComGraphhopperReaderOsmConditionalDateRangeParser_createCalendar() withJavaUtilList:restrictions_ withJavaUtilSet:restrictedValues_ withJavaUtilSet:intendedValues_]);
}

- (jboolean)isRegistered {
  return registered_;
}

- (void)setRegisteredWithBoolean:(jboolean)registered {
  self->registered_ = registered;
}

- (void)setBlockByDefaultWithBoolean:(jboolean)blockByDefault {
  self->blockByDefault_ = blockByDefault;
}

- (jboolean)isBlockFords {
  return blockFords_;
}

- (void)setBlockFordsWithBoolean:(jboolean)blockFords {
  self->blockFords_ = blockFords;
}

- (id<ConditionalTagInspector>)getConditionalTagInspector {
  return conditionalTagInspector_;
}

- (void)setConditionalTagInspectorWithConditionalTagInspector:(id<ConditionalTagInspector>)conditionalTagInspector {
  AbstractFlagEncoder_set_conditionalTagInspector_(self, conditionalTagInspector);
}

- (jint)defineNodeBitsWithInt:(jint)index
                      withInt:(jint)shift {
  return shift;
}

- (jint)defineWayBitsWithInt:(jint)index
                     withInt:(jint)shift {
  forwardBit_ = LShift64(1LL, shift);
  backwardBit_ = LShift64(2LL, shift);
  directionBitMask_ = LShift64(3LL, shift);
  shift += 2;
  roundaboutBit_ = LShift64(1LL, shift);
  shift++;
  index *= 2;
  acceptBit_ = LShift64(1LL, index);
  ferryBit_ = LShift64(2LL, index);
  return shift;
}

- (jint)defineRelationBitsWithInt:(jint)index
                          withInt:(jint)shift {
  return shift;
}

- (jlong)handleRelationTagsWithReaderRelation:(ReaderRelation *)relation
                                     withLong:(jlong)oldRelationFlags {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (jlong)acceptWayWithReaderWay:(ReaderWay *)way {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (jlong)handleWayTagsWithReaderWay:(ReaderWay *)way
                           withLong:(jlong)allowed
                           withLong:(jlong)relationFlags {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (jlong)handleNodeTagsWithReaderNode:(ReaderNode *)node {
  if ([((ReaderNode *) nil_chk(node)) hasTagWithNSString:@"barrier" withJavaUtilSet:absoluteBarriers_]) return directionBitMask_;
  if ([node hasTagWithNSString:@"barrier" withJavaUtilSet:potentialBarriers_]) {
    jboolean locked = NO;
    if ([node hasTagWithNSString:@"locked" withId:@"yes"]) locked = YES;
    for (NSString * __strong res in nil_chk(restrictions_)) {
      if (!locked && [node hasTagWithNSString:res withJavaUtilSet:intendedValues_]) return 0;
      if ([node hasTagWithNSString:res withJavaUtilSet:restrictedValues_]) return directionBitMask_;
    }
    if (blockByDefault_) return directionBitMask_;
  }
  if (blockFords_ && ([node hasTagWithNSString:@"highway" withId:@"ford"] || [node hasTagWithNSString:@"ford" withNSStringArray:[IOSObjectArray arrayWithLength:0 type:NSString_class_()]]) && ![node hasTagWithJavaUtilList:restrictions_ withJavaUtilSet:intendedValues_] && ![node hasTagWithNSString:@"ford" withId:@"no"]) {
    return directionBitMask_;
  }
  return 0;
}

- (InstructionAnnotation *)getAnnotationWithLong:(jlong)flags
                                 withTranslation:(id<Translation>)tr {
  return InstructionAnnotation_get_EMPTY_();
}

- (jlong)reverseFlagsWithLong:(jlong)flags {
  jlong dir = flags & directionBitMask_;
  if (dir == directionBitMask_ || dir == 0) return flags;
  return flags ^ directionBitMask_;
}

- (jlong)flagsDefaultWithBoolean:(jboolean)forward
                     withBoolean:(jboolean)backward {
  jlong flags = [((EncodedDoubleValue *) nil_chk(speedEncoder_)) setDefaultValueWithLong:0];
  return [self setAccessWithLong:flags withBoolean:forward withBoolean:backward];
}

- (jlong)setAccessWithLong:(jlong)flags
               withBoolean:(jboolean)forward
               withBoolean:(jboolean)backward {
  return [self setBoolWithLong:[self setBoolWithLong:flags withInt:AbstractFlagEncoder_K_BACKWARD withBoolean:backward] withInt:AbstractFlagEncoder_K_FORWARD withBoolean:forward];
}

- (jlong)setSpeedWithLong:(jlong)flags
               withDouble:(jdouble)speed {
  if (speed < 0 || JavaLangDouble_isNaNWithDouble_(speed)) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$D$$", @"Speed cannot be negative or NaN: ", speed, @", flags:", [((BitUtil *) nil_chk(BitUtil_get_LITTLE_())) toBitStringWithLong:flags])] autorelease];
  if (speed < ((EncodedDoubleValue *) nil_chk(speedEncoder_))->factor_ / 2) return [self setLowSpeedWithLong:flags withDouble:speed withBoolean:NO];
  if (speed > [self getMaxSpeed]) speed = [self getMaxSpeed];
  return [speedEncoder_ setDoubleValueWithLong:flags withDouble:speed];
}

- (jlong)setLowSpeedWithLong:(jlong)flags
                  withDouble:(jdouble)speed
                 withBoolean:(jboolean)reverse {
  return [self setAccessWithLong:[((EncodedDoubleValue *) nil_chk(speedEncoder_)) setDoubleValueWithLong:flags withDouble:0] withBoolean:NO withBoolean:NO];
}

- (jdouble)getSpeedWithLong:(jlong)flags {
  jdouble speedVal = [((EncodedDoubleValue *) nil_chk(speedEncoder_)) getDoubleValueWithLong:flags];
  if (speedVal < 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$D", @"Speed was negative!? ", speedVal)] autorelease];
  return speedVal;
}

- (jlong)setReverseSpeedWithLong:(jlong)flags
                      withDouble:(jdouble)speed {
  return [self setSpeedWithLong:flags withDouble:speed];
}

- (jdouble)getReverseSpeedWithLong:(jlong)flags {
  return [self getSpeedWithLong:flags];
}

- (jlong)setPropertiesWithDouble:(jdouble)speed
                     withBoolean:(jboolean)forward
                     withBoolean:(jboolean)backward {
  return [self setAccessWithLong:[self setSpeedWithLong:0 withDouble:speed] withBoolean:forward withBoolean:backward];
}

- (jdouble)getMaxSpeed {
  return [((EncodedDoubleValue *) nil_chk(speedEncoder_)) getMaxValue];
}

- (jdouble)getMaxSpeedWithReaderWay:(ReaderWay *)way {
  jdouble maxSpeed = [self parseSpeedWithNSString:[((ReaderWay *) nil_chk(way)) getTagWithNSString:@"maxspeed"]];
  jdouble fwdSpeed = [self parseSpeedWithNSString:[way getTagWithNSString:@"maxspeed:forward"]];
  if (fwdSpeed >= 0 && (maxSpeed < 0 || fwdSpeed < maxSpeed)) maxSpeed = fwdSpeed;
  jdouble backSpeed = [self parseSpeedWithNSString:[way getTagWithNSString:@"maxspeed:backward"]];
  if (backSpeed >= 0 && (maxSpeed < 0 || backSpeed < maxSpeed)) maxSpeed = backSpeed;
  return maxSpeed;
}

- (NSUInteger)hash {
  jint hash_ = 7;
  hash_ = 61 * hash_ + (jint) self->directionBitMask_;
  hash_ = 61 * hash_ + ((jint) [((NSString *) nil_chk([self description])) hash]);
  return hash_;
}

- (jboolean)isEqual:(id)obj {
  if (obj == nil) return NO;
  AbstractFlagEncoder *other = (AbstractFlagEncoder *) check_class_cast(obj, [AbstractFlagEncoder class]);
  if (self->directionBitMask_ != ((AbstractFlagEncoder *) nil_chk(other))->directionBitMask_) return NO;
  return [((NSString *) nil_chk([self description])) isEqual:[other description]];
}

- (jdouble)parseSpeedWithNSString:(NSString *)str {
  if (Helper_isEmptyWithNSString_(str)) return -1;
  if ([@"none" isEqual:str]) return 140;
  if ([((NSString *) nil_chk(str)) hasSuffix:@":rural"] || [str hasSuffix:@":trunk"]) return 80;
  if ([str hasSuffix:@":urban"]) return 50;
  if ([str isEqual:@"walk"] || [str hasSuffix:@":living_street"]) return 6;
  @try {
    jint val;
    jint mpInteger = [str indexOfString:@"mp"];
    if (mpInteger > 0) {
      str = [((NSString *) nil_chk([str substring:0 endIndex:mpInteger])) trim];
      val = JavaLangInteger_parseIntWithNSString_(str);
      return val * DistanceCalcEarth_KM_MILE;
    }
    jint knotInteger = [((NSString *) nil_chk(str)) indexOfString:@"knots"];
    if (knotInteger > 0) {
      str = [((NSString *) nil_chk([str substring:0 endIndex:knotInteger])) trim];
      val = JavaLangInteger_parseIntWithNSString_(str);
      return val * 1.852;
    }
    jint kmInteger = [((NSString *) nil_chk(str)) indexOfString:@"km"];
    if (kmInteger > 0) {
      str = [((NSString *) nil_chk([str substring:0 endIndex:kmInteger])) trim];
    }
    else {
      kmInteger = [str indexOfString:@"kph"];
      if (kmInteger > 0) {
        str = [((NSString *) nil_chk([str substring:0 endIndex:kmInteger])) trim];
      }
    }
    return JavaLangInteger_parseIntWithNSString_(str);
  }
  @catch (JavaLangException *ex) {
    return -1;
  }
}

- (void)applyWayTagsWithReaderWay:(ReaderWay *)way
            withEdgeIteratorState:(id<EdgeIteratorState>)edge {
}

- (jdouble)getFerrySpeedWithReaderWay:(ReaderWay *)way
                           withDouble:(jdouble)unknownSpeed
                           withDouble:(jdouble)shortTripsSpeed
                           withDouble:(jdouble)longTripsSpeed {
  jlong duration = 0;
  @try {
    duration = JavaLangLong_parseLongWithNSString_([((ReaderWay *) nil_chk(way)) getTagWithNSString:@"duration:seconds"]);
  }
  @catch (JavaLangException *ex) {
  }
  jdouble durationInHours = duration / 60.0 / 60.0;
  if (durationInHours > 0) @try {
    NSNumber *estimatedLength = [((ReaderWay *) nil_chk(way)) getTagWithNSString:@"estimated_distance" withId:nil];
    if (estimatedLength != nil) {
      jdouble val = [estimatedLength doubleValue] / 1000;
      jdouble calculatedTripSpeed = val / durationInHours / 1.4;
      if (calculatedTripSpeed > 0.01) {
        if (JavaLangMath_roundWithDouble_(calculatedTripSpeed) > ((EncodedDoubleValue *) nil_chk(speedEncoder_))->factor_ / 2) {
          shortTripsSpeed = JavaLangMath_roundWithDouble_(calculatedTripSpeed);
          if (shortTripsSpeed > [self getMaxSpeed]) shortTripsSpeed = [self getMaxSpeed];
          longTripsSpeed = shortTripsSpeed;
        }
        else {
          shortTripsSpeed = speedEncoder_->factor_ / 2;
        }
      }
      else {
        [((id<OrgSlf4jLogger>) nil_chk(AbstractFlagEncoder_logger_)) warnWithNSString:JreStrcat("$J$$$J$", @"Unrealistic long duration ignored in way with way ID=", [way getId], @" : Duration tag value=", [way getTagWithNSString:@"duration"], @" (=", JavaLangMath_roundWithDouble_(duration / 60.0), @" minutes)")];
        durationInHours = 0;
      }
    }
  }
  @catch (JavaLangException *ex) {
  }
  if (durationInHours == 0) {
    return unknownSpeed;
  }
  else if (durationInHours > 1) {
    return longTripsSpeed;
  }
  else {
    return shortTripsSpeed;
  }
}

- (void)setWayBitMaskWithInt:(jint)usedBits
                     withInt:(jint)shift {
  wayBitMask_ = (LShift64(1LL, usedBits)) - 1;
  LShiftAssignLong(&wayBitMask_, shift);
}

- (jlong)getWayBitMask {
  return wayBitMask_;
}

- (void)setRelBitMaskWithInt:(jint)usedBits
                     withInt:(jint)shift {
  relBitMask_ = (LShift64(1LL, usedBits)) - 1;
  LShiftAssignLong(&relBitMask_, shift);
}

- (jlong)getRelBitMask {
  return relBitMask_;
}

- (void)setNodeBitMaskWithInt:(jint)usedBits
                      withInt:(jint)shift {
  nodeBitMask_ = (LShift64(1LL, usedBits)) - 1;
  LShiftAssignLong(&nodeBitMask_, shift);
}

- (jlong)getNodeBitMask {
  return nodeBitMask_;
}

- (jint)defineTurnBitsWithInt:(jint)index
                      withInt:(jint)shift {
  if (maxTurnCosts_ == 0) return shift;
  else if (maxTurnCosts_ == 1) {
    turnRestrictionBit_ = LShift64(1LL, shift);
    return shift + 1;
  }
  jint turnBits = Helper_countBitValueWithInt_(maxTurnCosts_);
  AbstractFlagEncoder_setAndConsume_turnCostEncoder_(self, [[AbstractFlagEncoder_$1 alloc] initWithNSString:@"TurnCost" withInt:shift withInt:turnBits withInt:1 withInt:0 withInt:maxTurnCosts_]);
  return shift + turnBits;
}

- (jboolean)isTurnRestrictedWithLong:(jlong)flags {
  if (maxTurnCosts_ == 0) return NO;
  else if (maxTurnCosts_ == 1) return (flags & turnRestrictionBit_) != 0;
  return [((EncodedValue *) nil_chk(turnCostEncoder_)) getValueWithLong:flags] == maxTurnCosts_;
}

- (jdouble)getTurnCostWithLong:(jlong)flags {
  if (maxTurnCosts_ == 0) return 0;
  else if (maxTurnCosts_ == 1) return ((flags & turnRestrictionBit_) == 0) ? 0 : JavaLangDouble_POSITIVE_INFINITY;
  jlong cost = [((EncodedValue *) nil_chk(turnCostEncoder_)) getValueWithLong:flags];
  if (cost == maxTurnCosts_) return JavaLangDouble_POSITIVE_INFINITY;
  return cost;
}

- (jlong)getTurnFlagsWithBoolean:(jboolean)restricted
                      withDouble:(jdouble)costs {
  if (maxTurnCosts_ == 0) return 0;
  else if (maxTurnCosts_ == 1) {
    if (costs != 0) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Only restrictions are supported"] autorelease];
    return restricted ? turnRestrictionBit_ : 0;
  }
  if (restricted) {
    if (costs != 0 || JavaLangDouble_isInfiniteWithDouble_(costs)) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Restricted turn can only have infinite costs (or use 0)"] autorelease];
  }
  else if (costs >= maxTurnCosts_) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Cost is too high. Or specifiy restricted == true"] autorelease];
  if (costs < 0) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Turn costs cannot be negative"] autorelease];
  if (costs >= maxTurnCosts_ || restricted) costs = maxTurnCosts_;
  return [((EncodedValue *) nil_chk(turnCostEncoder_)) setValueWithLong:0LL withLong:J2ObjCFpToInt(costs)];
}

- (jboolean)isFerryWithLong:(jlong)internalFlags {
  return (internalFlags & ferryBit_) != 0;
}

- (jboolean)isAcceptWithLong:(jlong)internalFlags {
  return (internalFlags & acceptBit_) != 0;
}

- (jboolean)isBackwardWithLong:(jlong)flags {
  return (flags & backwardBit_) != 0;
}

- (jboolean)isForwardWithLong:(jlong)flags {
  return (flags & forwardBit_) != 0;
}

- (jlong)setBoolWithLong:(jlong)flags
                 withInt:(jint)key
             withBoolean:(jboolean)value {
  switch (key) {
    case AbstractFlagEncoder_K_FORWARD:
    return value ? flags | forwardBit_ : flags & ~forwardBit_;
    case AbstractFlagEncoder_K_BACKWARD:
    return value ? flags | backwardBit_ : flags & ~backwardBit_;
    case FlagEncoder_K_ROUNDABOUT:
    return value ? flags | roundaboutBit_ : flags & ~roundaboutBit_;
    default:
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$I$", @"Unknown key ", key, @" for boolean value")] autorelease];
  }
}

- (jboolean)isBoolWithLong:(jlong)flags
                   withInt:(jint)key {
  switch (key) {
    case AbstractFlagEncoder_K_FORWARD:
    return [self isForwardWithLong:flags];
    case AbstractFlagEncoder_K_BACKWARD:
    return [self isBackwardWithLong:flags];
    case FlagEncoder_K_ROUNDABOUT:
    return (flags & roundaboutBit_) != 0;
    default:
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$I$", @"Unknown key ", key, @" for boolean value")] autorelease];
  }
}

- (jlong)setLongWithLong:(jlong)flags
                 withInt:(jint)key
                withLong:(jlong)value {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:JreStrcat("$I$", @"Unknown key ", key, @" for long value.")] autorelease];
}

- (jlong)getLongWithLong:(jlong)flags
                 withInt:(jint)key {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:JreStrcat("$I$", @"Unknown key ", key, @" for long value.")] autorelease];
}

- (jlong)setDoubleWithLong:(jlong)flags
                   withInt:(jint)key
                withDouble:(jdouble)value {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:JreStrcat("$I$", @"Unknown key ", key, @" for double value.")] autorelease];
}

- (jdouble)getDoubleWithLong:(jlong)flags
                     withInt:(jint)key {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:JreStrcat("$I$", @"Unknown key ", key, @" for double value.")] autorelease];
}

- (jdouble)applyMaxSpeedWithReaderWay:(ReaderWay *)way
                           withDouble:(jdouble)speed {
  jdouble maxSpeed = [self getMaxSpeedWithReaderWay:way];
  if (maxSpeed >= 0) {
    return maxSpeed * 0.9;
  }
  return speed;
}

- (NSString *)getPropertiesString {
  return JreStrcat("$D$I$Z", @"speed_factor=", speedFactor_, @"|speed_bits=", speedBits_, @"|turn_costs=", (maxTurnCosts_ > 0));
}

- (jboolean)supportsWithIOSClass:(IOSClass *)feature {
  if ([ComGraphhopperRoutingWeightingTurnWeighting_class_() isAssignableFrom:feature]) return maxTurnCosts_ > 0;
  return NO;
}

- (void)dealloc {
  RELEASE_(restrictions_);
  RELEASE_(intendedValues_);
  RELEASE_(restrictedValues_);
  RELEASE_(ferries_);
  RELEASE_(oneways_);
  RELEASE_(absoluteBarriers_);
  RELEASE_(potentialBarriers_);
  RELEASE_(speedEncoder_);
  RELEASE_(properties_);
  RELEASE_(edgeOutExplorer_);
  RELEASE_(edgeInExplorer_);
  RELEASE_(turnCostEncoder_);
  RELEASE_(conditionalTagInspector_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(AbstractFlagEncoder *)other {
  [super copyAllFieldsTo:other];
  AbstractFlagEncoder_set_restrictions_(other, restrictions_);
  AbstractFlagEncoder_set_intendedValues_(other, intendedValues_);
  AbstractFlagEncoder_set_restrictedValues_(other, restrictedValues_);
  AbstractFlagEncoder_set_ferries_(other, ferries_);
  AbstractFlagEncoder_set_oneways_(other, oneways_);
  AbstractFlagEncoder_set_absoluteBarriers_(other, absoluteBarriers_);
  AbstractFlagEncoder_set_potentialBarriers_(other, potentialBarriers_);
  other->speedBits_ = speedBits_;
  other->speedFactor_ = speedFactor_;
  other->maxTurnCosts_ = maxTurnCosts_;
  other->forwardBit_ = forwardBit_;
  other->backwardBit_ = backwardBit_;
  other->directionBitMask_ = directionBitMask_;
  other->roundaboutBit_ = roundaboutBit_;
  AbstractFlagEncoder_set_speedEncoder_(other, speedEncoder_);
  other->acceptBit_ = acceptBit_;
  other->ferryBit_ = ferryBit_;
  AbstractFlagEncoder_set_properties_(other, properties_);
  other->maxPossibleSpeed_ = maxPossibleSpeed_;
  AbstractFlagEncoder_set_edgeOutExplorer_(other, edgeOutExplorer_);
  AbstractFlagEncoder_set_edgeInExplorer_(other, edgeInExplorer_);
  other->nodeBitMask_ = nodeBitMask_;
  other->wayBitMask_ = wayBitMask_;
  other->relBitMask_ = relBitMask_;
  AbstractFlagEncoder_set_turnCostEncoder_(other, turnCostEncoder_);
  other->turnRestrictionBit_ = turnRestrictionBit_;
  other->blockByDefault_ = blockByDefault_;
  other->blockFords_ = blockFords_;
  other->registered_ = registered_;
  AbstractFlagEncoder_set_conditionalTagInspector_(other, conditionalTagInspector_);
}

+ (void)initialize {
  if (self == [AbstractFlagEncoder class]) {
    JreStrongAssign(&AbstractFlagEncoder_logger_, nil, OrgSlf4jLoggerFactory_getLoggerWithIOSClass_(AbstractFlagEncoder_class_()));
    J2OBJC_SET_INITIALIZED(AbstractFlagEncoder)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithPMap:", "AbstractFlagEncoder", NULL, 0x1, NULL },
    { "initWithNSString:", "AbstractFlagEncoder", NULL, 0x1, NULL },
    { "initWithInt:withDouble:withInt:", "AbstractFlagEncoder", NULL, 0x4, NULL },
    { "init__", "init", "V", 0x4, NULL },
    { "isRegistered", NULL, "Z", 0x1, NULL },
    { "setRegisteredWithBoolean:", "setRegistered", "V", 0x1, NULL },
    { "setBlockByDefaultWithBoolean:", "setBlockByDefault", "V", 0x1, NULL },
    { "isBlockFords", NULL, "Z", 0x1, NULL },
    { "setBlockFordsWithBoolean:", "setBlockFords", "V", 0x1, NULL },
    { "getConditionalTagInspector", NULL, "Lcom.graphhopper.reader.ConditionalTagInspector;", 0x1, NULL },
    { "setConditionalTagInspectorWithConditionalTagInspector:", "setConditionalTagInspector", "V", 0x4, NULL },
    { "defineNodeBitsWithInt:withInt:", "defineNodeBits", "I", 0x1, NULL },
    { "defineWayBitsWithInt:withInt:", "defineWayBits", "I", 0x1, NULL },
    { "defineRelationBitsWithInt:withInt:", "defineRelationBits", "I", 0x1, NULL },
    { "handleRelationTagsWithReaderRelation:withLong:", "handleRelationTags", "J", 0x401, NULL },
    { "acceptWayWithReaderWay:", "acceptWay", "J", 0x401, NULL },
    { "handleWayTagsWithReaderWay:withLong:withLong:", "handleWayTags", "J", 0x401, NULL },
    { "handleNodeTagsWithReaderNode:", "handleNodeTags", "J", 0x1, NULL },
    { "getAnnotationWithLong:withTranslation:", "getAnnotation", "Lcom.graphhopper.util.InstructionAnnotation;", 0x1, NULL },
    { "reverseFlagsWithLong:", "reverseFlags", "J", 0x1, NULL },
    { "flagsDefaultWithBoolean:withBoolean:", "flagsDefault", "J", 0x1, NULL },
    { "setAccessWithLong:withBoolean:withBoolean:", "setAccess", "J", 0x1, NULL },
    { "setSpeedWithLong:withDouble:", "setSpeed", "J", 0x1, NULL },
    { "setLowSpeedWithLong:withDouble:withBoolean:", "setLowSpeed", "J", 0x4, NULL },
    { "getSpeedWithLong:", "getSpeed", "D", 0x1, NULL },
    { "setReverseSpeedWithLong:withDouble:", "setReverseSpeed", "J", 0x1, NULL },
    { "getReverseSpeedWithLong:", "getReverseSpeed", "D", 0x1, NULL },
    { "setPropertiesWithDouble:withBoolean:withBoolean:", "setProperties", "J", 0x1, NULL },
    { "getMaxSpeed", NULL, "D", 0x1, NULL },
    { "getMaxSpeedWithReaderWay:", "getMaxSpeed", "D", 0x4, NULL },
    { "hash", "hashCode", "I", 0x1, NULL },
    { "isEqual:", "equals", "Z", 0x1, NULL },
    { "parseSpeedWithNSString:", "parseSpeed", "D", 0x4, NULL },
    { "applyWayTagsWithReaderWay:withEdgeIteratorState:", "applyWayTags", "V", 0x1, NULL },
    { "getFerrySpeedWithReaderWay:withDouble:withDouble:withDouble:", "getFerrySpeed", "D", 0x4, NULL },
    { "setWayBitMaskWithInt:withInt:", "setWayBitMask", "V", 0x0, NULL },
    { "getWayBitMask", NULL, "J", 0x0, NULL },
    { "setRelBitMaskWithInt:withInt:", "setRelBitMask", "V", 0x0, NULL },
    { "getRelBitMask", NULL, "J", 0x0, NULL },
    { "setNodeBitMaskWithInt:withInt:", "setNodeBitMask", "V", 0x0, NULL },
    { "getNodeBitMask", NULL, "J", 0x0, NULL },
    { "defineTurnBitsWithInt:withInt:", "defineTurnBits", "I", 0x1, NULL },
    { "isTurnRestrictedWithLong:", "isTurnRestricted", "Z", 0x1, NULL },
    { "getTurnCostWithLong:", "getTurnCost", "D", 0x1, NULL },
    { "getTurnFlagsWithBoolean:withDouble:", "getTurnFlags", "J", 0x1, NULL },
    { "isFerryWithLong:", "isFerry", "Z", 0x4, NULL },
    { "isAcceptWithLong:", "isAccept", "Z", 0x4, NULL },
    { "isBackwardWithLong:", "isBackward", "Z", 0x1, NULL },
    { "isForwardWithLong:", "isForward", "Z", 0x1, NULL },
    { "setBoolWithLong:withInt:withBoolean:", "setBool", "J", 0x1, NULL },
    { "isBoolWithLong:withInt:", "isBool", "Z", 0x1, NULL },
    { "setLongWithLong:withInt:withLong:", "setLong", "J", 0x1, NULL },
    { "getLongWithLong:withInt:", "getLong", "J", 0x1, NULL },
    { "setDoubleWithLong:withInt:withDouble:", "setDouble", "J", 0x1, NULL },
    { "getDoubleWithLong:withInt:", "getDouble", "D", 0x1, NULL },
    { "applyMaxSpeedWithReaderWay:withDouble:", "applyMaxSpeed", "D", 0x4, NULL },
    { "getPropertiesString", NULL, "Ljava.lang.String;", 0x4, NULL },
    { "supportsWithIOSClass:", "supports", "Z", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "K_FORWARD_", NULL, 0x1c, "I", NULL, .constantValue.asInt = AbstractFlagEncoder_K_FORWARD },
    { "K_BACKWARD_", NULL, 0x1c, "I", NULL, .constantValue.asInt = AbstractFlagEncoder_K_BACKWARD },
    { "logger_", NULL, 0x1a, "Lorg.slf4j.Logger;", &AbstractFlagEncoder_logger_,  },
    { "restrictions_", NULL, 0x14, "Ljava.util.List;", NULL,  },
    { "intendedValues_", NULL, 0x14, "Ljava.util.Set;", NULL,  },
    { "restrictedValues_", NULL, 0x14, "Ljava.util.Set;", NULL,  },
    { "ferries_", NULL, 0x14, "Ljava.util.Set;", NULL,  },
    { "oneways_", NULL, 0x14, "Ljava.util.Set;", NULL,  },
    { "absoluteBarriers_", NULL, 0x14, "Ljava.util.Set;", NULL,  },
    { "potentialBarriers_", NULL, 0x14, "Ljava.util.Set;", NULL,  },
    { "speedBits_", NULL, 0x14, "I", NULL,  },
    { "speedFactor_", NULL, 0x14, "D", NULL,  },
    { "maxTurnCosts_", NULL, 0x12, "I", NULL,  },
    { "forwardBit_", NULL, 0x4, "J", NULL,  },
    { "backwardBit_", NULL, 0x4, "J", NULL,  },
    { "directionBitMask_", NULL, 0x4, "J", NULL,  },
    { "roundaboutBit_", NULL, 0x4, "J", NULL,  },
    { "speedEncoder_", NULL, 0x4, "Lcom.graphhopper.routing.util.EncodedDoubleValue;", NULL,  },
    { "acceptBit_", NULL, 0x4, "J", NULL,  },
    { "ferryBit_", NULL, 0x4, "J", NULL,  },
    { "properties_", NULL, 0x4, "Lcom.graphhopper.util.PMap;", NULL,  },
    { "maxPossibleSpeed_", NULL, 0x4, "I", NULL,  },
    { "edgeOutExplorer_", NULL, 0x4, "Lcom.graphhopper.util.EdgeExplorer;", NULL,  },
    { "edgeInExplorer_", NULL, 0x4, "Lcom.graphhopper.util.EdgeExplorer;", NULL,  },
    { "nodeBitMask_", NULL, 0x2, "J", NULL,  },
    { "wayBitMask_", NULL, 0x2, "J", NULL,  },
    { "relBitMask_", NULL, 0x2, "J", NULL,  },
    { "turnCostEncoder_", NULL, 0x2, "Lcom.graphhopper.routing.util.EncodedValue;", NULL,  },
    { "turnRestrictionBit_", NULL, 0x2, "J", NULL,  },
    { "blockByDefault_", NULL, 0x2, "Z", NULL,  },
    { "blockFords_", NULL, 0x2, "Z", NULL,  },
    { "registered_", NULL, 0x2, "Z", NULL,  },
    { "conditionalTagInspector_", NULL, 0x2, "Lcom.graphhopper.reader.ConditionalTagInspector;", NULL,  },
  };
  static const J2ObjcClassInfo _AbstractFlagEncoder = { 1, "AbstractFlagEncoder", "com.graphhopper.routing.util", NULL, 0x401, 58, methods, 33, fields, 0, NULL};
  return &_AbstractFlagEncoder;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AbstractFlagEncoder)

@implementation AbstractFlagEncoder_$1

- (jlong)getValueWithLong:(jlong)flags {
  flags &= mask_;
  URShiftAssignLong(&flags, shift_);
  return flags;
}

- (instancetype)initWithNSString:(NSString *)arg$0
                         withInt:(jint)arg$1
                         withInt:(jint)arg$2
                         withInt:(jint)arg$3
                         withInt:(jint)arg$4
                         withInt:(jint)arg$5 {
  return [super initWithNSString:arg$0 withInt:arg$1 withInt:arg$2 withDouble:arg$3 withLong:arg$4 withInt:arg$5];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "getValueWithLong:", "getValue", "J", 0x11, NULL },
    { "initWithNSString:withInt:withInt:withInt:withInt:withInt:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcClassInfo _AbstractFlagEncoder_$1 = { 1, "$1", "com.graphhopper.routing.util", "AbstractFlagEncoder", 0x8000, 2, methods, 0, NULL, 0, NULL};
  return &_AbstractFlagEncoder_$1;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AbstractFlagEncoder_$1)
