//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/coll/IntDoubleBinHeap.h"
#include "com/graphhopper/routing/AbstractRoutingAlgorithm.h"
#include "com/graphhopper/routing/DijkstraOneToMany.h"
#include "com/graphhopper/routing/Path.h"
#include "com/graphhopper/routing/PathNative.h"
#include "com/graphhopper/routing/util/TraversalMode.h"
#include "com/graphhopper/routing/weighting/Weighting.h"
#include "com/graphhopper/storage/Graph.h"
#include "com/graphhopper/util/EdgeExplorer.h"
#include "com/graphhopper/util/EdgeIterator.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/Parameters.h"
#include "java/lang/Double.h"
#include "java/util/Arrays.h"

@interface DijkstraOneToMany () {
 @public
  DijkstraOneToMany_TIntArrayListWithCap *changedNodes_;
  IOSIntArray *parents_;
  IOSIntArray *edgeIds_;
  IntDoubleBinHeap *heap_;
  jint visitedNodes_;
  jboolean doClear_;
  jint endNode_;
  jint currNode_, fromNode_, to_;
  jdouble weightLimit_;
}
@end

J2OBJC_FIELD_SETTER(DijkstraOneToMany, changedNodes_, DijkstraOneToMany_TIntArrayListWithCap *)
J2OBJC_FIELD_SETTER(DijkstraOneToMany, parents_, IOSIntArray *)
J2OBJC_FIELD_SETTER(DijkstraOneToMany, edgeIds_, IOSIntArray *)
J2OBJC_FIELD_SETTER(DijkstraOneToMany, heap_, IntDoubleBinHeap *)

@implementation DijkstraOneToMany

- (instancetype)initWithGraph:(id<Graph>)graph
withComGraphhopperRoutingWeightingWeighting:(id<ComGraphhopperRoutingWeightingWeighting>)weighting
        withTraversalModeEnum:(TraversalModeEnum *)tMode {
  if (self = [super initWithGraph:graph withComGraphhopperRoutingWeightingWeighting:weighting withTraversalModeEnum:tMode]) {
    doClear_ = YES;
    weightLimit_ = JavaLangDouble_MAX_VALUE;
    DijkstraOneToMany_setAndConsume_parents_(self, [IOSIntArray newArrayWithLength:[((id<Graph>) nil_chk(graph)) getNodes]]);
    JavaUtilArrays_fillWithIntArray_withInt_(parents_, DijkstraOneToMany_EMPTY_PARENT);
    DijkstraOneToMany_setAndConsume_edgeIds_(self, [IOSIntArray newArrayWithLength:[graph getNodes]]);
    JavaUtilArrays_fillWithIntArray_withInt_(edgeIds_, EdgeIterator_NO_EDGE);
    DijkstraOneToMany_setAndConsume_weights_(self, [IOSDoubleArray newArrayWithLength:[graph getNodes]]);
    JavaUtilArrays_fillWithDoubleArray_withDouble_(weights_, JavaLangDouble_MAX_VALUE);
    DijkstraOneToMany_setAndConsume_heap_(self, [[IntDoubleBinHeap alloc] init]);
    DijkstraOneToMany_setAndConsume_changedNodes_(self, [[DijkstraOneToMany_TIntArrayListWithCap alloc] init]);
  }
  return self;
}

- (Path *)calcPathWithInt:(jint)from
                  withInt:(jint)to {
  fromNode_ = from;
  endNode_ = [self findEndNodeWithInt:from withInt:to];
  return [self extractPath];
}

- (Path *)extractPath {
  PathNative *p = [[[PathNative alloc] initWithGraph:graph_ withComGraphhopperRoutingWeightingWeighting:weighting_ withIntArray:parents_ withIntArray:edgeIds_] autorelease];
  if (endNode_ >= 0) [p setWeightWithDouble:IOSDoubleArray_Get(nil_chk(weights_), endNode_)];
  [p setFromNodeWithInt:fromNode_];
  if (endNode_ < 0 || [self isWeightLimitExceeded]) return p;
  return [((Path *) nil_chk([p setEndNodeWithInt:endNode_])) extract];
}

- (DijkstraOneToMany *)clear {
  doClear_ = YES;
  return self;
}

- (jdouble)getWeightWithInt:(jint)endNode {
  return IOSDoubleArray_Get(nil_chk(weights_), endNode);
}

- (jint)findEndNodeWithInt:(jint)from
                   withInt:(jint)to {
  if (((IOSDoubleArray *) nil_chk(weights_))->size_ < 2) return DijkstraOneToMany_NOT_FOUND;
  self->to_ = to;
  if (doClear_) {
    doClear_ = NO;
    jint vn = [((DijkstraOneToMany_TIntArrayListWithCap *) nil_chk(changedNodes_)) size];
    for (jint i = 0; i < vn; i++) {
      jint n = [changedNodes_ getWithInt:i];
      *IOSDoubleArray_GetRef(weights_, n) = JavaLangDouble_MAX_VALUE;
      *IOSIntArray_GetRef(nil_chk(parents_), n) = DijkstraOneToMany_EMPTY_PARENT;
      *IOSIntArray_GetRef(nil_chk(edgeIds_), n) = EdgeIterator_NO_EDGE;
    }
    [((IntDoubleBinHeap *) nil_chk(heap_)) clear];
    [changedNodes_ reset];
    currNode_ = from;
    if (![((TraversalModeEnum *) nil_chk(traversalMode_)) isEdgeBased]) {
      *IOSDoubleArray_GetRef(weights_, currNode_) = 0;
      [changedNodes_ addWithInt:currNode_];
    }
  }
  else {
    jint parentNode = IOSIntArray_Get(nil_chk(parents_), to);
    if (parentNode != DijkstraOneToMany_EMPTY_PARENT && IOSDoubleArray_Get(weights_, to) <= IOSDoubleArray_Get(weights_, currNode_)) return to;
    if ([((IntDoubleBinHeap *) nil_chk(heap_)) isEmpty] || [self isMaxVisitedNodesExceeded]) return DijkstraOneToMany_NOT_FOUND;
    currNode_ = [heap_ poll_element];
  }
  visitedNodes_ = 0;
  if ([self finished]) {
    if ([((IntDoubleBinHeap *) nil_chk(heap_)) isEmpty]) doClear_ = YES;
    return currNode_;
  }
  while (YES) {
    visitedNodes_++;
    id<EdgeIterator> iter = [((id<EdgeExplorer>) nil_chk(outEdgeExplorer_)) setBaseNodeWithInt:currNode_];
    while ([((id<EdgeIterator>) nil_chk(iter)) next]) {
      jint adjNode = [iter getAdjNode];
      jint prevEdgeId = IOSIntArray_Get(nil_chk(edgeIds_), adjNode);
      if (![self acceptWithEdgeIterator:iter withInt:prevEdgeId]) continue;
      jdouble tmpWeight = [((id<ComGraphhopperRoutingWeightingWeighting>) nil_chk(weighting_)) calcWeightWithEdgeIteratorState:iter withBoolean:NO withInt:prevEdgeId] + IOSDoubleArray_Get(weights_, currNode_);
      if (JavaLangDouble_isInfiniteWithDouble_(tmpWeight)) continue;
      jdouble w = IOSDoubleArray_Get(weights_, adjNode);
      if (w == JavaLangDouble_MAX_VALUE) {
        *IOSIntArray_GetRef(nil_chk(parents_), adjNode) = currNode_;
        *IOSDoubleArray_GetRef(weights_, adjNode) = tmpWeight;
        [((IntDoubleBinHeap *) nil_chk(heap_)) insert_WithDouble:tmpWeight withInt:adjNode];
        [((DijkstraOneToMany_TIntArrayListWithCap *) nil_chk(changedNodes_)) addWithInt:adjNode];
        *IOSIntArray_GetRef(edgeIds_, adjNode) = [iter getEdge];
      }
      else if (w > tmpWeight) {
        *IOSIntArray_GetRef(nil_chk(parents_), adjNode) = currNode_;
        *IOSDoubleArray_GetRef(weights_, adjNode) = tmpWeight;
        [((IntDoubleBinHeap *) nil_chk(heap_)) update_WithDouble:tmpWeight withInt:adjNode];
        [((DijkstraOneToMany_TIntArrayListWithCap *) nil_chk(changedNodes_)) addWithInt:adjNode];
        *IOSIntArray_GetRef(edgeIds_, adjNode) = [iter getEdge];
      }
    }
    if ([((IntDoubleBinHeap *) nil_chk(heap_)) isEmpty] || [self isMaxVisitedNodesExceeded] || [self isWeightLimitExceeded]) return DijkstraOneToMany_NOT_FOUND;
    currNode_ = [heap_ peek_element];
    if ([self finished]) return currNode_;
    [heap_ poll_element];
  }
}

- (jboolean)finished {
  return currNode_ == to_;
}

- (void)setWeightLimitWithDouble:(jdouble)weightLimit {
  self->weightLimit_ = weightLimit;
}

- (jboolean)isWeightLimitExceeded {
  return IOSDoubleArray_Get(nil_chk(weights_), currNode_) > weightLimit_;
}

- (void)close {
  DijkstraOneToMany_set_weights_(self, nil);
  DijkstraOneToMany_set_parents_(self, nil);
  DijkstraOneToMany_set_edgeIds_(self, nil);
  DijkstraOneToMany_set_heap_(self, nil);
}

- (jint)getVisitedNodes {
  return visitedNodes_;
}

- (NSString *)getName {
  return Parameters_Algorithms_get_DIJKSTRA_ONE_TO_MANY_();
}

- (NSString *)getMemoryUsageAsString {
  jlong len = ((IOSDoubleArray *) nil_chk(weights_))->size_;
  return JreStrcat("J$", ((8LL + 4LL + 4LL) * len + [((DijkstraOneToMany_TIntArrayListWithCap *) nil_chk(changedNodes_)) getCapacity] * 4LL + [((IntDoubleBinHeap *) nil_chk(heap_)) getCapacity] * (4LL + 4LL)) / Helper_MB, @"MB");
}

- (void)dealloc {
  RELEASE_(changedNodes_);
  RELEASE_(weights_);
  RELEASE_(parents_);
  RELEASE_(edgeIds_);
  RELEASE_(heap_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(DijkstraOneToMany *)other {
  [super copyAllFieldsTo:other];
  DijkstraOneToMany_set_changedNodes_(other, changedNodes_);
  DijkstraOneToMany_set_weights_(other, weights_);
  DijkstraOneToMany_set_parents_(other, parents_);
  DijkstraOneToMany_set_edgeIds_(other, edgeIds_);
  DijkstraOneToMany_set_heap_(other, heap_);
  other->visitedNodes_ = visitedNodes_;
  other->doClear_ = doClear_;
  other->endNode_ = endNode_;
  other->currNode_ = currNode_;
  other->fromNode_ = fromNode_;
  other->to_ = to_;
  other->weightLimit_ = weightLimit_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGraph:withComGraphhopperRoutingWeightingWeighting:withTraversalModeEnum:", "DijkstraOneToMany", NULL, 0x1, NULL },
    { "calcPathWithInt:withInt:", "calcPath", "Lcom.graphhopper.routing.Path;", 0x1, NULL },
    { "extractPath", NULL, "Lcom.graphhopper.routing.Path;", 0x1, NULL },
    { "clear", NULL, "Lcom.graphhopper.routing.DijkstraOneToMany;", 0x1, NULL },
    { "getWeightWithInt:", "getWeight", "D", 0x1, NULL },
    { "findEndNodeWithInt:withInt:", "findEndNode", "I", 0x1, NULL },
    { "finished", NULL, "Z", 0x1, NULL },
    { "setWeightLimitWithDouble:", "setWeightLimit", "V", 0x1, NULL },
    { "isWeightLimitExceeded", NULL, "Z", 0x4, NULL },
    { "close", NULL, "V", 0x1, NULL },
    { "getVisitedNodes", NULL, "I", 0x1, NULL },
    { "getName", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "getMemoryUsageAsString", NULL, "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "EMPTY_PARENT_", NULL, 0x1a, "I", NULL, .constantValue.asInt = DijkstraOneToMany_EMPTY_PARENT },
    { "NOT_FOUND_", NULL, 0x1a, "I", NULL, .constantValue.asInt = DijkstraOneToMany_NOT_FOUND },
    { "changedNodes_", NULL, 0x12, "Lcom.graphhopper.routing.DijkstraOneToMany$TIntArrayListWithCap;", NULL,  },
    { "weights_", NULL, 0x4, "[D", NULL,  },
    { "parents_", NULL, 0x2, "[I", NULL,  },
    { "edgeIds_", NULL, 0x2, "[I", NULL,  },
    { "heap_", NULL, 0x2, "Lcom.graphhopper.coll.IntDoubleBinHeap;", NULL,  },
    { "visitedNodes_", NULL, 0x2, "I", NULL,  },
    { "doClear_", NULL, 0x2, "Z", NULL,  },
    { "endNode_", NULL, 0x2, "I", NULL,  },
    { "currNode_", NULL, 0x2, "I", NULL,  },
    { "fromNode_", NULL, 0x2, "I", NULL,  },
    { "to_", NULL, 0x2, "I", NULL,  },
    { "weightLimit_", NULL, 0x2, "D", NULL,  },
  };
  static const J2ObjcClassInfo _DijkstraOneToMany = { 1, "DijkstraOneToMany", "com.graphhopper.routing", NULL, 0x1, 13, methods, 14, fields, 0, NULL};
  return &_DijkstraOneToMany;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(DijkstraOneToMany)

@implementation DijkstraOneToMany_TIntArrayListWithCap

- (instancetype)init {
  return [super init];
}

- (jint)getCapacity {
  return ((IOSIntArray *) nil_chk(_data_))->size_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "TIntArrayListWithCap", NULL, 0x1, NULL },
    { "getCapacity", NULL, "I", 0x1, NULL },
  };
  static const J2ObjcClassInfo _DijkstraOneToMany_TIntArrayListWithCap = { 1, "TIntArrayListWithCap", "com.graphhopper.routing", "DijkstraOneToMany", 0xa, 2, methods, 0, NULL, 0, NULL};
  return &_DijkstraOneToMany_TIntArrayListWithCap;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(DijkstraOneToMany_TIntArrayListWithCap)
