//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/routing/Path.java
//

#include "IOSClass.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/routing/Path.h"
#include "com/graphhopper/routing/util/DefaultEdgeFilter.h"
#include "com/graphhopper/routing/util/FlagEncoder.h"
#include "com/graphhopper/routing/weighting/Weighting.h"
#include "com/graphhopper/storage/Graph.h"
#include "com/graphhopper/storage/NodeAccess.h"
#include "com/graphhopper/storage/SPTEntry.h"
#include "com/graphhopper/util/AngleCalc.h"
#include "com/graphhopper/util/EdgeExplorer.h"
#include "com/graphhopper/util/EdgeIterator.h"
#include "com/graphhopper/util/EdgeIteratorState.h"
#include "com/graphhopper/util/FinishInstruction.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/Instruction.h"
#include "com/graphhopper/util/InstructionAnnotation.h"
#include "com/graphhopper/util/InstructionList.h"
#include "com/graphhopper/util/PointList.h"
#include "com/graphhopper/util/RoundaboutInstruction.h"
#include "com/graphhopper/util/StopWatch.h"
#include "com/graphhopper/util/Translation.h"
#include "gnu/trove/list/TIntList.h"
#include "gnu/trove/list/array/TIntArrayList.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Math.h"
#include "java/util/ArrayList.h"
#include "java/util/Collections.h"
#include "java/util/List.h"

__attribute__((unused)) static jint Path_getFromNode(Path *self);
__attribute__((unused)) static void Path_forEveryEdgeWithPath_EdgeVisitor_(Path *self, id<Path_EdgeVisitor> visitor);
__attribute__((unused)) static void Path_$4_updatePointsAndInstructionWithEdgeIteratorState_withPointList_(Path_$4 *self, id<EdgeIteratorState> edge, PointList *pl);

@interface Path () {
 @public
  id<JavaUtilList> description__;
  id<FlagEncoder> encoder_;
  jboolean found_;
  jint fromNode_;
  id<GnuTroveListTIntList> edgeIds_;
  jdouble weight_;
  id<NodeAccess> nodeAccess_;
}

/**
 @return the first node of this Path.
 */
- (jint)getFromNode;

/**
 @brief Iterates over all edges in this path sorted from start to end and calls the visitor callback for every edge.
 <p>
 @param visitor callback to handle every edge. The edge is decoupled from the iterator and can be stored.
 */
- (void)forEveryEdgeWithPath_EdgeVisitor:(id<Path_EdgeVisitor>)visitor;
@end

J2OBJC_FIELD_SETTER(Path, description__, id<JavaUtilList>)
J2OBJC_FIELD_SETTER(Path, encoder_, id<FlagEncoder>)
J2OBJC_FIELD_SETTER(Path, edgeIds_, id<GnuTroveListTIntList>)
J2OBJC_FIELD_SETTER(Path, nodeAccess_, id<NodeAccess>)

@interface Path_$1 () {
 @public
  id<JavaUtilList> val$edges_;
}
@end

J2OBJC_FIELD_SETTER(Path_$1, val$edges_, id<JavaUtilList>)

@interface Path_$2 () {
 @public
  GnuTroveListArrayTIntArrayList *val$nodes_;
}
@end

J2OBJC_FIELD_SETTER(Path_$2, val$nodes_, GnuTroveListArrayTIntArrayList *)

@interface Path_$3 () {
 @public
  PointList *val$points_;
}
@end

J2OBJC_FIELD_SETTER(Path_$3, val$points_, PointList *)

@interface Path_$4 () {
 @public
  Path *this$0_;
  jdouble prevLat_;
  jdouble prevLon_;
  jdouble doublePrevLat_, doublePrevLong_;
  jint prevNode_;
  jdouble prevOrientation_;
  Instruction *prevInstruction_;
  jboolean prevInRoundabout_;
  NSString *name_, *prevName_;
  InstructionAnnotation *annotation_, *prevAnnotation_;
  id<EdgeExplorer> outEdgeExplorer_;
  jint val$tmpNode_;
  id<Translation> val$tr_;
  InstructionList *val$ways_;
}

- (void)updatePointsAndInstructionWithEdgeIteratorState:(id<EdgeIteratorState>)edge
                                          withPointList:(PointList *)pl;
@end

J2OBJC_FIELD_SETTER(Path_$4, this$0_, Path *)
J2OBJC_FIELD_SETTER(Path_$4, prevInstruction_, Instruction *)
J2OBJC_FIELD_SETTER(Path_$4, name_, NSString *)
J2OBJC_FIELD_SETTER(Path_$4, prevName_, NSString *)
J2OBJC_FIELD_SETTER(Path_$4, annotation_, InstructionAnnotation *)
J2OBJC_FIELD_SETTER(Path_$4, prevAnnotation_, InstructionAnnotation *)
J2OBJC_FIELD_SETTER(Path_$4, outEdgeExplorer_, id<EdgeExplorer>)
J2OBJC_FIELD_SETTER(Path_$4, val$tr_, id<Translation>)
J2OBJC_FIELD_SETTER(Path_$4, val$ways_, InstructionList *)

BOOL Path_initialized = NO;

@implementation Path

AngleCalc * Path_AC_;

- (instancetype)initPathWithGraph:(id<Graph>)graph
withComGraphhopperRoutingWeightingWeighting:(id<ComGraphhopperRoutingWeightingWeighting>)weighting {
  if (self = [super init]) {
    Path_setAndConsume_extractSW_(self, [[StopWatch alloc] initWithNSString:@"extract"]);
    reverseOrder__ = YES;
    endNode_ = -1;
    fromNode_ = -1;
    self->weight_ = JavaLangDouble_MAX_VALUE;
    Path_set_graph_(self, graph);
    Path_set_nodeAccess_(self, [((id<Graph>) nil_chk(graph)) getNodeAccess]);
    Path_set_weighting_(self, weighting);
    Path_set_encoder_(self, [((id<ComGraphhopperRoutingWeightingWeighting>) nil_chk(weighting)) getFlagEncoder]);
    Path_setAndConsume_edgeIds_(self, [[GnuTroveListArrayTIntArrayList alloc] init]);
  }
  return self;
}

- (instancetype)initWithGraph:(id<Graph>)graph
withComGraphhopperRoutingWeightingWeighting:(id<ComGraphhopperRoutingWeightingWeighting>)weighting {
  return [self initPathWithGraph:graph withComGraphhopperRoutingWeightingWeighting:weighting];
}

- (instancetype)initWithPath:(Path *)p {
  if (self = [self initPathWithGraph:((Path *) nil_chk(p))->graph_ withComGraphhopperRoutingWeightingWeighting:p->weighting_]) {
    weight_ = p->weight_;
    Path_setAndConsume_edgeIds_(self, [[GnuTroveListArrayTIntArrayList alloc] initWithGnuTroveTIntCollection:p->edgeIds_]);
    Path_set_sptEntry_(self, p->sptEntry_);
  }
  return self;
}

- (id<JavaUtilList>)getDescription {
  if (description__ == nil) return JavaUtilCollections_emptyList();
  return description__;
}

- (Path *)setDescriptionWithJavaUtilList:(id<JavaUtilList>)description_ {
  Path_set_description__(self, description_);
  return self;
}

- (Path *)setSPTEntryWithSPTEntry:(SPTEntry *)sptEntry {
  Path_set_sptEntry_(self, sptEntry);
  return self;
}

- (void)addEdgeWithInt:(jint)edge {
  [((id<GnuTroveListTIntList>) nil_chk(edgeIds_)) addWithInt:edge];
}

- (Path *)setEndNodeWithInt:(jint)end {
  endNode_ = end;
  return self;
}

- (jint)getFromNode {
  return Path_getFromNode(self);
}

- (Path *)setFromNodeWithInt:(jint)from {
  fromNode_ = from;
  return self;
}

- (jint)getEdgeCount {
  return [((id<GnuTroveListTIntList>) nil_chk(edgeIds_)) size];
}

- (jboolean)isFound {
  return found_;
}

- (Path *)setFoundWithBoolean:(jboolean)found {
  self->found_ = found;
  return self;
}

- (void)reverseOrder {
  if (!reverseOrder__) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Switching order multiple times is not supported"] autorelease];
  reverseOrder__ = NO;
  [((id<GnuTroveListTIntList>) nil_chk(edgeIds_)) reverse];
}

- (Path *)setDistanceWithDouble:(jdouble)distance {
  self->distance_ = distance;
  return self;
}

- (jdouble)getDistance {
  return distance_;
}

- (jlong)getTime {
  return time_;
}

- (jdouble)getWeight {
  return weight_;
}

- (Path *)setWeightWithDouble:(jdouble)w {
  self->weight_ = w;
  return self;
}

- (Path *)extract {
  if ([self isFound]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Extract can only be called once"] autorelease];
  [((StopWatch *) nil_chk(extractSW_)) start];
  SPTEntry *goalEdge = sptEntry_;
  jint prevEdge = EdgeIterator_NO_EDGE;
  [self setEndNodeWithInt:((SPTEntry *) nil_chk(goalEdge))->adjNode_];
  while (EdgeIterator_Edge_isValidWithInt_(goalEdge->edge_)) {
    [self processEdgeWithInt:goalEdge->edge_ withInt:goalEdge->adjNode_ withInt:prevEdge];
    prevEdge = goalEdge->edge_;
    goalEdge = goalEdge->parent_;
  }
  [self setFromNodeWithInt:((SPTEntry *) nil_chk(goalEdge))->adjNode_];
  [self reverseOrder];
  [extractSW_ stop];
  return [self setFoundWithBoolean:YES];
}

- (id<EdgeIteratorState>)getFinalEdge {
  return [((id<Graph>) nil_chk(graph_)) getEdgeIteratorStateWithInt:[edgeIds_ getWithInt:[((id<GnuTroveListTIntList>) nil_chk(edgeIds_)) size] - 1] withInt:endNode_];
}

- (jlong)getExtractTime {
  return [((StopWatch *) nil_chk(extractSW_)) getNanos];
}

- (NSString *)getDebugInfo {
  return [((StopWatch *) nil_chk(extractSW_)) description];
}

- (void)processEdgeWithInt:(jint)edgeId
                   withInt:(jint)adjNode
                   withInt:(jint)prevEdgeId {
  id<EdgeIteratorState> iter = [((id<Graph>) nil_chk(graph_)) getEdgeIteratorStateWithInt:edgeId withInt:adjNode];
  distance_ += [((id<EdgeIteratorState>) nil_chk(iter)) getDistance];
  time_ += [((id<ComGraphhopperRoutingWeightingWeighting>) nil_chk(weighting_)) calcMillisWithEdgeIteratorState:iter withBoolean:NO withInt:prevEdgeId];
  [self addEdgeWithInt:edgeId];
}

- (jlong)calcMillisWithEdgeIteratorState:(id<EdgeIteratorState>)edge
                             withBoolean:(jboolean)reverse {
  return [((id<ComGraphhopperRoutingWeightingWeighting>) nil_chk(weighting_)) calcMillisWithEdgeIteratorState:edge withBoolean:reverse withInt:EdgeIterator_NO_EDGE];
}

- (void)forEveryEdgeWithPath_EdgeVisitor:(id<Path_EdgeVisitor>)visitor {
  Path_forEveryEdgeWithPath_EdgeVisitor_(self, visitor);
}

- (id<JavaUtilList>)calcEdges {
  id<JavaUtilList> edges = [[[JavaUtilArrayList alloc] initWithInt:[((id<GnuTroveListTIntList>) nil_chk(edgeIds_)) size]] autorelease];
  if ([edgeIds_ isEmpty]) return edges;
  Path_forEveryEdgeWithPath_EdgeVisitor_(self, [[[Path_$1 alloc] initWithJavaUtilList:edges] autorelease]);
  return edges;
}

- (id<GnuTroveListTIntList>)calcNodes {
  GnuTroveListArrayTIntArrayList *nodes = [[[GnuTroveListArrayTIntArrayList alloc] initWithInt:[((id<GnuTroveListTIntList>) nil_chk(edgeIds_)) size] + 1] autorelease];
  if ([edgeIds_ isEmpty]) {
    if ([self isFound]) {
      [nodes addWithInt:endNode_];
    }
    return nodes;
  }
  jint tmpNode = Path_getFromNode(self);
  [nodes addWithInt:tmpNode];
  Path_forEveryEdgeWithPath_EdgeVisitor_(self, [[[Path_$2 alloc] initWithGnuTroveListArrayTIntArrayList:nodes] autorelease]);
  return nodes;
}

- (PointList *)calcPoints {
  PointList *points = [[[PointList alloc] initWithInt:[((id<GnuTroveListTIntList>) nil_chk(edgeIds_)) size] + 1 withBoolean:[((id<NodeAccess>) nil_chk(nodeAccess_)) is3D]] autorelease];
  if ([edgeIds_ isEmpty]) {
    if ([self isFound]) {
      [points addWithPointAccess:[((id<Graph>) nil_chk(graph_)) getNodeAccess] withInt:endNode_];
    }
    return points;
  }
  jint tmpNode = Path_getFromNode(self);
  [points addWithPointAccess:nodeAccess_ withInt:tmpNode];
  Path_forEveryEdgeWithPath_EdgeVisitor_(self, [[[Path_$3 alloc] initWithPointList:points] autorelease]);
  return points;
}

- (InstructionList *)calcInstructionsWithTranslation:(id<Translation>)tr {
  InstructionList *ways = [[[InstructionList alloc] initWithInt:[((id<GnuTroveListTIntList>) nil_chk(edgeIds_)) size] / 4 withTranslation:tr] autorelease];
  if ([edgeIds_ isEmpty]) {
    if ([self isFound]) {
      [ways addWithInstruction:[[[FinishInstruction alloc] initWithPointAccess:nodeAccess_ withInt:endNode_] autorelease]];
    }
    return ways;
  }
  jint tmpNode = Path_getFromNode(self);
  Path_forEveryEdgeWithPath_EdgeVisitor_(self, [[[Path_$4 alloc] initWithPath:self withInt:tmpNode withTranslation:tr withInstructionList:ways] autorelease]);
  return ways;
}

- (NSString *)description {
  return JreStrcat("$D$I", @"distance:", [self getDistance], @", edges:", [((id<GnuTroveListTIntList>) nil_chk(edgeIds_)) size]);
}

- (NSString *)toDetailsString {
  NSString *str = @"";
  for (jint i = 0; i < [((id<GnuTroveListTIntList>) nil_chk(edgeIds_)) size]; i++) {
    if (i > 0) str = JreStrcat("$$", str, @"->");
    str = JreStrcat("$I", str, [edgeIds_ getWithInt:i]);
  }
  return JreStrcat("$$Z$$", [self description], @", found:", [self isFound], @", ", str);
}

- (void)dealloc {
  RELEASE_(extractSW_);
  RELEASE_(graph_);
  RELEASE_(sptEntry_);
  RELEASE_(description__);
  RELEASE_(weighting_);
  RELEASE_(encoder_);
  RELEASE_(edgeIds_);
  RELEASE_(nodeAccess_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(Path *)other {
  [super copyAllFieldsTo:other];
  Path_set_extractSW_(other, extractSW_);
  Path_set_graph_(other, graph_);
  other->distance_ = distance_;
  other->reverseOrder__ = reverseOrder__;
  other->time_ = time_;
  Path_set_sptEntry_(other, sptEntry_);
  other->endNode_ = endNode_;
  Path_set_description__(other, description__);
  Path_set_weighting_(other, weighting_);
  Path_set_encoder_(other, encoder_);
  other->found_ = found_;
  other->fromNode_ = fromNode_;
  Path_set_edgeIds_(other, edgeIds_);
  other->weight_ = weight_;
  Path_set_nodeAccess_(other, nodeAccess_);
}

+ (void)initialize {
  if (self == [Path class]) {
    JreStrongAssign(&Path_AC_, nil, Helper_get_ANGLE_CALC_());
    J2OBJC_SET_INITIALIZED(Path)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGraph:withComGraphhopperRoutingWeightingWeighting:", "Path", NULL, 0x1, NULL },
    { "initWithPath:", "Path", NULL, 0x0, NULL },
    { "getDescription", NULL, "Ljava.util.List;", 0x1, NULL },
    { "setDescriptionWithJavaUtilList:", "setDescription", "Lcom.graphhopper.routing.Path;", 0x1, NULL },
    { "setSPTEntryWithSPTEntry:", "setSPTEntry", "Lcom.graphhopper.routing.Path;", 0x1, NULL },
    { "addEdgeWithInt:", "addEdge", "V", 0x4, NULL },
    { "setEndNodeWithInt:", "setEndNode", "Lcom.graphhopper.routing.Path;", 0x4, NULL },
    { "getFromNode", NULL, "I", 0x2, NULL },
    { "setFromNodeWithInt:", "setFromNode", "Lcom.graphhopper.routing.Path;", 0x4, NULL },
    { "getEdgeCount", NULL, "I", 0x1, NULL },
    { "isFound", NULL, "Z", 0x1, NULL },
    { "setFoundWithBoolean:", "setFound", "Lcom.graphhopper.routing.Path;", 0x1, NULL },
    { "reverseOrder", NULL, "V", 0x0, NULL },
    { "setDistanceWithDouble:", "setDistance", "Lcom.graphhopper.routing.Path;", 0x1, NULL },
    { "getDistance", NULL, "D", 0x1, NULL },
    { "getTime", NULL, "J", 0x1, NULL },
    { "getWeight", NULL, "D", 0x1, NULL },
    { "setWeightWithDouble:", "setWeight", "Lcom.graphhopper.routing.Path;", 0x1, NULL },
    { "extract", NULL, "Lcom.graphhopper.routing.Path;", 0x1, NULL },
    { "getFinalEdge", NULL, "Lcom.graphhopper.util.EdgeIteratorState;", 0x1, NULL },
    { "getExtractTime", NULL, "J", 0x1, NULL },
    { "getDebugInfo", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "processEdgeWithInt:withInt:withInt:", "processEdge", "V", 0x4, NULL },
    { "calcMillisWithEdgeIteratorState:withBoolean:", "calcMillis", "J", 0x4, NULL },
    { "forEveryEdgeWithPath_EdgeVisitor:", "forEveryEdge", "V", 0x2, NULL },
    { "calcEdges", NULL, "Ljava.util.List;", 0x1, NULL },
    { "calcNodes", NULL, "Lgnu.trove.list.TIntList;", 0x1, NULL },
    { "calcPoints", NULL, "Lcom.graphhopper.util.PointList;", 0x1, NULL },
    { "calcInstructionsWithTranslation:", "calcInstructions", "Lcom.graphhopper.util.InstructionList;", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "toDetailsString", NULL, "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "AC_", NULL, 0x1a, "Lcom.graphhopper.util.AngleCalc;", &Path_AC_,  },
    { "extractSW_", NULL, 0x10, "Lcom.graphhopper.util.StopWatch;", NULL,  },
    { "graph_", NULL, 0x4, "Lcom.graphhopper.storage.Graph;", NULL,  },
    { "distance_", NULL, 0x4, "D", NULL,  },
    { "reverseOrder__", "reverseOrder", 0x4, "Z", NULL,  },
    { "time_", NULL, 0x4, "J", NULL,  },
    { "sptEntry_", NULL, 0x4, "Lcom.graphhopper.storage.SPTEntry;", NULL,  },
    { "endNode_", NULL, 0x4, "I", NULL,  },
    { "description__", "description", 0x2, "Ljava.util.List;", NULL,  },
    { "weighting_", NULL, 0x4, "Lcom.graphhopper.routing.weighting.Weighting;", NULL,  },
    { "encoder_", NULL, 0x2, "Lcom.graphhopper.routing.util.FlagEncoder;", NULL,  },
    { "found_", NULL, 0x2, "Z", NULL,  },
    { "fromNode_", NULL, 0x2, "I", NULL,  },
    { "edgeIds_", NULL, 0x2, "Lgnu.trove.list.TIntList;", NULL,  },
    { "weight_", NULL, 0x2, "D", NULL,  },
    { "nodeAccess_", NULL, 0x2, "Lcom.graphhopper.storage.NodeAccess;", NULL,  },
  };
  static const J2ObjcClassInfo _Path = { 1, "Path", "com.graphhopper.routing", NULL, 0x1, 31, methods, 16, fields, 0, NULL};
  return &_Path;
}

@end

jint Path_getFromNode(Path *self) {
  if (self->fromNode_ < 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Call extract() before retrieving fromNode"] autorelease];
  return self->fromNode_;
}

void Path_forEveryEdgeWithPath_EdgeVisitor_(Path *self, id<Path_EdgeVisitor> visitor) {
  jint tmpNode = Path_getFromNode(self);
  jint len = [((id<GnuTroveListTIntList>) nil_chk(self->edgeIds_)) size];
  for (jint i = 0; i < len; i++) {
    id<EdgeIteratorState> edgeBase = [((id<Graph>) nil_chk(self->graph_)) getEdgeIteratorStateWithInt:[self->edgeIds_ getWithInt:i] withInt:tmpNode];
    if (edgeBase == nil) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$I$I$I", @"Edge ", [self->edgeIds_ getWithInt:i], @" was empty when requested with node ", tmpNode, @", array index:", i, @", edges:", [self->edgeIds_ size])] autorelease];
    tmpNode = [((id<EdgeIteratorState>) nil_chk(edgeBase)) getBaseNode];
    edgeBase = [self->graph_ getEdgeIteratorStateWithInt:[edgeBase getEdge] withInt:tmpNode];
    [((id<Path_EdgeVisitor>) nil_chk(visitor)) nextWithEdgeIteratorState:edgeBase withInt:i];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(Path)

@interface Path_EdgeVisitor : NSObject
@end

@implementation Path_EdgeVisitor

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "nextWithEdgeIteratorState:withInt:", "next", "V", 0x401, NULL },
  };
  static const J2ObjcClassInfo _Path_EdgeVisitor = { 1, "EdgeVisitor", "com.graphhopper.routing", "Path", 0x20a, 1, methods, 0, NULL, 0, NULL};
  return &_Path_EdgeVisitor;
}

@end

J2OBJC_INTERFACE_TYPE_LITERAL_SOURCE(Path_EdgeVisitor)

@implementation Path_$1

- (void)nextWithEdgeIteratorState:(id<EdgeIteratorState>)eb
                          withInt:(jint)i {
  [((id<JavaUtilList>) nil_chk(val$edges_)) addWithId:eb];
}

- (instancetype)initWithJavaUtilList:(id<JavaUtilList>)capture$0 {
  Path_$1_set_val$edges_(self, capture$0);
  return [super init];
}

- (void)dealloc {
  RELEASE_(val$edges_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(Path_$1 *)other {
  [super copyAllFieldsTo:other];
  Path_$1_set_val$edges_(other, val$edges_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "nextWithEdgeIteratorState:withInt:", "next", "V", 0x1, NULL },
    { "initWithJavaUtilList:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "val$edges_", NULL, 0x1012, "Ljava.util.List;", NULL,  },
  };
  static const J2ObjcClassInfo _Path_$1 = { 1, "$1", "com.graphhopper.routing", "Path", 0x8000, 2, methods, 1, fields, 0, NULL};
  return &_Path_$1;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(Path_$1)

@implementation Path_$2

- (void)nextWithEdgeIteratorState:(id<EdgeIteratorState>)eb
                          withInt:(jint)i {
  [((GnuTroveListArrayTIntArrayList *) nil_chk(val$nodes_)) addWithInt:[((id<EdgeIteratorState>) nil_chk(eb)) getAdjNode]];
}

- (instancetype)initWithGnuTroveListArrayTIntArrayList:(GnuTroveListArrayTIntArrayList *)capture$0 {
  Path_$2_set_val$nodes_(self, capture$0);
  return [super init];
}

- (void)dealloc {
  RELEASE_(val$nodes_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(Path_$2 *)other {
  [super copyAllFieldsTo:other];
  Path_$2_set_val$nodes_(other, val$nodes_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "nextWithEdgeIteratorState:withInt:", "next", "V", 0x1, NULL },
    { "initWithGnuTroveListArrayTIntArrayList:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "val$nodes_", NULL, 0x1012, "Lgnu.trove.list.array.TIntArrayList;", NULL,  },
  };
  static const J2ObjcClassInfo _Path_$2 = { 1, "$2", "com.graphhopper.routing", "Path", 0x8000, 2, methods, 1, fields, 0, NULL};
  return &_Path_$2;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(Path_$2)

@implementation Path_$3

- (void)nextWithEdgeIteratorState:(id<EdgeIteratorState>)eb
                          withInt:(jint)index {
  PointList *pl = [((id<EdgeIteratorState>) nil_chk(eb)) fetchWayGeometryWithInt:2];
  for (jint j = 0; j < [((PointList *) nil_chk(pl)) getSize]; j++) {
    [((PointList *) nil_chk(val$points_)) addWithPointAccess:pl withInt:j];
  }
}

- (instancetype)initWithPointList:(PointList *)capture$0 {
  Path_$3_set_val$points_(self, capture$0);
  return [super init];
}

- (void)dealloc {
  RELEASE_(val$points_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(Path_$3 *)other {
  [super copyAllFieldsTo:other];
  Path_$3_set_val$points_(other, val$points_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "nextWithEdgeIteratorState:withInt:", "next", "V", 0x1, NULL },
    { "initWithPointList:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "val$points_", NULL, 0x1012, "Lcom.graphhopper.util.PointList;", NULL,  },
  };
  static const J2ObjcClassInfo _Path_$3 = { 1, "$3", "com.graphhopper.routing", "Path", 0x8000, 2, methods, 1, fields, 0, NULL};
  return &_Path_$3;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(Path_$3)

@implementation Path_$4

- (void)nextWithEdgeIteratorState:(id<EdgeIteratorState>)edge
                          withInt:(jint)index {
  jint adjNode = [((id<EdgeIteratorState>) nil_chk(edge)) getAdjNode];
  jint baseNode = [edge getBaseNode];
  jlong flags = [edge getFlags];
  jdouble adjLat = [((id<NodeAccess>) nil_chk(this$0_->nodeAccess_)) getLatitudeWithInt:adjNode];
  jdouble adjLon = [this$0_->nodeAccess_ getLongitudeWithInt:adjNode];
  jdouble latitude, longitude;
  PointList *wayGeo = [edge fetchWayGeometryWithInt:3];
  jboolean isRoundabout = [((id<FlagEncoder>) nil_chk(this$0_->encoder_)) isBoolWithLong:flags withInt:FlagEncoder_K_ROUNDABOUT];
  if ([((PointList *) nil_chk(wayGeo)) getSize] <= 2) {
    latitude = adjLat;
    longitude = adjLon;
  }
  else {
    latitude = [wayGeo getLatitudeWithInt:1];
    longitude = [wayGeo getLongitudeWithInt:1];
    NSAssert(JavaLangDouble_compareWithDouble_withDouble_(prevLat_, [this$0_->nodeAccess_ getLatitudeWithInt:baseNode]) == 0, @"com/graphhopper/routing/Path.java:402 condition failed: assert java.lang.Double.compare(prevLat, nodeAccess.getLatitude(baseNode)) == 0;");
    NSAssert(JavaLangDouble_compareWithDouble_withDouble_(prevLon_, [this$0_->nodeAccess_ getLongitudeWithInt:baseNode]) == 0, @"com/graphhopper/routing/Path.java:403 condition failed: assert java.lang.Double.compare(prevLon, nodeAccess.getLongitude(baseNode)) == 0;");
  }
  Path_$4_set_name_(self, [edge getName]);
  Path_$4_set_annotation_(self, [this$0_->encoder_ getAnnotationWithLong:flags withTranslation:val$tr_]);
  if ((prevName_ == nil) && (!isRoundabout)) {
    jint sign = Instruction_CONTINUE_ON_STREET;
    Path_$4_setAndConsume_prevInstruction_(self, [[Instruction alloc] initWithInt:sign withNSString:name_ withInstructionAnnotation:annotation_ withPointList:[[[PointList alloc] initWithInt:10 withBoolean:[this$0_->nodeAccess_ is3D]] autorelease]]);
    [((InstructionList *) nil_chk(val$ways_)) addWithInstruction:prevInstruction_];
    Path_$4_set_prevName_(self, name_);
    Path_$4_set_prevAnnotation_(self, annotation_);
  }
  else if (isRoundabout) {
    if (!prevInRoundabout_) {
      jint sign = Instruction_USE_ROUNDABOUT;
      RoundaboutInstruction *roundaboutInstruction = [[[RoundaboutInstruction alloc] initWithInt:sign withNSString:name_ withInstructionAnnotation:annotation_ withPointList:[[[PointList alloc] initWithInt:10 withBoolean:[this$0_->nodeAccess_ is3D]] autorelease]] autorelease];
      if (prevName_ != nil) {
        id<EdgeIterator> edgeIter = [((id<EdgeExplorer>) nil_chk(outEdgeExplorer_)) setBaseNodeWithInt:baseNode];
        while ([((id<EdgeIterator>) nil_chk(edgeIter)) next]) {
          if (([edgeIter getAdjNode] != prevNode_) && ![this$0_->encoder_ isBoolWithLong:[edgeIter getFlags] withInt:FlagEncoder_K_ROUNDABOUT]) {
            [roundaboutInstruction increaseExitNumber];
            break;
          }
        }
        prevOrientation_ = [((AngleCalc *) nil_chk(Path_get_AC_())) calcOrientationWithDouble:doublePrevLat_ withDouble:doublePrevLong_ withDouble:prevLat_ withDouble:prevLon_];
        jdouble orientation = [Path_get_AC_() calcOrientationWithDouble:prevLat_ withDouble:prevLon_ withDouble:latitude withDouble:longitude];
        orientation = [Path_get_AC_() alignOrientationWithDouble:prevOrientation_ withDouble:orientation];
        jdouble delta = (orientation - prevOrientation_);
        [roundaboutInstruction setDirOfRotationWithDouble:delta];
      }
      else {
        prevOrientation_ = [((AngleCalc *) nil_chk(Path_get_AC_())) calcOrientationWithDouble:prevLat_ withDouble:prevLon_ withDouble:latitude withDouble:longitude];
        Path_$4_set_prevName_(self, name_);
        Path_$4_set_prevAnnotation_(self, annotation_);
      }
      Path_$4_set_prevInstruction_(self, roundaboutInstruction);
      [((InstructionList *) nil_chk(val$ways_)) addWithInstruction:prevInstruction_];
    }
    id<EdgeIterator> edgeIter = [((id<EdgeExplorer>) nil_chk(outEdgeExplorer_)) setBaseNodeWithInt:adjNode];
    while ([((id<EdgeIterator>) nil_chk(edgeIter)) next]) {
      if (![this$0_->encoder_ isBoolWithLong:[edgeIter getFlags] withInt:FlagEncoder_K_ROUNDABOUT]) {
        [((RoundaboutInstruction *) nil_chk(((RoundaboutInstruction *) check_class_cast(prevInstruction_, [RoundaboutInstruction class])))) increaseExitNumber];
        break;
      }
    }
  }
  else if (prevInRoundabout_) {
    [((Instruction *) nil_chk(prevInstruction_)) setNameWithNSString:name_];
    jdouble orientation = [((AngleCalc *) nil_chk(Path_get_AC_())) calcOrientationWithDouble:prevLat_ withDouble:prevLon_ withDouble:latitude withDouble:longitude];
    orientation = [Path_get_AC_() alignOrientationWithDouble:prevOrientation_ withDouble:orientation];
    jdouble deltaInOut = (orientation - prevOrientation_);
    jdouble recentOrientation = [Path_get_AC_() calcOrientationWithDouble:doublePrevLat_ withDouble:doublePrevLong_ withDouble:prevLat_ withDouble:prevLon_];
    orientation = [Path_get_AC_() alignOrientationWithDouble:recentOrientation withDouble:orientation];
    jdouble deltaOut = (orientation - recentOrientation);
    Path_$4_set_prevInstruction_(self, [((RoundaboutInstruction *) nil_chk([((RoundaboutInstruction *) nil_chk([((RoundaboutInstruction *) check_class_cast(prevInstruction_, [RoundaboutInstruction class])) setRadianWithDouble:deltaInOut])) setDirOfRotationWithDouble:deltaOut])) setExited]);
    Path_$4_set_prevName_(self, name_);
    Path_$4_set_prevAnnotation_(self, annotation_);
  }
  else if ((![((NSString *) nil_chk(name_)) isEqual:prevName_]) || (![((InstructionAnnotation *) nil_chk(annotation_)) isEqual:prevAnnotation_])) {
    prevOrientation_ = [((AngleCalc *) nil_chk(Path_get_AC_())) calcOrientationWithDouble:doublePrevLat_ withDouble:doublePrevLong_ withDouble:prevLat_ withDouble:prevLon_];
    jdouble orientation = [Path_get_AC_() calcOrientationWithDouble:prevLat_ withDouble:prevLon_ withDouble:latitude withDouble:longitude];
    orientation = [Path_get_AC_() alignOrientationWithDouble:prevOrientation_ withDouble:orientation];
    jdouble delta = orientation - prevOrientation_;
    jdouble absDelta = JavaLangMath_absWithDouble_(delta);
    jint sign;
    if (absDelta < 0.2) {
      sign = Instruction_CONTINUE_ON_STREET;
    }
    else if (absDelta < 0.8) {
      if (delta > 0) sign = Instruction_TURN_SLIGHT_LEFT;
      else sign = Instruction_TURN_SLIGHT_RIGHT;
    }
    else if (absDelta < 1.8) {
      if (delta > 0) sign = Instruction_TURN_LEFT;
      else sign = Instruction_TURN_RIGHT;
    }
    else if (delta > 0) sign = Instruction_TURN_SHARP_LEFT;
    else sign = Instruction_TURN_SHARP_RIGHT;
    Path_$4_setAndConsume_prevInstruction_(self, [[Instruction alloc] initWithInt:sign withNSString:name_ withInstructionAnnotation:annotation_ withPointList:[[[PointList alloc] initWithInt:10 withBoolean:[this$0_->nodeAccess_ is3D]] autorelease]]);
    [((InstructionList *) nil_chk(val$ways_)) addWithInstruction:prevInstruction_];
    Path_$4_set_prevName_(self, name_);
    Path_$4_set_prevAnnotation_(self, annotation_);
  }
  Path_$4_updatePointsAndInstructionWithEdgeIteratorState_withPointList_(self, edge, wayGeo);
  if ([wayGeo getSize] <= 2) {
    doublePrevLat_ = prevLat_;
    doublePrevLong_ = prevLon_;
  }
  else {
    jint beforeLast = [wayGeo getSize] - 2;
    doublePrevLat_ = [wayGeo getLatitudeWithInt:beforeLast];
    doublePrevLong_ = [wayGeo getLongitudeWithInt:beforeLast];
  }
  prevInRoundabout_ = isRoundabout;
  prevNode_ = baseNode;
  prevLat_ = adjLat;
  prevLon_ = adjLon;
  jboolean lastEdge = index == [((id<GnuTroveListTIntList>) nil_chk(this$0_->edgeIds_)) size] - 1;
  if (lastEdge) {
    if (isRoundabout) {
      jdouble orientation = [((AngleCalc *) nil_chk(Path_get_AC_())) calcOrientationWithDouble:doublePrevLat_ withDouble:doublePrevLong_ withDouble:prevLat_ withDouble:prevLon_];
      orientation = [Path_get_AC_() alignOrientationWithDouble:prevOrientation_ withDouble:orientation];
      jdouble delta = (orientation - prevOrientation_);
      [((RoundaboutInstruction *) nil_chk(((RoundaboutInstruction *) check_class_cast(prevInstruction_, [RoundaboutInstruction class])))) setRadianWithDouble:delta];
    }
    [((InstructionList *) nil_chk(val$ways_)) addWithInstruction:[[[FinishInstruction alloc] initWithPointAccess:this$0_->nodeAccess_ withInt:adjNode] autorelease]];
  }
}

- (void)updatePointsAndInstructionWithEdgeIteratorState:(id<EdgeIteratorState>)edge
                                          withPointList:(PointList *)pl {
  Path_$4_updatePointsAndInstructionWithEdgeIteratorState_withPointList_(self, edge, pl);
}

- (instancetype)initWithPath:(Path *)outer$
                     withInt:(jint)capture$0
             withTranslation:(id<Translation>)capture$1
         withInstructionList:(InstructionList *)capture$2 {
  Path_$4_set_this$0_(self, outer$);
  val$tmpNode_ = capture$0;
  Path_$4_set_val$tr_(self, capture$1);
  Path_$4_set_val$ways_(self, capture$2);
  if (self = [super init]) {
    prevLat_ = [((id<NodeAccess>) nil_chk(outer$->nodeAccess_)) getLatitudeWithInt:val$tmpNode_];
    prevLon_ = [outer$->nodeAccess_ getLongitudeWithInt:val$tmpNode_];
    prevNode_ = -1;
    prevInRoundabout_ = NO;
    Path_$4_set_prevName_(self, nil);
    Path_$4_set_outEdgeExplorer_(self, [((id<Graph>) nil_chk(outer$->graph_)) createEdgeExplorerWithEdgeFilter:[[[DefaultEdgeFilter alloc] initWithFlagEncoder:outer$->encoder_ withBoolean:NO withBoolean:YES] autorelease]]);
  }
  return self;
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(prevInstruction_);
  RELEASE_(name_);
  RELEASE_(prevName_);
  RELEASE_(annotation_);
  RELEASE_(prevAnnotation_);
  RELEASE_(outEdgeExplorer_);
  RELEASE_(val$tr_);
  RELEASE_(val$ways_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(Path_$4 *)other {
  [super copyAllFieldsTo:other];
  Path_$4_set_this$0_(other, this$0_);
  other->prevLat_ = prevLat_;
  other->prevLon_ = prevLon_;
  other->doublePrevLat_ = doublePrevLat_;
  other->doublePrevLong_ = doublePrevLong_;
  other->prevNode_ = prevNode_;
  other->prevOrientation_ = prevOrientation_;
  Path_$4_set_prevInstruction_(other, prevInstruction_);
  other->prevInRoundabout_ = prevInRoundabout_;
  Path_$4_set_name_(other, name_);
  Path_$4_set_prevName_(other, prevName_);
  Path_$4_set_annotation_(other, annotation_);
  Path_$4_set_prevAnnotation_(other, prevAnnotation_);
  Path_$4_set_outEdgeExplorer_(other, outEdgeExplorer_);
  other->val$tmpNode_ = val$tmpNode_;
  Path_$4_set_val$tr_(other, val$tr_);
  Path_$4_set_val$ways_(other, val$ways_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "nextWithEdgeIteratorState:withInt:", "next", "V", 0x1, NULL },
    { "updatePointsAndInstructionWithEdgeIteratorState:withPointList:", "updatePointsAndInstruction", "V", 0x2, NULL },
    { "initWithPath:withInt:withTranslation:withInstructionList:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lcom.graphhopper.routing.Path;", NULL,  },
    { "prevLat_", NULL, 0x2, "D", NULL,  },
    { "prevLon_", NULL, 0x2, "D", NULL,  },
    { "doublePrevLat_", NULL, 0x2, "D", NULL,  },
    { "doublePrevLong_", NULL, 0x2, "D", NULL,  },
    { "prevNode_", NULL, 0x2, "I", NULL,  },
    { "prevOrientation_", NULL, 0x2, "D", NULL,  },
    { "prevInstruction_", NULL, 0x2, "Lcom.graphhopper.util.Instruction;", NULL,  },
    { "prevInRoundabout_", NULL, 0x2, "Z", NULL,  },
    { "name_", NULL, 0x2, "Ljava.lang.String;", NULL,  },
    { "prevName_", NULL, 0x2, "Ljava.lang.String;", NULL,  },
    { "annotation_", NULL, 0x2, "Lcom.graphhopper.util.InstructionAnnotation;", NULL,  },
    { "prevAnnotation_", NULL, 0x2, "Lcom.graphhopper.util.InstructionAnnotation;", NULL,  },
    { "outEdgeExplorer_", NULL, 0x2, "Lcom.graphhopper.util.EdgeExplorer;", NULL,  },
    { "val$tmpNode_", NULL, 0x1012, "I", NULL,  },
    { "val$tr_", NULL, 0x1012, "Lcom.graphhopper.util.Translation;", NULL,  },
    { "val$ways_", NULL, 0x1012, "Lcom.graphhopper.util.InstructionList;", NULL,  },
  };
  static const J2ObjcClassInfo _Path_$4 = { 1, "$4", "com.graphhopper.routing", "Path", 0x8000, 3, methods, 17, fields, 0, NULL};
  return &_Path_$4;
}

@end

void Path_$4_updatePointsAndInstructionWithEdgeIteratorState_withPointList_(Path_$4 *self, id<EdgeIteratorState> edge, PointList *pl) {
  jint len = [((PointList *) nil_chk(pl)) size] - 1;
  for (jint i = 0; i < len; i++) {
    [((PointList *) nil_chk([((Instruction *) nil_chk(self->prevInstruction_)) getPoints])) addWithPointAccess:pl withInt:i];
  }
  jdouble newDist = [((id<EdgeIteratorState>) nil_chk(edge)) getDistance];
  [self->prevInstruction_ setDistanceWithDouble:newDist + [((Instruction *) nil_chk(self->prevInstruction_)) getDistance]];
  [self->prevInstruction_ setTimeWithLong:[((id<ComGraphhopperRoutingWeightingWeighting>) nil_chk(self->this$0_->weighting_)) calcMillisWithEdgeIteratorState:edge withBoolean:NO withInt:EdgeIterator_NO_EDGE] + [self->prevInstruction_ getTime]];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(Path_$4)
