//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/coll/GHTreeMapComposed.h"
#include "com/graphhopper/routing/AStar.h"
#include "com/graphhopper/routing/AStarBidirection.h"
#include "com/graphhopper/routing/AbstractBidirAlgo.h"
#include "com/graphhopper/routing/AlgorithmOptions.h"
#include "com/graphhopper/routing/DijkstraBidirectionRef.h"
#include "com/graphhopper/routing/DijkstraOneToMany.h"
#include "com/graphhopper/routing/Path.h"
#include "com/graphhopper/routing/PathBidirRef.h"
#include "com/graphhopper/routing/RoutingAlgorithm.h"
#include "com/graphhopper/routing/RoutingAlgorithmFactorySimple.h"
#include "com/graphhopper/routing/ch/Path4CH.h"
#include "com/graphhopper/routing/ch/PreparationWeighting.h"
#include "com/graphhopper/routing/ch/PrepareContractionHierarchies.h"
#include "com/graphhopper/routing/ch/PrepareEncoder.h"
#include "com/graphhopper/routing/util/AllCHEdgesIterator.h"
#include "com/graphhopper/routing/util/AllEdgesIterator.h"
#include "com/graphhopper/routing/util/DefaultEdgeFilter.h"
#include "com/graphhopper/routing/util/EdgeFilter.h"
#include "com/graphhopper/routing/util/FlagEncoder.h"
#include "com/graphhopper/routing/util/LevelEdgeFilter.h"
#include "com/graphhopper/routing/util/TraversalMode.h"
#include "com/graphhopper/routing/weighting/AbstractWeighting.h"
#include "com/graphhopper/routing/weighting/WeightApproximator.h"
#include "com/graphhopper/routing/weighting/Weighting.h"
#include "com/graphhopper/storage/CHGraph.h"
#include "com/graphhopper/storage/CHGraphImpl.h"
#include "com/graphhopper/storage/DataAccess.h"
#include "com/graphhopper/storage/Directory.h"
#include "com/graphhopper/storage/Graph.h"
#include "com/graphhopper/storage/GraphHopperStorage.h"
#include "com/graphhopper/storage/NodeAccess.h"
#include "com/graphhopper/storage/SPTEntry.h"
#include "com/graphhopper/util/CHEdgeExplorer.h"
#include "com/graphhopper/util/CHEdgeIterator.h"
#include "com/graphhopper/util/CHEdgeIteratorState.h"
#include "com/graphhopper/util/EdgeIterator.h"
#include "com/graphhopper/util/EdgeIteratorState.h"
#include "com/graphhopper/util/GHUtility.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/Parameters.h"
#include "com/graphhopper/util/StopWatch.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/util/HashMap.h"
#include "java/util/Map.h"
#include "java/util/Random.h"
#include "java/util/Set.h"
#include "org/slf4j/Logger.h"
#include "org/slf4j/LoggerFactory.h"

__attribute__((unused)) static NSString *PrepareContractionHierarchies_getTimesAsString(PrepareContractionHierarchies *self);
__attribute__((unused)) static void PrepareContractionHierarchies_setOrigEdgeCountWithInt_withInt_(PrepareContractionHierarchies *self, jint edgeId, jint value);
__attribute__((unused)) static jint PrepareContractionHierarchies_getOrigEdgeCountWithInt_(PrepareContractionHierarchies *self, jint edgeId);
__attribute__((unused)) static AStarBidirection *PrepareContractionHierarchies_createAStarBidirectionWithGraph_(PrepareContractionHierarchies *self, id<Graph> graph);
__attribute__((unused)) static AbstractBidirAlgo *PrepareContractionHierarchies_createDijkstraBidirectionWithGraph_(PrepareContractionHierarchies *self, id<Graph> graph);

@interface PrepareContractionHierarchies () {
 @public
  id<OrgSlf4jLogger> logger_;
  PreparationWeighting *prepareWeighting_;
  TraversalModeEnum *traversalMode_;
  LevelEdgeFilter *levelFilter_;
  GraphHopperStorage *ghStorage_;
  CHGraphImpl *prepareGraph_;
  id<DataAccess> originalEdges_;
  id<JavaUtilMap> shortcuts_;
  JavaUtilRandom *rand_;
  StopWatch *allSW_;
  id<CHEdgeExplorer> vehicleInExplorer_;
  id<CHEdgeExplorer> vehicleOutExplorer_;
  id<CHEdgeExplorer> vehicleAllExplorer_;
  id<CHEdgeExplorer> vehicleAllTmpExplorer_;
  id<CHEdgeExplorer> calcPrioAllExplorer_;
  jint maxLevel_;
  GHTreeMapComposed *sortedNodes_;
  IOSIntArray *oldPriorities_;
  PrepareContractionHierarchies_IgnoreNodeFilter *ignoreNodeFilter_;
  DijkstraOneToMany *prepareAlgo_;
  jlong counter_;
  jint newShortcuts_;
  jlong dijkstraCount_;
  jdouble meanDegree_;
  StopWatch *dijkstraSW_;
  jint periodicUpdatesPercentage_;
  jint lastNodesLazyUpdatePercentage_;
  jint neighborUpdatePercentage_;
  jdouble nodesContractedPercentage_;
  jdouble logMessagesPercentage_;
  jdouble dijkstraTime_;
  jdouble periodTime_;
  jdouble lazyTime_;
  jdouble neighborTime_;
  jint maxEdgesCount_;
}

- (NSString *)getTimesAsString;

- (void)setOrigEdgeCountWithInt:(jint)edgeId
                        withInt:(jint)value;

- (jint)getOrigEdgeCountWithInt:(jint)edgeId;

- (AStarBidirection *)createAStarBidirectionWithGraph:(id<Graph>)graph;

- (AbstractBidirAlgo *)createDijkstraBidirectionWithGraph:(id<Graph>)graph;
@end

J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, logger_, id<OrgSlf4jLogger>)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, prepareWeighting_, PreparationWeighting *)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, traversalMode_, TraversalModeEnum *)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, levelFilter_, LevelEdgeFilter *)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, ghStorage_, GraphHopperStorage *)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, prepareGraph_, CHGraphImpl *)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, originalEdges_, id<DataAccess>)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, shortcuts_, id<JavaUtilMap>)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, rand_, JavaUtilRandom *)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, allSW_, StopWatch *)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, vehicleInExplorer_, id<CHEdgeExplorer>)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, vehicleOutExplorer_, id<CHEdgeExplorer>)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, vehicleAllExplorer_, id<CHEdgeExplorer>)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, vehicleAllTmpExplorer_, id<CHEdgeExplorer>)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, calcPrioAllExplorer_, id<CHEdgeExplorer>)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, sortedNodes_, GHTreeMapComposed *)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, oldPriorities_, IOSIntArray *)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, ignoreNodeFilter_, PrepareContractionHierarchies_IgnoreNodeFilter *)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, prepareAlgo_, DijkstraOneToMany *)
J2OBJC_FIELD_SETTER(PrepareContractionHierarchies, dijkstraSW_, StopWatch *)

@interface PrepareContractionHierarchies_CalcShortcutHandler () {
 @public
  PrepareContractionHierarchies *this$0_;
}
@end

J2OBJC_FIELD_SETTER(PrepareContractionHierarchies_CalcShortcutHandler, this$0_, PrepareContractionHierarchies *)

@interface PrepareContractionHierarchies_AddShortcutHandler () {
 @public
  PrepareContractionHierarchies *this$0_;
}
@end

J2OBJC_FIELD_SETTER(PrepareContractionHierarchies_AddShortcutHandler, this$0_, PrepareContractionHierarchies *)

@interface PrepareContractionHierarchies_$1 () {
 @public
  id<EdgeFilter> val$allFilter_;
}
@end

J2OBJC_FIELD_SETTER(PrepareContractionHierarchies_$1, val$allFilter_, id<EdgeFilter>)

@interface PrepareContractionHierarchies_$2 () {
 @public
  PrepareContractionHierarchies *this$0_;
}
@end

J2OBJC_FIELD_SETTER(PrepareContractionHierarchies_$2, this$0_, PrepareContractionHierarchies *)

@interface PrepareContractionHierarchies_$3 () {
 @public
  PrepareContractionHierarchies *this$0_;
}
@end

J2OBJC_FIELD_SETTER(PrepareContractionHierarchies_$3, this$0_, PrepareContractionHierarchies *)

@implementation PrepareContractionHierarchies

- (instancetype)initWithDirectory:(id<Directory>)dir
           withGraphHopperStorage:(GraphHopperStorage *)ghStorage
                      withCHGraph:(id<CHGraph>)chGraph
withComGraphhopperRoutingWeightingWeighting:(id<ComGraphhopperRoutingWeightingWeighting>)weighting
            withTraversalModeEnum:(TraversalModeEnum *)traversalMode {
  if (self = [super init]) {
    PrepareContractionHierarchies_set_logger_(self, OrgSlf4jLoggerFactory_getLoggerWithIOSClass_([self getClass]));
    PrepareContractionHierarchies_setAndConsume_shortcuts_(self, [[JavaUtilHashMap alloc] init]);
    PrepareContractionHierarchies_setAndConsume_rand_(self, [[JavaUtilRandom alloc] initWithLong:123]);
    PrepareContractionHierarchies_setAndConsume_allSW_(self, [[StopWatch alloc] init]);
    PrepareContractionHierarchies_setAndConsume_addScHandler_(self, [[PrepareContractionHierarchies_AddShortcutHandler alloc] initWithPrepareContractionHierarchies:self]);
    PrepareContractionHierarchies_setAndConsume_calcScHandler_(self, [[PrepareContractionHierarchies_CalcShortcutHandler alloc] initWithPrepareContractionHierarchies:self]);
    PrepareContractionHierarchies_setAndConsume_dijkstraSW_(self, [[StopWatch alloc] init]);
    periodicUpdatesPercentage_ = 20;
    lastNodesLazyUpdatePercentage_ = 10;
    neighborUpdatePercentage_ = 20;
    nodesContractedPercentage_ = 100;
    logMessagesPercentage_ = 20;
    PrepareContractionHierarchies_set_ghStorage_(self, ghStorage);
    PrepareContractionHierarchies_set_prepareGraph_(self, (CHGraphImpl *) check_class_cast(chGraph, [CHGraphImpl class]));
    PrepareContractionHierarchies_set_traversalMode_(self, traversalMode);
    PrepareContractionHierarchies_setAndConsume_levelFilter_(self, [[LevelEdgeFilter alloc] initWithCHGraph:prepareGraph_]);
    PrepareContractionHierarchies_setAndConsume_prepareWeighting_(self, [[PreparationWeighting alloc] initWithComGraphhopperRoutingWeightingWeighting:weighting]);
    PrepareContractionHierarchies_set_originalEdges_(self, [((id<Directory>) nil_chk(dir)) findWithNSString:JreStrcat("$$", @"original_edges_", ComGraphhopperRoutingWeightingAbstractWeighting_weightingToFileNameWithComGraphhopperRoutingWeightingWeighting_(weighting))]);
    [((id<DataAccess>) nil_chk(originalEdges_)) createWithLong:1000];
  }
  return self;
}

- (PrepareContractionHierarchies *)setPeriodicUpdatesWithInt:(jint)periodicUpdates {
  if (periodicUpdates < 0) return self;
  if (periodicUpdates > 100) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"periodicUpdates has to be in [0, 100], to disable it use 0"] autorelease];
  self->periodicUpdatesPercentage_ = periodicUpdates;
  return self;
}

- (PrepareContractionHierarchies *)setLazyUpdatesWithInt:(jint)lazyUpdates {
  if (lazyUpdates < 0) return self;
  if (lazyUpdates > 100) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"lazyUpdates has to be in [0, 100], to disable it use 0"] autorelease];
  self->lastNodesLazyUpdatePercentage_ = lazyUpdates;
  return self;
}

- (PrepareContractionHierarchies *)setNeighborUpdatesWithInt:(jint)neighborUpdates {
  if (neighborUpdates < 0) return self;
  if (neighborUpdates > 100) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"neighborUpdates has to be in [0, 100], to disable it use 0"] autorelease];
  self->neighborUpdatePercentage_ = neighborUpdates;
  return self;
}

- (PrepareContractionHierarchies *)setLogMessagesWithDouble:(jdouble)logMessages {
  if (logMessages >= 0) self->logMessagesPercentage_ = logMessages;
  return self;
}

- (PrepareContractionHierarchies *)setContractedNodesWithDouble:(jdouble)nodesContracted {
  if (nodesContracted < 0) return self;
  if (nodesContracted > 100) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"setNodesContracted can be 100% maximum"] autorelease];
  self->nodesContractedPercentage_ = nodesContracted;
  return self;
}

- (void)doWork {
  if (prepareWeighting_ == nil) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"No weight calculation set."] autorelease];
  [((StopWatch *) nil_chk(allSW_)) start];
  [super doWork];
  [self initFromGraph];
  if (![self prepareNodes]) return;
  [self contractNodes];
}

- (jboolean)prepareNodes {
  jint nodes = [((CHGraphImpl *) nil_chk(prepareGraph_)) getNodes];
  for (jint node = 0; node < nodes; node++) {
    [prepareGraph_ setLevelWithInt:node withInt:maxLevel_];
  }
  for (jint node = 0; node < nodes; node++) {
    jint priority = *IOSIntArray_GetRef(nil_chk(oldPriorities_), node) = [self calculatePriorityWithInt:node];
    [((GHTreeMapComposed *) nil_chk(sortedNodes_)) insertWithInt:node withInt:priority];
  }
  if ([((GHTreeMapComposed *) nil_chk(sortedNodes_)) isEmpty]) return NO;
  return YES;
}

- (void)contractNodes {
  meanDegree_ = [((id<AllCHEdgesIterator>) nil_chk([((CHGraphImpl *) nil_chk(prepareGraph_)) getAllEdges])) getMaxId] / [prepareGraph_ getNodes];
  jint level = 1;
  counter_ = 0;
  jint initSize = [((GHTreeMapComposed *) nil_chk(sortedNodes_)) getSize];
  jlong logSize = JavaLangMath_roundWithDouble_(JavaLangMath_maxWithDouble_withDouble_(10, [sortedNodes_ getSize] / 100 * logMessagesPercentage_));
  if (logMessagesPercentage_ == 0) logSize = JavaLangInteger_MAX_VALUE;
  jboolean periodicUpdate = YES;
  StopWatch *periodSW = [[[StopWatch alloc] init] autorelease];
  jint updateCounter = 0;
  jlong periodicUpdatesCount = JavaLangMath_roundWithDouble_(JavaLangMath_maxWithDouble_withDouble_(10, [sortedNodes_ getSize] / 100.0 * periodicUpdatesPercentage_));
  if (periodicUpdatesPercentage_ == 0) periodicUpdate = NO;
  jlong lastNodesLazyUpdates = JavaLangMath_roundWithDouble_([sortedNodes_ getSize] / 100.0 * lastNodesLazyUpdatePercentage_);
  jlong nodesToAvoidContract = JavaLangMath_roundWithDouble_((100 - nodesContractedPercentage_) / 100 * [sortedNodes_ getSize]);
  StopWatch *lazySW = [[[StopWatch alloc] init] autorelease];
  jboolean neighborUpdate = YES;
  if (neighborUpdatePercentage_ == 0) neighborUpdate = NO;
  StopWatch *neighborSW = [[[StopWatch alloc] init] autorelease];
  while (![sortedNodes_ isEmpty]) {
    if (periodicUpdate && counter_ > 0 && counter_ % periodicUpdatesCount == 0) {
      [periodSW start];
      [sortedNodes_ clear];
      jint len = [prepareGraph_ getNodes];
      for (jint node = 0; node < len; node++) {
        if ([prepareGraph_ getLevelWithInt:node] != maxLevel_) continue;
        jint priority = *IOSIntArray_GetRef(nil_chk(oldPriorities_), node) = [self calculatePriorityWithInt:node];
        [sortedNodes_ insertWithInt:node withInt:priority];
      }
      [periodSW stop];
      updateCounter++;
      if ([sortedNodes_ isEmpty]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Cannot prepare as no unprepared nodes where found. Called preparation twice?"] autorelease];
    }
    if (counter_ % logSize == 0) {
      dijkstraTime_ += [((StopWatch *) nil_chk(dijkstraSW_)) getSeconds];
      periodTime_ += [periodSW getSeconds];
      lazyTime_ += [lazySW getSeconds];
      neighborTime_ += [neighborSW getSeconds];
      [((id<OrgSlf4jLogger>) nil_chk(logger_)) infoWithNSString:JreStrcat("$$I$$$$$$$$$J$$$$", Helper_nfWithLong_(counter_), @", updates:", updateCounter, @", nodes: ", Helper_nfWithLong_([sortedNodes_ getSize]), @", shortcuts:", Helper_nfWithLong_(newShortcuts_), @", dijkstras:", Helper_nfWithLong_(dijkstraCount_), @", ", PrepareContractionHierarchies_getTimesAsString(self), @", meanDegree:", J2ObjCFpToLong(meanDegree_), @", algo:", [((DijkstraOneToMany *) nil_chk(prepareAlgo_)) getMemoryUsageAsString], @", ", Helper_getMemInfo())];
      PrepareContractionHierarchies_setAndConsume_dijkstraSW_(self, [[StopWatch alloc] init]);
      periodSW = [[[StopWatch alloc] init] autorelease];
      lazySW = [[[StopWatch alloc] init] autorelease];
      neighborSW = [[[StopWatch alloc] init] autorelease];
    }
    counter_++;
    jint polledNode = [sortedNodes_ pollKey];
    if (![sortedNodes_ isEmpty] && [sortedNodes_ getSize] < lastNodesLazyUpdates) {
      [lazySW start];
      jint priority = *IOSIntArray_GetRef(nil_chk(oldPriorities_), polledNode) = [self calculatePriorityWithInt:polledNode];
      if (priority > [sortedNodes_ peekValue]) {
        [sortedNodes_ insertWithInt:polledNode withInt:priority];
        [lazySW stop];
        continue;
      }
      [lazySW stop];
    }
    newShortcuts_ += [self addShortcutsWithInt:polledNode];
    [prepareGraph_ setLevelWithInt:polledNode withInt:level];
    level++;
    if ([sortedNodes_ getSize] < nodesToAvoidContract) break;
    id<CHEdgeIterator> iter = [((id<CHEdgeExplorer>) nil_chk(vehicleAllExplorer_)) setBaseNodeWithInt:polledNode];
    while ([((id<CHEdgeIterator>) nil_chk(iter)) next]) {
      jint nn = [iter getAdjNode];
      if ([prepareGraph_ getLevelWithInt:nn] != maxLevel_) continue;
      if (neighborUpdate && [((JavaUtilRandom *) nil_chk(rand_)) nextIntWithInt:100] < neighborUpdatePercentage_) {
        [neighborSW start];
        jint oldPrio = IOSIntArray_Get(nil_chk(oldPriorities_), nn);
        jint priority = *IOSIntArray_GetRef(oldPriorities_, nn) = [self calculatePriorityWithInt:nn];
        if (priority != oldPrio) [sortedNodes_ updateWithInt:nn withInt:oldPrio withInt:priority];
        [neighborSW stop];
      }
      [prepareGraph_ disconnectWithCHEdgeExplorer:vehicleAllTmpExplorer_ withEdgeIteratorState:iter];
    }
  }
  [self close];
  dijkstraTime_ += [((StopWatch *) nil_chk(dijkstraSW_)) getSeconds];
  periodTime_ += [periodSW getSeconds];
  lazyTime_ += [lazySW getSeconds];
  neighborTime_ += [neighborSW getSeconds];
  [((id<OrgSlf4jLogger>) nil_chk(logger_)) infoWithNSString:JreStrcat("$I$$$@$J$$$J$I$I$I$I$$", @"took:", J2ObjCFpToInt([((StopWatch *) nil_chk([((StopWatch *) nil_chk(allSW_)) stop])) getSeconds]), @", new shortcuts: ", Helper_nfWithLong_(newShortcuts_), @", ", prepareWeighting_, @", dijkstras:", dijkstraCount_, @", ", PrepareContractionHierarchies_getTimesAsString(self), @", meanDegree:", J2ObjCFpToLong(meanDegree_), @", initSize:", initSize, @", periodic:", periodicUpdatesPercentage_, @", lazy:", lastNodesLazyUpdatePercentage_, @", neighbor:", neighborUpdatePercentage_, @", ", Helper_getMemInfo())];
}

- (jlong)getDijkstraCount {
  return dijkstraCount_;
}

- (jdouble)getLazyTime {
  return lazyTime_;
}

- (jdouble)getPeriodTime {
  return periodTime_;
}

- (jdouble)getDijkstraTime {
  return dijkstraTime_;
}

- (jdouble)getNeighborTime {
  return neighborTime_;
}

- (id<ComGraphhopperRoutingWeightingWeighting>)getWeighting {
  return [((CHGraphImpl *) nil_chk(prepareGraph_)) getWeighting];
}

- (void)close {
  [((DijkstraOneToMany *) nil_chk(prepareAlgo_)) close];
  [((id<DataAccess>) nil_chk(originalEdges_)) close];
  PrepareContractionHierarchies_set_sortedNodes_(self, nil);
  PrepareContractionHierarchies_set_oldPriorities_(self, nil);
}

- (NSString *)getTimesAsString {
  return PrepareContractionHierarchies_getTimesAsString(self);
}

- (id<JavaUtilSet>)testFindShortcutsWithInt:(jint)node {
  [self findShortcutsWithPrepareContractionHierarchies_ShortcutHandler:[((PrepareContractionHierarchies_AddShortcutHandler *) nil_chk(addScHandler_)) setNodeWithInt:node]];
  return [((id<JavaUtilMap>) nil_chk(shortcuts_)) keySet];
}

- (jint)calculatePriorityWithInt:(jint)v {
  [self findShortcutsWithPrepareContractionHierarchies_ShortcutHandler:[((PrepareContractionHierarchies_CalcShortcutHandler *) nil_chk(calcScHandler_)) setNodeWithInt:v]];
  jint originalEdgesCount = calcScHandler_->originalEdgesCount_;
  jint contractedNeighbors = 0;
  jint degree = 0;
  id<CHEdgeIterator> iter = [((id<CHEdgeExplorer>) nil_chk(calcPrioAllExplorer_)) setBaseNodeWithInt:v];
  while ([((id<CHEdgeIterator>) nil_chk(iter)) next]) {
    degree++;
    if ([iter isShortcut]) contractedNeighbors++;
  }
  jint edgeDifference = calcScHandler_->shortcuts_ - degree;
  return 10 * edgeDifference + originalEdgesCount + contractedNeighbors;
}

- (void)findShortcutsWithPrepareContractionHierarchies_ShortcutHandler:(id<PrepareContractionHierarchies_ShortcutHandler>)sch {
  jlong tmpDegreeCounter = 0;
  id<EdgeIterator> incomingEdges = [((id<CHEdgeExplorer>) nil_chk(vehicleInExplorer_)) setBaseNodeWithInt:[((id<PrepareContractionHierarchies_ShortcutHandler>) nil_chk(sch)) getNode]];
  while ([((id<EdgeIterator>) nil_chk(incomingEdges)) next]) {
    jint u_fromNode = [incomingEdges getAdjNode];
    if ([((CHGraphImpl *) nil_chk(prepareGraph_)) getLevelWithInt:u_fromNode] != maxLevel_) continue;
    jdouble v_u_dist = [incomingEdges getDistance];
    jdouble v_u_weight = [((PreparationWeighting *) nil_chk(prepareWeighting_)) calcWeightWithEdgeIteratorState:incomingEdges withBoolean:YES withInt:EdgeIterator_NO_EDGE];
    jint skippedEdge1 = [incomingEdges getEdge];
    jint incomingEdgeOrigCount = PrepareContractionHierarchies_getOrigEdgeCountWithInt_(self, skippedEdge1);
    id<EdgeIterator> outgoingEdges = [((id<CHEdgeExplorer>) nil_chk(vehicleOutExplorer_)) setBaseNodeWithInt:[sch getNode]];
    [((DijkstraOneToMany *) nil_chk(prepareAlgo_)) clear];
    tmpDegreeCounter++;
    while ([((id<EdgeIterator>) nil_chk(outgoingEdges)) next]) {
      jint w_toNode = [outgoingEdges getAdjNode];
      if ([prepareGraph_ getLevelWithInt:w_toNode] != maxLevel_ || u_fromNode == w_toNode) continue;
      jdouble existingDirectWeight = v_u_weight + [prepareWeighting_ calcWeightWithEdgeIteratorState:outgoingEdges withBoolean:NO withInt:[incomingEdges getEdge]];
      if (JavaLangDouble_isNaNWithDouble_(existingDirectWeight)) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$$$$$D", @"Weighting should never return NaN values, in:", [self getCoordsWithEdgeIteratorState:incomingEdges withGraph:prepareGraph_], @", out:", [self getCoordsWithEdgeIteratorState:outgoingEdges withGraph:prepareGraph_], @", dist:", [outgoingEdges getDistance])] autorelease];
      if (JavaLangDouble_isInfiniteWithDouble_(existingDirectWeight)) continue;
      jdouble existingDistSum = v_u_dist + [outgoingEdges getDistance];
      [prepareAlgo_ setWeightLimitWithDouble:existingDirectWeight];
      [prepareAlgo_ setMaxVisitedNodesWithInt:J2ObjCFpToInt(meanDegree_) * 100];
      [prepareAlgo_ setEdgeFilterWithEdgeFilter:[((PrepareContractionHierarchies_IgnoreNodeFilter *) nil_chk(ignoreNodeFilter_)) setAvoidNodeWithInt:[sch getNode]]];
      [((StopWatch *) nil_chk(dijkstraSW_)) start];
      dijkstraCount_++;
      jint endNode = [prepareAlgo_ findEndNodeWithInt:u_fromNode withInt:w_toNode];
      [dijkstraSW_ stop];
      if (endNode == w_toNode && [prepareAlgo_ getWeightWithInt:endNode] <= existingDirectWeight) continue;
      [sch foundShortcutWithInt:u_fromNode withInt:w_toNode withDouble:existingDirectWeight withDouble:existingDistSum withEdgeIterator:outgoingEdges withInt:skippedEdge1 withInt:incomingEdgeOrigCount];
    }
  }
  if ([sch isKindOfClass:[PrepareContractionHierarchies_AddShortcutHandler class]]) {
    meanDegree_ = (meanDegree_ * 2 + tmpDegreeCounter) / 3;
  }
}

- (jint)addShortcutsWithInt:(jint)v {
  [((id<JavaUtilMap>) nil_chk(shortcuts_)) clear];
  [self findShortcutsWithPrepareContractionHierarchies_ShortcutHandler:[((PrepareContractionHierarchies_AddShortcutHandler *) nil_chk(addScHandler_)) setNodeWithInt:v]];
  jint tmpNewShortcuts = 0;
  for (PrepareContractionHierarchies_Shortcut * __strong sc in nil_chk([shortcuts_ keySet])) {
    {
      jboolean updatedInGraph = NO;
      id<CHEdgeIterator> iter = [((id<CHEdgeExplorer>) nil_chk(vehicleOutExplorer_)) setBaseNodeWithInt:((PrepareContractionHierarchies_Shortcut *) nil_chk(sc))->from_];
      while ([((id<CHEdgeIterator>) nil_chk(iter)) next]) {
        if ([iter isShortcut] && [iter getAdjNode] == sc->to_ && [iter canBeOverwrittenWithLong:sc->flags_]) {
          if (sc->weight_ >= [((PreparationWeighting *) nil_chk(prepareWeighting_)) calcWeightWithEdgeIteratorState:iter withBoolean:NO withInt:EdgeIterator_NO_EDGE]) goto continue_NEXT_SC;
          if ([iter getEdge] == sc->skippedEdge1_ || [iter getEdge] == sc->skippedEdge2_) {
            @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$I$I$@C$$@$$$$$@", @"Shortcut cannot update itself! ", [iter getEdge], @", skipEdge1:", sc->skippedEdge1_, @", skipEdge2:", sc->skippedEdge2_, @", edge ", iter, ':', [self getCoordsWithEdgeIteratorState:iter withGraph:prepareGraph_], @", sc:", sc, @", skippedEdge1: ", [self getCoordsWithEdgeIteratorState:[((CHGraphImpl *) nil_chk(prepareGraph_)) getEdgeIteratorStateWithInt:sc->skippedEdge1_ withInt:sc->from_] withGraph:prepareGraph_], @", skippedEdge2: ", [self getCoordsWithEdgeIteratorState:[prepareGraph_ getEdgeIteratorStateWithInt:sc->skippedEdge2_ withInt:sc->to_] withGraph:prepareGraph_], @", neighbors:", GHUtility_getNeighborsWithEdgeIterator_(iter))] autorelease];
          }
          [iter setFlagsWithLong:sc->flags_];
          [iter setWeightWithDouble:sc->weight_];
          [iter setDistanceWithDouble:sc->dist_];
          [iter setSkippedEdgesWithInt:sc->skippedEdge1_ withInt:sc->skippedEdge2_];
          PrepareContractionHierarchies_setOrigEdgeCountWithInt_withInt_(self, [iter getEdge], sc->originalEdges_);
          updatedInGraph = YES;
          break;
        }
      }
      if (!updatedInGraph) {
        id<CHEdgeIteratorState> edgeState = [((CHGraphImpl *) nil_chk(prepareGraph_)) shortcutWithInt:sc->from_ withInt:sc->to_];
        [((id<CHEdgeIteratorState>) nil_chk(edgeState)) setFlagsWithLong:sc->flags_];
        [edgeState setWeightWithDouble:sc->weight_];
        [edgeState setDistanceWithDouble:sc->dist_];
        [edgeState setSkippedEdgesWithInt:sc->skippedEdge1_ withInt:sc->skippedEdge2_];
        PrepareContractionHierarchies_setOrigEdgeCountWithInt_withInt_(self, [edgeState getEdge], sc->originalEdges_);
        tmpNewShortcuts++;
      }
    }
    continue_NEXT_SC: ;
  }
  return tmpNewShortcuts;
}

- (NSString *)getCoordsWithEdgeIteratorState:(id<EdgeIteratorState>)e
                                   withGraph:(id<Graph>)g {
  id<NodeAccess> na = [((id<Graph>) nil_chk(g)) getNodeAccess];
  jint base = [((id<EdgeIteratorState>) nil_chk(e)) getBaseNode];
  jint adj = [e getAdjNode];
  return JreStrcat("I$I$I$DCD$DCD", base, @"->", adj, @" (", [e getEdge], @"); ", [((id<NodeAccess>) nil_chk(na)) getLatWithInt:base], ',', [na getLonWithInt:base], @" -> ", [na getLatWithInt:adj], ',', [na getLonWithInt:adj]);
}

- (PrepareContractionHierarchies *)initFromGraph {
  [((GraphHopperStorage *) nil_chk(ghStorage_)) freeze];
  maxEdgesCount_ = [((id<AllEdgesIterator>) nil_chk([ghStorage_ getAllEdges])) getMaxId];
  id<FlagEncoder> prepareFlagEncoder = [((PreparationWeighting *) nil_chk(prepareWeighting_)) getFlagEncoder];
  PrepareContractionHierarchies_set_vehicleInExplorer_(self, [((CHGraphImpl *) nil_chk(prepareGraph_)) createEdgeExplorerWithEdgeFilter:[[[DefaultEdgeFilter alloc] initWithFlagEncoder:prepareFlagEncoder withBoolean:YES withBoolean:NO] autorelease]]);
  PrepareContractionHierarchies_set_vehicleOutExplorer_(self, [prepareGraph_ createEdgeExplorerWithEdgeFilter:[[[DefaultEdgeFilter alloc] initWithFlagEncoder:prepareFlagEncoder withBoolean:NO withBoolean:YES] autorelease]]);
  id<EdgeFilter> allFilter = [[[DefaultEdgeFilter alloc] initWithFlagEncoder:prepareFlagEncoder withBoolean:YES withBoolean:YES] autorelease];
  id<EdgeFilter> accessWithLevelFilter = [[[PrepareContractionHierarchies_$1 alloc] initWithCHGraphImpl:prepareGraph_ withEdgeFilter:allFilter] autorelease];
  maxLevel_ = [prepareGraph_ getNodes] + 1;
  PrepareContractionHierarchies_setAndConsume_ignoreNodeFilter_(self, [[PrepareContractionHierarchies_IgnoreNodeFilter alloc] initWithCHGraph:prepareGraph_ withInt:maxLevel_]);
  PrepareContractionHierarchies_set_vehicleAllExplorer_(self, [prepareGraph_ createEdgeExplorerWithEdgeFilter:allFilter]);
  PrepareContractionHierarchies_set_vehicleAllTmpExplorer_(self, [prepareGraph_ createEdgeExplorerWithEdgeFilter:allFilter]);
  PrepareContractionHierarchies_set_calcPrioAllExplorer_(self, [prepareGraph_ createEdgeExplorerWithEdgeFilter:accessWithLevelFilter]);
  PrepareContractionHierarchies_setAndConsume_sortedNodes_(self, [[GHTreeMapComposed alloc] init]);
  PrepareContractionHierarchies_setAndConsume_oldPriorities_(self, [IOSIntArray newArrayWithLength:[prepareGraph_ getNodes]]);
  PrepareContractionHierarchies_setAndConsume_prepareAlgo_(self, [[DijkstraOneToMany alloc] initWithGraph:prepareGraph_ withComGraphhopperRoutingWeightingWeighting:prepareWeighting_ withTraversalModeEnum:traversalMode_]);
  return self;
}

- (jint)getShortcuts {
  return newShortcuts_;
}

- (void)setOrigEdgeCountWithInt:(jint)edgeId
                        withInt:(jint)value {
  PrepareContractionHierarchies_setOrigEdgeCountWithInt_withInt_(self, edgeId, value);
}

- (jint)getOrigEdgeCountWithInt:(jint)edgeId {
  return PrepareContractionHierarchies_getOrigEdgeCountWithInt_(self, edgeId);
}

- (id<RoutingAlgorithm>)createAlgoWithGraph:(id<Graph>)graph
                       withAlgorithmOptions:(AlgorithmOptions *)opts {
  AbstractBidirAlgo *algo;
  if ([((NSString *) nil_chk(Parameters_Algorithms_get_ASTAR_BI_())) isEqual:[((AlgorithmOptions *) nil_chk(opts)) getAlgorithm]]) {
    AStarBidirection *tmpAlgo = PrepareContractionHierarchies_createAStarBidirectionWithGraph_(self, graph);
    [((AStarBidirection *) nil_chk(tmpAlgo)) setApproximationWithComGraphhopperRoutingWeightingWeightApproximator:RoutingAlgorithmFactorySimple_getApproximationWithNSString_withAlgorithmOptions_withNodeAccess_(Parameters_Algorithms_get_ASTAR_BI_(), opts, [((id<Graph>) nil_chk(graph)) getNodeAccess])];
    algo = tmpAlgo;
  }
  else if ([((NSString *) nil_chk(Parameters_Algorithms_get_DIJKSTRA_BI_())) isEqual:[opts getAlgorithm]]) {
    algo = PrepareContractionHierarchies_createDijkstraBidirectionWithGraph_(self, graph);
  }
  else {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$$$", @"Algorithm ", [opts getAlgorithm], @" not supported for Contraction Hierarchies. Try with ch.disable=true")] autorelease];
  }
  [((AbstractBidirAlgo *) nil_chk(algo)) setMaxVisitedNodesWithInt:[opts getMaxVisitedNodes]];
  [algo setEdgeFilterWithEdgeFilter:levelFilter_];
  return algo;
}

- (AStarBidirection *)createAStarBidirectionWithGraph:(id<Graph>)graph {
  return PrepareContractionHierarchies_createAStarBidirectionWithGraph_(self, graph);
}

- (AbstractBidirAlgo *)createDijkstraBidirectionWithGraph:(id<Graph>)graph {
  return PrepareContractionHierarchies_createDijkstraBidirectionWithGraph_(self, graph);
}

- (NSString *)description {
  return @"prepare|CH|dijkstrabi";
}

- (void)dealloc {
  RELEASE_(logger_);
  RELEASE_(prepareWeighting_);
  RELEASE_(traversalMode_);
  RELEASE_(levelFilter_);
  RELEASE_(ghStorage_);
  RELEASE_(prepareGraph_);
  RELEASE_(originalEdges_);
  RELEASE_(shortcuts_);
  RELEASE_(rand_);
  RELEASE_(allSW_);
  RELEASE_(addScHandler_);
  RELEASE_(calcScHandler_);
  RELEASE_(vehicleInExplorer_);
  RELEASE_(vehicleOutExplorer_);
  RELEASE_(vehicleAllExplorer_);
  RELEASE_(vehicleAllTmpExplorer_);
  RELEASE_(calcPrioAllExplorer_);
  RELEASE_(sortedNodes_);
  RELEASE_(oldPriorities_);
  RELEASE_(ignoreNodeFilter_);
  RELEASE_(prepareAlgo_);
  RELEASE_(dijkstraSW_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(PrepareContractionHierarchies *)other {
  [super copyAllFieldsTo:other];
  PrepareContractionHierarchies_set_logger_(other, logger_);
  PrepareContractionHierarchies_set_prepareWeighting_(other, prepareWeighting_);
  PrepareContractionHierarchies_set_traversalMode_(other, traversalMode_);
  PrepareContractionHierarchies_set_levelFilter_(other, levelFilter_);
  PrepareContractionHierarchies_set_ghStorage_(other, ghStorage_);
  PrepareContractionHierarchies_set_prepareGraph_(other, prepareGraph_);
  PrepareContractionHierarchies_set_originalEdges_(other, originalEdges_);
  PrepareContractionHierarchies_set_shortcuts_(other, shortcuts_);
  PrepareContractionHierarchies_set_rand_(other, rand_);
  PrepareContractionHierarchies_set_allSW_(other, allSW_);
  PrepareContractionHierarchies_set_addScHandler_(other, addScHandler_);
  PrepareContractionHierarchies_set_calcScHandler_(other, calcScHandler_);
  PrepareContractionHierarchies_set_vehicleInExplorer_(other, vehicleInExplorer_);
  PrepareContractionHierarchies_set_vehicleOutExplorer_(other, vehicleOutExplorer_);
  PrepareContractionHierarchies_set_vehicleAllExplorer_(other, vehicleAllExplorer_);
  PrepareContractionHierarchies_set_vehicleAllTmpExplorer_(other, vehicleAllTmpExplorer_);
  PrepareContractionHierarchies_set_calcPrioAllExplorer_(other, calcPrioAllExplorer_);
  other->maxLevel_ = maxLevel_;
  PrepareContractionHierarchies_set_sortedNodes_(other, sortedNodes_);
  PrepareContractionHierarchies_set_oldPriorities_(other, oldPriorities_);
  PrepareContractionHierarchies_set_ignoreNodeFilter_(other, ignoreNodeFilter_);
  PrepareContractionHierarchies_set_prepareAlgo_(other, prepareAlgo_);
  other->counter_ = counter_;
  other->newShortcuts_ = newShortcuts_;
  other->dijkstraCount_ = dijkstraCount_;
  other->meanDegree_ = meanDegree_;
  PrepareContractionHierarchies_set_dijkstraSW_(other, dijkstraSW_);
  other->periodicUpdatesPercentage_ = periodicUpdatesPercentage_;
  other->lastNodesLazyUpdatePercentage_ = lastNodesLazyUpdatePercentage_;
  other->neighborUpdatePercentage_ = neighborUpdatePercentage_;
  other->nodesContractedPercentage_ = nodesContractedPercentage_;
  other->logMessagesPercentage_ = logMessagesPercentage_;
  other->dijkstraTime_ = dijkstraTime_;
  other->periodTime_ = periodTime_;
  other->lazyTime_ = lazyTime_;
  other->neighborTime_ = neighborTime_;
  other->maxEdgesCount_ = maxEdgesCount_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithDirectory:withGraphHopperStorage:withCHGraph:withComGraphhopperRoutingWeightingWeighting:withTraversalModeEnum:", "PrepareContractionHierarchies", NULL, 0x1, NULL },
    { "setPeriodicUpdatesWithInt:", "setPeriodicUpdates", "Lcom.graphhopper.routing.ch.PrepareContractionHierarchies;", 0x1, NULL },
    { "setLazyUpdatesWithInt:", "setLazyUpdates", "Lcom.graphhopper.routing.ch.PrepareContractionHierarchies;", 0x1, NULL },
    { "setNeighborUpdatesWithInt:", "setNeighborUpdates", "Lcom.graphhopper.routing.ch.PrepareContractionHierarchies;", 0x1, NULL },
    { "setLogMessagesWithDouble:", "setLogMessages", "Lcom.graphhopper.routing.ch.PrepareContractionHierarchies;", 0x1, NULL },
    { "setContractedNodesWithDouble:", "setContractedNodes", "Lcom.graphhopper.routing.ch.PrepareContractionHierarchies;", 0x1, NULL },
    { "doWork", NULL, "V", 0x1, NULL },
    { "prepareNodes", NULL, "Z", 0x0, NULL },
    { "contractNodes", NULL, "V", 0x0, NULL },
    { "getDijkstraCount", NULL, "J", 0x1, NULL },
    { "getLazyTime", NULL, "D", 0x1, NULL },
    { "getPeriodTime", NULL, "D", 0x1, NULL },
    { "getDijkstraTime", NULL, "D", 0x1, NULL },
    { "getNeighborTime", NULL, "D", 0x1, NULL },
    { "getWeighting", NULL, "Lcom.graphhopper.routing.weighting.Weighting;", 0x1, NULL },
    { "close", NULL, "V", 0x1, NULL },
    { "getTimesAsString", NULL, "Ljava.lang.String;", 0x2, NULL },
    { "testFindShortcutsWithInt:", "testFindShortcuts", "Ljava.util.Set;", 0x0, NULL },
    { "calculatePriorityWithInt:", "calculatePriority", "I", 0x0, NULL },
    { "findShortcutsWithPrepareContractionHierarchies_ShortcutHandler:", "findShortcuts", "V", 0x0, NULL },
    { "addShortcutsWithInt:", "addShortcuts", "I", 0x0, NULL },
    { "getCoordsWithEdgeIteratorState:withGraph:", "getCoords", "Ljava.lang.String;", 0x0, NULL },
    { "initFromGraph", NULL, "Lcom.graphhopper.routing.ch.PrepareContractionHierarchies;", 0x0, NULL },
    { "getShortcuts", NULL, "I", 0x1, NULL },
    { "setOrigEdgeCountWithInt:withInt:", "setOrigEdgeCount", "V", 0x2, NULL },
    { "getOrigEdgeCountWithInt:", "getOrigEdgeCount", "I", 0x2, NULL },
    { "createAlgoWithGraph:withAlgorithmOptions:", "createAlgo", "Lcom.graphhopper.routing.RoutingAlgorithm;", 0x1, NULL },
    { "createAStarBidirectionWithGraph:", "createAStarBidirection", "Lcom.graphhopper.routing.AStarBidirection;", 0x2, NULL },
    { "createDijkstraBidirectionWithGraph:", "createDijkstraBidirection", "Lcom.graphhopper.routing.AbstractBidirAlgo;", 0x2, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "logger_", NULL, 0x12, "Lorg.slf4j.Logger;", NULL,  },
    { "prepareWeighting_", NULL, 0x12, "Lcom.graphhopper.routing.ch.PreparationWeighting;", NULL,  },
    { "traversalMode_", NULL, 0x12, "Lcom.graphhopper.routing.util.TraversalMode;", NULL,  },
    { "levelFilter_", NULL, 0x12, "Lcom.graphhopper.routing.util.LevelEdgeFilter;", NULL,  },
    { "ghStorage_", NULL, 0x12, "Lcom.graphhopper.storage.GraphHopperStorage;", NULL,  },
    { "prepareGraph_", NULL, 0x12, "Lcom.graphhopper.storage.CHGraphImpl;", NULL,  },
    { "originalEdges_", NULL, 0x12, "Lcom.graphhopper.storage.DataAccess;", NULL,  },
    { "shortcuts_", NULL, 0x12, "Ljava.util.Map;", NULL,  },
    { "rand_", NULL, 0x12, "Ljava.util.Random;", NULL,  },
    { "allSW_", NULL, 0x12, "Lcom.graphhopper.util.StopWatch;", NULL,  },
    { "addScHandler_", NULL, 0x0, "Lcom.graphhopper.routing.ch.PrepareContractionHierarchies$AddShortcutHandler;", NULL,  },
    { "calcScHandler_", NULL, 0x0, "Lcom.graphhopper.routing.ch.PrepareContractionHierarchies$CalcShortcutHandler;", NULL,  },
    { "vehicleInExplorer_", NULL, 0x2, "Lcom.graphhopper.util.CHEdgeExplorer;", NULL,  },
    { "vehicleOutExplorer_", NULL, 0x2, "Lcom.graphhopper.util.CHEdgeExplorer;", NULL,  },
    { "vehicleAllExplorer_", NULL, 0x2, "Lcom.graphhopper.util.CHEdgeExplorer;", NULL,  },
    { "vehicleAllTmpExplorer_", NULL, 0x2, "Lcom.graphhopper.util.CHEdgeExplorer;", NULL,  },
    { "calcPrioAllExplorer_", NULL, 0x2, "Lcom.graphhopper.util.CHEdgeExplorer;", NULL,  },
    { "maxLevel_", NULL, 0x2, "I", NULL,  },
    { "sortedNodes_", NULL, 0x2, "Lcom.graphhopper.coll.GHTreeMapComposed;", NULL,  },
    { "oldPriorities_", NULL, 0x2, "[I", NULL,  },
    { "ignoreNodeFilter_", NULL, 0x2, "Lcom.graphhopper.routing.ch.PrepareContractionHierarchies$IgnoreNodeFilter;", NULL,  },
    { "prepareAlgo_", NULL, 0x2, "Lcom.graphhopper.routing.DijkstraOneToMany;", NULL,  },
    { "counter_", NULL, 0x2, "J", NULL,  },
    { "newShortcuts_", NULL, 0x2, "I", NULL,  },
    { "dijkstraCount_", NULL, 0x2, "J", NULL,  },
    { "meanDegree_", NULL, 0x2, "D", NULL,  },
    { "dijkstraSW_", NULL, 0x2, "Lcom.graphhopper.util.StopWatch;", NULL,  },
    { "periodicUpdatesPercentage_", NULL, 0x2, "I", NULL,  },
    { "lastNodesLazyUpdatePercentage_", NULL, 0x2, "I", NULL,  },
    { "neighborUpdatePercentage_", NULL, 0x2, "I", NULL,  },
    { "nodesContractedPercentage_", NULL, 0x2, "D", NULL,  },
    { "logMessagesPercentage_", NULL, 0x2, "D", NULL,  },
    { "dijkstraTime_", NULL, 0x2, "D", NULL,  },
    { "periodTime_", NULL, 0x2, "D", NULL,  },
    { "lazyTime_", NULL, 0x2, "D", NULL,  },
    { "neighborTime_", NULL, 0x2, "D", NULL,  },
    { "maxEdgesCount_", NULL, 0x2, "I", NULL,  },
  };
  static const J2ObjcClassInfo _PrepareContractionHierarchies = { 1, "PrepareContractionHierarchies", "com.graphhopper.routing.ch", NULL, 0x1, 30, methods, 37, fields, 0, NULL};
  return &_PrepareContractionHierarchies;
}

@end

NSString *PrepareContractionHierarchies_getTimesAsString(PrepareContractionHierarchies *self) {
  return JreStrcat("$D$D$D$D", @"t(dijk):", Helper_round2WithDouble_(self->dijkstraTime_), @", t(period):", Helper_round2WithDouble_(self->periodTime_), @", t(lazy):", Helper_round2WithDouble_(self->lazyTime_), @", t(neighbor):", Helper_round2WithDouble_(self->neighborTime_));
}

void PrepareContractionHierarchies_setOrigEdgeCountWithInt_withInt_(PrepareContractionHierarchies *self, jint edgeId, jint value) {
  edgeId -= self->maxEdgesCount_;
  if (edgeId < 0) {
    if (value != 1) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$I$I$I", @"Trying to set original edge count for normal edge to a value = ", value, @", edge:", (edgeId + self->maxEdgesCount_), @", max:", self->maxEdgesCount_, @", graph.max:", [((id<AllEdgesIterator>) nil_chk([((GraphHopperStorage *) nil_chk(self->ghStorage_)) getAllEdges])) getMaxId])] autorelease];
    return;
  }
  jlong tmp = (jlong) edgeId * 4;
  [((id<DataAccess>) nil_chk(self->originalEdges_)) ensureCapacityWithLong:tmp + 4];
  [self->originalEdges_ setIntWithLong:tmp withInt:value];
}

jint PrepareContractionHierarchies_getOrigEdgeCountWithInt_(PrepareContractionHierarchies *self, jint edgeId) {
  edgeId -= self->maxEdgesCount_;
  if (edgeId < 0) return 1;
  jlong tmp = (jlong) edgeId * 4;
  [((id<DataAccess>) nil_chk(self->originalEdges_)) ensureCapacityWithLong:tmp + 4];
  return [self->originalEdges_ getIntWithLong:tmp];
}

AStarBidirection *PrepareContractionHierarchies_createAStarBidirectionWithGraph_(PrepareContractionHierarchies *self, id<Graph> graph) {
  return [[[PrepareContractionHierarchies_$2 alloc] initWithPrepareContractionHierarchies:self withGraph:graph withPreparationWeighting:self->prepareWeighting_ withTraversalModeEnum:self->traversalMode_] autorelease];
}

AbstractBidirAlgo *PrepareContractionHierarchies_createDijkstraBidirectionWithGraph_(PrepareContractionHierarchies *self, id<Graph> graph) {
  return [[[PrepareContractionHierarchies_$3 alloc] initWithPrepareContractionHierarchies:self withGraph:graph withPreparationWeighting:self->prepareWeighting_ withTraversalModeEnum:self->traversalMode_] autorelease];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(PrepareContractionHierarchies)

@implementation PrepareContractionHierarchies_IgnoreNodeFilter

- (instancetype)initWithCHGraph:(id<CHGraph>)g
                        withInt:(jint)maxLevel {
  if (self = [super init]) {
    PrepareContractionHierarchies_IgnoreNodeFilter_set_graph_(self, g);
    self->maxLevel_ = maxLevel;
  }
  return self;
}

- (PrepareContractionHierarchies_IgnoreNodeFilter *)setAvoidNodeWithInt:(jint)node {
  self->avoidNode_ = node;
  return self;
}

- (jboolean)acceptWithEdgeIteratorState:(id<EdgeIteratorState>)iter {
  jint node = [((id<EdgeIteratorState>) nil_chk(iter)) getAdjNode];
  return avoidNode_ != node && [((id<CHGraph>) nil_chk(graph_)) getLevelWithInt:node] == maxLevel_;
}

- (void)dealloc {
  RELEASE_(graph_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(PrepareContractionHierarchies_IgnoreNodeFilter *)other {
  [super copyAllFieldsTo:other];
  other->avoidNode_ = avoidNode_;
  other->maxLevel_ = maxLevel_;
  PrepareContractionHierarchies_IgnoreNodeFilter_set_graph_(other, graph_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithCHGraph:withInt:", "IgnoreNodeFilter", NULL, 0x1, NULL },
    { "setAvoidNodeWithInt:", "setAvoidNode", "Lcom.graphhopper.routing.ch.PrepareContractionHierarchies$IgnoreNodeFilter;", 0x1, NULL },
    { "acceptWithEdgeIteratorState:", "accept", "Z", 0x11, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "avoidNode_", NULL, 0x0, "I", NULL,  },
    { "maxLevel_", NULL, 0x0, "I", NULL,  },
    { "graph_", NULL, 0x0, "Lcom.graphhopper.storage.CHGraph;", NULL,  },
  };
  static const J2ObjcClassInfo _PrepareContractionHierarchies_IgnoreNodeFilter = { 1, "IgnoreNodeFilter", "com.graphhopper.routing.ch", "PrepareContractionHierarchies", 0x8, 3, methods, 3, fields, 0, NULL};
  return &_PrepareContractionHierarchies_IgnoreNodeFilter;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(PrepareContractionHierarchies_IgnoreNodeFilter)

@implementation PrepareContractionHierarchies_Shortcut

- (instancetype)initWithInt:(jint)from
                    withInt:(jint)to
                 withDouble:(jdouble)weight
                 withDouble:(jdouble)dist {
  if (self = [super init]) {
    flags_ = PrepareEncoder_getScFwdDir();
    self->from_ = from;
    self->to_ = to;
    self->weight_ = weight;
    self->dist_ = dist;
  }
  return self;
}

- (NSUInteger)hash {
  jint hash_ = 5;
  hash_ = 23 * hash_ + from_;
  hash_ = 23 * hash_ + to_;
  return 23 * hash_ + (jint) (JavaLangDouble_doubleToLongBitsWithDouble_(self->weight_) ^ (URShift64(JavaLangDouble_doubleToLongBitsWithDouble_(self->weight_), 32)));
}

- (jboolean)isEqual:(id)obj {
  if (obj == nil || [self getClass] != [obj getClass]) return NO;
  PrepareContractionHierarchies_Shortcut *other = (PrepareContractionHierarchies_Shortcut *) check_class_cast(obj, [PrepareContractionHierarchies_Shortcut class]);
  if (self->from_ != ((PrepareContractionHierarchies_Shortcut *) nil_chk(other))->from_ || self->to_ != other->to_) return NO;
  return JavaLangDouble_doubleToLongBitsWithDouble_(self->weight_) == JavaLangDouble_doubleToLongBitsWithDouble_(other->weight_);
}

- (NSString *)description {
  NSString *str;
  if (flags_ == PrepareEncoder_getScDirMask()) str = JreStrcat("I$", from_, @"<->");
  else str = JreStrcat("I$", from_, @"->");
  return JreStrcat("$I$D$ICIC", str, to_, @", weight:", weight_, @" (", skippedEdge1_, ',', skippedEdge2_, ')');
}

- (void)copyAllFieldsTo:(PrepareContractionHierarchies_Shortcut *)other {
  [super copyAllFieldsTo:other];
  other->from_ = from_;
  other->to_ = to_;
  other->skippedEdge1_ = skippedEdge1_;
  other->skippedEdge2_ = skippedEdge2_;
  other->dist_ = dist_;
  other->weight_ = weight_;
  other->originalEdges_ = originalEdges_;
  other->flags_ = flags_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithInt:withInt:withDouble:withDouble:", "Shortcut", NULL, 0x1, NULL },
    { "hash", "hashCode", "I", 0x1, NULL },
    { "isEqual:", "equals", "Z", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "from_", NULL, 0x0, "I", NULL,  },
    { "to_", NULL, 0x0, "I", NULL,  },
    { "skippedEdge1_", NULL, 0x0, "I", NULL,  },
    { "skippedEdge2_", NULL, 0x0, "I", NULL,  },
    { "dist_", NULL, 0x0, "D", NULL,  },
    { "weight_", NULL, 0x0, "D", NULL,  },
    { "originalEdges_", NULL, 0x0, "I", NULL,  },
    { "flags_", NULL, 0x0, "J", NULL,  },
  };
  static const J2ObjcClassInfo _PrepareContractionHierarchies_Shortcut = { 1, "Shortcut", "com.graphhopper.routing.ch", "PrepareContractionHierarchies", 0x8, 4, methods, 8, fields, 0, NULL};
  return &_PrepareContractionHierarchies_Shortcut;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(PrepareContractionHierarchies_Shortcut)

@interface PrepareContractionHierarchies_ShortcutHandler : NSObject
@end

@implementation PrepareContractionHierarchies_ShortcutHandler

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "foundShortcutWithInt:withInt:withDouble:withDouble:withEdgeIterator:withInt:withInt:", "foundShortcut", "V", 0x401, NULL },
    { "getNode", NULL, "I", 0x401, NULL },
  };
  static const J2ObjcClassInfo _PrepareContractionHierarchies_ShortcutHandler = { 1, "ShortcutHandler", "com.graphhopper.routing.ch", "PrepareContractionHierarchies", 0x200, 2, methods, 0, NULL, 0, NULL};
  return &_PrepareContractionHierarchies_ShortcutHandler;
}

@end

J2OBJC_INTERFACE_TYPE_LITERAL_SOURCE(PrepareContractionHierarchies_ShortcutHandler)

@implementation PrepareContractionHierarchies_CalcShortcutHandler

- (jint)getNode {
  return node_;
}

- (PrepareContractionHierarchies_CalcShortcutHandler *)setNodeWithInt:(jint)n {
  node_ = n;
  originalEdgesCount_ = 0;
  shortcuts_ = 0;
  return self;
}

- (void)foundShortcutWithInt:(jint)u_fromNode
                     withInt:(jint)w_toNode
                  withDouble:(jdouble)existingDirectWeight
                  withDouble:(jdouble)distance
            withEdgeIterator:(id<EdgeIterator>)outgoingEdges
                     withInt:(jint)skippedEdge1
                     withInt:(jint)incomingEdgeOrigCount {
  shortcuts_++;
  originalEdgesCount_ += incomingEdgeOrigCount + PrepareContractionHierarchies_getOrigEdgeCountWithInt_(this$0_, [((id<EdgeIterator>) nil_chk(outgoingEdges)) getEdge]);
}

- (instancetype)initWithPrepareContractionHierarchies:(PrepareContractionHierarchies *)outer$ {
  PrepareContractionHierarchies_CalcShortcutHandler_set_this$0_(self, outer$);
  return [super init];
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(PrepareContractionHierarchies_CalcShortcutHandler *)other {
  [super copyAllFieldsTo:other];
  PrepareContractionHierarchies_CalcShortcutHandler_set_this$0_(other, this$0_);
  other->node_ = node_;
  other->originalEdgesCount_ = originalEdgesCount_;
  other->shortcuts_ = shortcuts_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "getNode", NULL, "I", 0x1, NULL },
    { "setNodeWithInt:", "setNode", "Lcom.graphhopper.routing.ch.PrepareContractionHierarchies$CalcShortcutHandler;", 0x1, NULL },
    { "foundShortcutWithInt:withInt:withDouble:withDouble:withEdgeIterator:withInt:withInt:", "foundShortcut", "V", 0x1, NULL },
    { "initWithPrepareContractionHierarchies:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lcom.graphhopper.routing.ch.PrepareContractionHierarchies;", NULL,  },
    { "node_", NULL, 0x0, "I", NULL,  },
    { "originalEdgesCount_", NULL, 0x0, "I", NULL,  },
    { "shortcuts_", NULL, 0x0, "I", NULL,  },
  };
  static const J2ObjcClassInfo _PrepareContractionHierarchies_CalcShortcutHandler = { 1, "CalcShortcutHandler", "com.graphhopper.routing.ch", "PrepareContractionHierarchies", 0x0, 4, methods, 4, fields, 0, NULL};
  return &_PrepareContractionHierarchies_CalcShortcutHandler;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(PrepareContractionHierarchies_CalcShortcutHandler)

@implementation PrepareContractionHierarchies_AddShortcutHandler

- (instancetype)initWithPrepareContractionHierarchies:(PrepareContractionHierarchies *)outer$ {
  PrepareContractionHierarchies_AddShortcutHandler_set_this$0_(self, outer$);
  return [super init];
}

- (jint)getNode {
  return node_;
}

- (PrepareContractionHierarchies_AddShortcutHandler *)setNodeWithInt:(jint)n {
  [((id<JavaUtilMap>) nil_chk(this$0_->shortcuts_)) clear];
  node_ = n;
  return self;
}

- (void)foundShortcutWithInt:(jint)u_fromNode
                     withInt:(jint)w_toNode
                  withDouble:(jdouble)existingDirectWeight
                  withDouble:(jdouble)existingDistSum
            withEdgeIterator:(id<EdgeIterator>)outgoingEdges
                     withInt:(jint)skippedEdge1
                     withInt:(jint)incomingEdgeOrigCount {
  PrepareContractionHierarchies_Shortcut *sc = [[[PrepareContractionHierarchies_Shortcut alloc] initWithInt:u_fromNode withInt:w_toNode withDouble:existingDirectWeight withDouble:existingDistSum] autorelease];
  if ([((id<JavaUtilMap>) nil_chk(this$0_->shortcuts_)) containsKeyWithId:sc]) return;
  PrepareContractionHierarchies_Shortcut *tmpSc = [[[PrepareContractionHierarchies_Shortcut alloc] initWithInt:w_toNode withInt:u_fromNode withDouble:existingDirectWeight withDouble:existingDistSum] autorelease];
  PrepareContractionHierarchies_Shortcut *tmpRetSc = [this$0_->shortcuts_ getWithId:tmpSc];
  if (tmpRetSc != nil) {
    if (tmpRetSc->skippedEdge2_ == skippedEdge1 && tmpRetSc->skippedEdge1_ == [((id<EdgeIterator>) nil_chk(outgoingEdges)) getEdge]) {
      tmpRetSc->flags_ = PrepareEncoder_getScDirMask();
      return;
    }
  }
  [this$0_->shortcuts_ putWithId:sc withId:sc];
  sc->skippedEdge1_ = skippedEdge1;
  sc->skippedEdge2_ = [((id<EdgeIterator>) nil_chk(outgoingEdges)) getEdge];
  sc->originalEdges_ = incomingEdgeOrigCount + PrepareContractionHierarchies_getOrigEdgeCountWithInt_(this$0_, [outgoingEdges getEdge]);
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(PrepareContractionHierarchies_AddShortcutHandler *)other {
  [super copyAllFieldsTo:other];
  PrepareContractionHierarchies_AddShortcutHandler_set_this$0_(other, this$0_);
  other->node_ = node_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithPrepareContractionHierarchies:", "AddShortcutHandler", NULL, 0x1, NULL },
    { "getNode", NULL, "I", 0x1, NULL },
    { "setNodeWithInt:", "setNode", "Lcom.graphhopper.routing.ch.PrepareContractionHierarchies$AddShortcutHandler;", 0x1, NULL },
    { "foundShortcutWithInt:withInt:withDouble:withDouble:withEdgeIterator:withInt:withInt:", "foundShortcut", "V", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lcom.graphhopper.routing.ch.PrepareContractionHierarchies;", NULL,  },
    { "node_", NULL, 0x0, "I", NULL,  },
  };
  static const J2ObjcClassInfo _PrepareContractionHierarchies_AddShortcutHandler = { 1, "AddShortcutHandler", "com.graphhopper.routing.ch", "PrepareContractionHierarchies", 0x0, 4, methods, 2, fields, 0, NULL};
  return &_PrepareContractionHierarchies_AddShortcutHandler;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(PrepareContractionHierarchies_AddShortcutHandler)

@implementation PrepareContractionHierarchies_$1

- (jboolean)acceptWithEdgeIteratorState:(id<EdgeIteratorState>)edgeState {
  if (![super acceptWithEdgeIteratorState:edgeState]) return NO;
  return [((id<EdgeFilter>) nil_chk(val$allFilter_)) acceptWithEdgeIteratorState:edgeState];
}

- (instancetype)initWithCHGraphImpl:(CHGraphImpl *)arg$0
                     withEdgeFilter:(id<EdgeFilter>)capture$0 {
  PrepareContractionHierarchies_$1_set_val$allFilter_(self, capture$0);
  return [super initWithCHGraph:arg$0];
}

- (void)dealloc {
  RELEASE_(val$allFilter_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(PrepareContractionHierarchies_$1 *)other {
  [super copyAllFieldsTo:other];
  PrepareContractionHierarchies_$1_set_val$allFilter_(other, val$allFilter_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "acceptWithEdgeIteratorState:", "accept", "Z", 0x11, NULL },
    { "initWithCHGraphImpl:withEdgeFilter:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "val$allFilter_", NULL, 0x1012, "Lcom.graphhopper.routing.util.EdgeFilter;", NULL,  },
  };
  static const J2ObjcClassInfo _PrepareContractionHierarchies_$1 = { 1, "$1", "com.graphhopper.routing.ch", "PrepareContractionHierarchies", 0x8000, 2, methods, 1, fields, 0, NULL};
  return &_PrepareContractionHierarchies_$1;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(PrepareContractionHierarchies_$1)

@implementation PrepareContractionHierarchies_$2

- (jboolean)finished {
  if (finishedFrom_ && finishedTo_) return YES;
  return ((AStar_AStarEntry *) nil_chk(currFrom_))->weight_ >= [((PathBidirRef *) nil_chk(bestPath_)) getWeight] && ((AStar_AStarEntry *) nil_chk(currTo_))->weight_ >= [bestPath_ getWeight];
}

- (Path *)createAndInitPath {
  AStarBidirection_setAndConsume_bestPath_(self, [[Path4CH alloc] initWithGraph:graph_ withGraph:[((id<Graph>) nil_chk(graph_)) getBaseGraph] withComGraphhopperRoutingWeightingWeighting:weighting_]);
  return bestPath_;
}

- (NSString *)getName {
  return @"astarbiCH";
}

- (NSString *)description {
  return JreStrcat("$C@", [self getName], '|', this$0_->prepareWeighting_);
}

- (instancetype)initWithPrepareContractionHierarchies:(PrepareContractionHierarchies *)outer$
                                            withGraph:(id<Graph>)arg$0
                             withPreparationWeighting:(PreparationWeighting *)arg$1
                                withTraversalModeEnum:(TraversalModeEnum *)arg$2 {
  PrepareContractionHierarchies_$2_set_this$0_(self, outer$);
  return [super initWithGraph:arg$0 withComGraphhopperRoutingWeightingWeighting:arg$1 withTraversalModeEnum:arg$2];
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(PrepareContractionHierarchies_$2 *)other {
  [super copyAllFieldsTo:other];
  PrepareContractionHierarchies_$2_set_this$0_(other, this$0_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "finished", NULL, "Z", 0x4, NULL },
    { "createAndInitPath", NULL, "Lcom.graphhopper.routing.Path;", 0x4, NULL },
    { "getName", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "initWithPrepareContractionHierarchies:withGraph:withPreparationWeighting:withTraversalModeEnum:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lcom.graphhopper.routing.ch.PrepareContractionHierarchies;", NULL,  },
  };
  static const J2ObjcClassInfo _PrepareContractionHierarchies_$2 = { 1, "$2", "com.graphhopper.routing.ch", "PrepareContractionHierarchies", 0x8000, 5, methods, 1, fields, 0, NULL};
  return &_PrepareContractionHierarchies_$2;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(PrepareContractionHierarchies_$2)

@implementation PrepareContractionHierarchies_$3

- (jboolean)finished {
  if (finishedFrom_ && finishedTo_) return YES;
  return ((SPTEntry *) nil_chk(currFrom_))->weight_ >= [((PathBidirRef *) nil_chk(bestPath_)) getWeight] && ((SPTEntry *) nil_chk(currTo_))->weight_ >= [bestPath_ getWeight];
}

- (Path *)createAndInitPath {
  DijkstraBidirectionRef_setAndConsume_bestPath_(self, [[Path4CH alloc] initWithGraph:graph_ withGraph:[((id<Graph>) nil_chk(graph_)) getBaseGraph] withComGraphhopperRoutingWeightingWeighting:weighting_]);
  return bestPath_;
}

- (NSString *)getName {
  return @"dijkstrabiCH";
}

- (NSString *)description {
  return JreStrcat("$C@", [self getName], '|', this$0_->prepareWeighting_);
}

- (instancetype)initWithPrepareContractionHierarchies:(PrepareContractionHierarchies *)outer$
                                            withGraph:(id<Graph>)arg$0
                             withPreparationWeighting:(PreparationWeighting *)arg$1
                                withTraversalModeEnum:(TraversalModeEnum *)arg$2 {
  PrepareContractionHierarchies_$3_set_this$0_(self, outer$);
  return [super initWithGraph:arg$0 withComGraphhopperRoutingWeightingWeighting:arg$1 withTraversalModeEnum:arg$2];
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(PrepareContractionHierarchies_$3 *)other {
  [super copyAllFieldsTo:other];
  PrepareContractionHierarchies_$3_set_this$0_(other, this$0_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "finished", NULL, "Z", 0x1, NULL },
    { "createAndInitPath", NULL, "Lcom.graphhopper.routing.Path;", 0x4, NULL },
    { "getName", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "initWithPrepareContractionHierarchies:withGraph:withPreparationWeighting:withTraversalModeEnum:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lcom.graphhopper.routing.ch.PrepareContractionHierarchies;", NULL,  },
  };
  static const J2ObjcClassInfo _PrepareContractionHierarchies_$3 = { 1, "$3", "com.graphhopper.routing.ch", "PrepareContractionHierarchies", 0x8000, 5, methods, 1, fields, 0, NULL};
  return &_PrepareContractionHierarchies_$3;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(PrepareContractionHierarchies_$3)
