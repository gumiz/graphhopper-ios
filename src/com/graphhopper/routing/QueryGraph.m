//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/routing/QueryGraph.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/routing/QueryGraph.h"
#include "com/graphhopper/routing/VirtualEdgeIterator.h"
#include "com/graphhopper/routing/VirtualEdgeIteratorState.h"
#include "com/graphhopper/routing/util/AllEdgesIterator.h"
#include "com/graphhopper/routing/util/DefaultEdgeFilter.h"
#include "com/graphhopper/routing/util/EdgeFilter.h"
#include "com/graphhopper/storage/Graph.h"
#include "com/graphhopper/storage/GraphExtension.h"
#include "com/graphhopper/storage/NodeAccess.h"
#include "com/graphhopper/storage/TurnCostExtension.h"
#include "com/graphhopper/storage/index/QueryResult.h"
#include "com/graphhopper/util/AngleCalc.h"
#include "com/graphhopper/util/DistancePlaneProjection.h"
#include "com/graphhopper/util/EdgeExplorer.h"
#include "com/graphhopper/util/EdgeIterator.h"
#include "com/graphhopper/util/EdgeIteratorState.h"
#include "com/graphhopper/util/GHUtility.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/PointList.h"
#include "com/graphhopper/util/shapes/BBox.h"
#include "com/graphhopper/util/shapes/GHPoint.h"
#include "com/graphhopper/util/shapes/GHPoint3D.h"
#include "gnu/trove/list/array/TIntArrayList.h"
#include "gnu/trove/map/TIntObjectMap.h"
#include "gnu/trove/map/hash/TIntObjectHashMap.h"
#include "gnu/trove/set/hash/TIntHashSet.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/Collections.h"
#include "java/util/HashMap.h"
#include "java/util/List.h"
#include "java/util/Map.h"

__attribute__((unused)) static void QueryGraph_createEdgesWithInt_withInt_withGHPoint3D_withInt_withGHPoint3D_withInt_withPointList_withEdgeIteratorState_withInt_withInt_withLong_(QueryGraph *self, jint origTraversalKey, jint origRevTraversalKey, GHPoint3D *prevSnapped, jint prevWayIndex, GHPoint3D *currSnapped, jint wayIndex, PointList *fullPL, id<EdgeIteratorState> closestEdge, jint prevNodeId, jint nodeId, jlong reverseFlags);
__attribute__((unused)) static jint QueryGraph_getPosOfReverseEdgeWithInt_(QueryGraph *self, jint edgeId);
__attribute__((unused)) static id<EdgeExplorer> QueryGraph_createUncachedEdgeExplorerWithEdgeFilter_(QueryGraph *self, id<EdgeFilter> edgeFilter);
__attribute__((unused)) static void QueryGraph_addVirtualEdgesWithGnuTroveMapTIntObjectMap_withEdgeFilter_withBoolean_withInt_withInt_(QueryGraph *self, id<GnuTroveMapTIntObjectMap> node2EdgeMap, id<EdgeFilter> filter, jboolean base, jint node, jint virtNode);
__attribute__((unused)) static jboolean QueryGraph_isInitialized(QueryGraph *self);
__attribute__((unused)) static JavaLangUnsupportedOperationException *QueryGraph_exc(QueryGraph *self);

@interface QueryGraph_QueryGraphTurnExt () {
 @public
  QueryGraph *this$0_;
  TurnCostExtension *mainTurnExtension_;
}
@end

J2OBJC_FIELD_SETTER(QueryGraph_QueryGraphTurnExt, this$0_, QueryGraph *)
J2OBJC_FIELD_SETTER(QueryGraph_QueryGraphTurnExt, mainTurnExtension_, TurnCostExtension *)

@interface QueryGraph_$1 () {
 @public
  QueryGraph *this$0_;
}
@end

J2OBJC_FIELD_SETTER(QueryGraph_$1, this$0_, QueryGraph *)

@interface QueryGraph () {
 @public
  id<Graph> mainGraph_;
  id<NodeAccess> mainNodeAccess_;
  jint mainNodes_;
  jint mainEdges_;
  QueryGraph *baseGraph_;
  id<GraphExtension> wrappedExtension_;
  id<JavaUtilMap> cacheMap_;
  id<JavaUtilList> queryResults_;
  /**
   @brief Store lat,lon of virtual tower nodes.
   */
  PointList *virtualNodes_;
  id<NodeAccess> nodeAccess_;
  id<JavaUtilList> modifiedEdges_;
  jboolean useEdgeExplorerCache_;
}
- (instancetype)initWithGraph:(id<Graph>)graph
               withQueryGraph:(QueryGraph *)superQueryGraph;

- (void)createEdgesWithInt:(jint)origTraversalKey
                   withInt:(jint)origRevTraversalKey
             withGHPoint3D:(GHPoint3D *)prevSnapped
                   withInt:(jint)prevWayIndex
             withGHPoint3D:(GHPoint3D *)currSnapped
                   withInt:(jint)wayIndex
             withPointList:(PointList *)fullPL
     withEdgeIteratorState:(id<EdgeIteratorState>)closestEdge
                   withInt:(jint)prevNodeId
                   withInt:(jint)nodeId
                  withLong:(jlong)reverseFlags;

- (jint)getPosOfReverseEdgeWithInt:(jint)edgeId;

- (id<EdgeExplorer>)createUncachedEdgeExplorerWithEdgeFilter:(id<EdgeFilter>)edgeFilter;

/**
 @brief Creates a fake edge iterator pointing to multiple edge states.
 */
- (void)addVirtualEdgesWithGnuTroveMapTIntObjectMap:(id<GnuTroveMapTIntObjectMap>)node2EdgeMap
                                     withEdgeFilter:(id<EdgeFilter>)filter
                                        withBoolean:(jboolean)base
                                            withInt:(jint)node
                                            withInt:(jint)virtNode;

- (jboolean)isInitialized;

- (JavaLangUnsupportedOperationException *)exc;
@end

J2OBJC_FIELD_SETTER(QueryGraph, mainGraph_, id<Graph>)
J2OBJC_FIELD_SETTER(QueryGraph, mainNodeAccess_, id<NodeAccess>)
J2OBJC_FIELD_SETTER(QueryGraph, baseGraph_, QueryGraph *)
J2OBJC_FIELD_SETTER(QueryGraph, wrappedExtension_, id<GraphExtension>)
J2OBJC_FIELD_SETTER(QueryGraph, cacheMap_, id<JavaUtilMap>)
J2OBJC_FIELD_SETTER(QueryGraph, queryResults_, id<JavaUtilList>)
J2OBJC_FIELD_SETTER(QueryGraph, virtualNodes_, PointList *)
J2OBJC_FIELD_SETTER(QueryGraph, nodeAccess_, id<NodeAccess>)
J2OBJC_FIELD_SETTER(QueryGraph, modifiedEdges_, id<JavaUtilList>)

@interface QueryGraph_$3 () {
 @public
  QueryGraph *this$0_;
}
@end

J2OBJC_FIELD_SETTER(QueryGraph_$3, this$0_, QueryGraph *)

@interface QueryGraph_$3_$1 () {
 @public
  PointList *val$fullPL_;
}
@end

J2OBJC_FIELD_SETTER(QueryGraph_$3_$1, val$fullPL_, PointList *)

@interface QueryGraph_$4 () {
 @public
  QueryGraph *this$0_;
  id<GnuTroveMapTIntObjectMap> val$node2EdgeMap_;
  id<EdgeExplorer> val$mainExplorer_;
}
@end

J2OBJC_FIELD_SETTER(QueryGraph_$4, this$0_, QueryGraph *)
J2OBJC_FIELD_SETTER(QueryGraph_$4, val$node2EdgeMap_, id<GnuTroveMapTIntObjectMap>)
J2OBJC_FIELD_SETTER(QueryGraph_$4, val$mainExplorer_, id<EdgeExplorer>)

@interface QueryGraph_$5 () {
 @public
  id<GnuTroveMapTIntObjectMap> val$node2EdgeMap_;
  id<EdgeExplorer> val$mainExplorer_;
}
@end

J2OBJC_FIELD_SETTER(QueryGraph_$5, val$node2EdgeMap_, id<GnuTroveMapTIntObjectMap>)
J2OBJC_FIELD_SETTER(QueryGraph_$5, val$mainExplorer_, id<EdgeExplorer>)

@implementation QueryGraph_QueryGraphTurnExt

- (instancetype)initWithQueryGraph:(QueryGraph *)outer$ {
  QueryGraph_QueryGraphTurnExt_set_this$0_(self, outer$);
  if (self = [super init]) {
    QueryGraph_QueryGraphTurnExt_set_mainTurnExtension_(self, (TurnCostExtension *) check_class_cast([((id<Graph>) nil_chk(outer$->mainGraph_)) getExtension], [TurnCostExtension class]));
  }
  return self;
}

- (jlong)getTurnCostFlagsWithInt:(jint)edgeFrom
                         withInt:(jint)nodeVia
                         withInt:(jint)edgeTo {
  if ([this$0_ isVirtualNodeWithInt:nodeVia]) {
    return 0;
  }
  else if ([this$0_ isVirtualEdgeWithInt:edgeFrom] || [this$0_ isVirtualEdgeWithInt:edgeTo]) {
    if ([this$0_ isVirtualEdgeWithInt:edgeFrom]) {
      edgeFrom = [((id<EdgeIteratorState>) nil_chk([((QueryResult *) nil_chk([((id<JavaUtilList>) nil_chk(this$0_->queryResults_)) getWithInt:(edgeFrom - this$0_->mainEdges_) / 4])) getClosestEdge])) getEdge];
    }
    if ([this$0_ isVirtualEdgeWithInt:edgeTo]) {
      edgeTo = [((id<EdgeIteratorState>) nil_chk([((QueryResult *) nil_chk([((id<JavaUtilList>) nil_chk(this$0_->queryResults_)) getWithInt:(edgeTo - this$0_->mainEdges_) / 4])) getClosestEdge])) getEdge];
    }
    return [((TurnCostExtension *) nil_chk(mainTurnExtension_)) getTurnCostFlagsWithInt:edgeFrom withInt:nodeVia withInt:edgeTo];
  }
  else {
    return [((TurnCostExtension *) nil_chk(mainTurnExtension_)) getTurnCostFlagsWithInt:edgeFrom withInt:nodeVia withInt:edgeTo];
  }
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(mainTurnExtension_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(QueryGraph_QueryGraphTurnExt *)other {
  [super copyAllFieldsTo:other];
  QueryGraph_QueryGraphTurnExt_set_this$0_(other, this$0_);
  QueryGraph_QueryGraphTurnExt_set_mainTurnExtension_(other, mainTurnExtension_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithQueryGraph:", "QueryGraphTurnExt", NULL, 0x1, NULL },
    { "getTurnCostFlagsWithInt:withInt:withInt:", "getTurnCostFlags", "J", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lcom.graphhopper.routing.QueryGraph;", NULL,  },
    { "mainTurnExtension_", NULL, 0x12, "Lcom.graphhopper.storage.TurnCostExtension;", NULL,  },
  };
  static const J2ObjcClassInfo _QueryGraph_QueryGraphTurnExt = { 1, "QueryGraphTurnExt", "com.graphhopper.routing", "QueryGraph", 0x0, 2, methods, 2, fields, 0, NULL};
  return &_QueryGraph_QueryGraphTurnExt;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(QueryGraph_QueryGraphTurnExt)

@implementation QueryGraph_$1

- (void)ensureNodeWithInt:(jint)nodeId {
  [((id<NodeAccess>) nil_chk(this$0_->mainNodeAccess_)) ensureNodeWithInt:nodeId];
}

- (jboolean)is3D {
  return [((id<NodeAccess>) nil_chk(this$0_->mainNodeAccess_)) is3D];
}

- (jint)getDimension {
  return [((id<NodeAccess>) nil_chk(this$0_->mainNodeAccess_)) getDimension];
}

- (jdouble)getLatitudeWithInt:(jint)nodeId {
  if ([this$0_ isVirtualNodeWithInt:nodeId]) return [((PointList *) nil_chk(this$0_->virtualNodes_)) getLatitudeWithInt:nodeId - this$0_->mainNodes_];
  return [((id<NodeAccess>) nil_chk(this$0_->mainNodeAccess_)) getLatitudeWithInt:nodeId];
}

- (jdouble)getLongitudeWithInt:(jint)nodeId {
  if ([this$0_ isVirtualNodeWithInt:nodeId]) return [((PointList *) nil_chk(this$0_->virtualNodes_)) getLongitudeWithInt:nodeId - this$0_->mainNodes_];
  return [((id<NodeAccess>) nil_chk(this$0_->mainNodeAccess_)) getLongitudeWithInt:nodeId];
}

- (jdouble)getElevationWithInt:(jint)nodeId {
  if ([this$0_ isVirtualNodeWithInt:nodeId]) return [((PointList *) nil_chk(this$0_->virtualNodes_)) getElevationWithInt:nodeId - this$0_->mainNodes_];
  return [((id<NodeAccess>) nil_chk(this$0_->mainNodeAccess_)) getElevationWithInt:nodeId];
}

- (jint)getAdditionalNodeFieldWithInt:(jint)nodeId {
  if ([this$0_ isVirtualNodeWithInt:nodeId]) return 0;
  return [((id<NodeAccess>) nil_chk(this$0_->mainNodeAccess_)) getAdditionalNodeFieldWithInt:nodeId];
}

- (void)setNodeWithInt:(jint)nodeId
            withDouble:(jdouble)lat
            withDouble:(jdouble)lon {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported yet."] autorelease];
}

- (void)setNodeWithInt:(jint)nodeId
            withDouble:(jdouble)lat
            withDouble:(jdouble)lon
            withDouble:(jdouble)ele {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported yet."] autorelease];
}

- (void)setAdditionalNodeFieldWithInt:(jint)nodeId
                              withInt:(jint)additionalValue {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported yet."] autorelease];
}

- (jdouble)getLatWithInt:(jint)nodeId {
  return [self getLatitudeWithInt:nodeId];
}

- (jdouble)getLonWithInt:(jint)nodeId {
  return [self getLongitudeWithInt:nodeId];
}

- (jdouble)getEleWithInt:(jint)nodeId {
  return [self getElevationWithInt:nodeId];
}

- (instancetype)initWithQueryGraph:(QueryGraph *)outer$ {
  QueryGraph_$1_set_this$0_(self, outer$);
  return [super init];
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(QueryGraph_$1 *)other {
  [super copyAllFieldsTo:other];
  QueryGraph_$1_set_this$0_(other, this$0_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "ensureNodeWithInt:", "ensureNode", "V", 0x1, NULL },
    { "is3D", NULL, "Z", 0x1, NULL },
    { "getDimension", NULL, "I", 0x1, NULL },
    { "getLatitudeWithInt:", "getLatitude", "D", 0x1, NULL },
    { "getLongitudeWithInt:", "getLongitude", "D", 0x1, NULL },
    { "getElevationWithInt:", "getElevation", "D", 0x1, NULL },
    { "getAdditionalNodeFieldWithInt:", "getAdditionalNodeField", "I", 0x1, NULL },
    { "setNodeWithInt:withDouble:withDouble:", "setNode", "V", 0x1, NULL },
    { "setNodeWithInt:withDouble:withDouble:withDouble:", "setNode", "V", 0x1, NULL },
    { "setAdditionalNodeFieldWithInt:withInt:", "setAdditionalNodeField", "V", 0x1, NULL },
    { "getLatWithInt:", "getLat", "D", 0x1, NULL },
    { "getLonWithInt:", "getLon", "D", 0x1, NULL },
    { "getEleWithInt:", "getEle", "D", 0x1, NULL },
    { "initWithQueryGraph:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lcom.graphhopper.routing.QueryGraph;", NULL,  },
  };
  static const J2ObjcClassInfo _QueryGraph_$1 = { 1, "$1", "com.graphhopper.routing", "QueryGraph", 0x8000, 14, methods, 1, fields, 0, NULL};
  return &_QueryGraph_$1;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(QueryGraph_$1)

BOOL QueryGraph_initialized = NO;

@implementation QueryGraph

AngleCalc * QueryGraph_AC_;

- (instancetype)initWithGraph:(id<Graph>)graph {
  if (self = [super init]) {
    QueryGraph_setAndConsume_cacheMap_(self, [[JavaUtilHashMap alloc] initWithInt:4]);
    QueryGraph_setAndConsume_nodeAccess_(self, [[QueryGraph_$1 alloc] initWithQueryGraph:self]);
    QueryGraph_setAndConsume_modifiedEdges_(self, [[JavaUtilArrayList alloc] initWithInt:5]);
    useEdgeExplorerCache_ = NO;
    QueryGraph_set_mainGraph_(self, graph);
    QueryGraph_set_mainNodeAccess_(self, [((id<Graph>) nil_chk(graph)) getNodeAccess]);
    mainNodes_ = [graph getNodes];
    mainEdges_ = [((id<AllEdgesIterator>) nil_chk([graph getAllEdges])) getMaxId];
    if ([[((id<Graph>) nil_chk(mainGraph_)) getExtension] isKindOfClass:[TurnCostExtension class]]) QueryGraph_setAndConsume_wrappedExtension_(self, [[QueryGraph_QueryGraphTurnExt alloc] initWithQueryGraph:self]);
    else QueryGraph_set_wrappedExtension_(self, [mainGraph_ getExtension]);
    QueryGraph_setAndConsume_baseGraph_(self, [[QueryGraph_$2 alloc] initWithGraph:[graph getBaseGraph] withQueryGraph:self]);
  }
  return self;
}

- (instancetype)initWithGraph:(id<Graph>)graph
               withQueryGraph:(QueryGraph *)superQueryGraph {
  if (self = [super init]) {
    QueryGraph_setAndConsume_cacheMap_(self, [[JavaUtilHashMap alloc] initWithInt:4]);
    QueryGraph_setAndConsume_nodeAccess_(self, [[QueryGraph_$1 alloc] initWithQueryGraph:self]);
    QueryGraph_setAndConsume_modifiedEdges_(self, [[JavaUtilArrayList alloc] initWithInt:5]);
    useEdgeExplorerCache_ = NO;
    QueryGraph_set_mainGraph_(self, graph);
    QueryGraph_set_baseGraph_(self, self);
    QueryGraph_set_wrappedExtension_(self, ((QueryGraph *) nil_chk(superQueryGraph))->wrappedExtension_);
    QueryGraph_set_mainNodeAccess_(self, [((id<Graph>) nil_chk(graph)) getNodeAccess]);
    mainNodes_ = superQueryGraph->mainNodes_;
    mainEdges_ = superQueryGraph->mainEdges_;
  }
  return self;
}

- (QueryGraph *)lookupWithQueryResult:(QueryResult *)fromRes
                      withQueryResult:(QueryResult *)toRes {
  id<JavaUtilList> results = [[[JavaUtilArrayList alloc] initWithInt:2] autorelease];
  [results addWithId:fromRes];
  [results addWithId:toRes];
  [self lookupWithJavaUtilList:results];
  return self;
}

- (void)lookupWithJavaUtilList:(id<JavaUtilList>)resList {
  if (QueryGraph_isInitialized(self)) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Call lookup only once. Otherwise you'll have problems for queries sharing the same edge."] autorelease];
  QueryGraph_setAndConsume_virtualEdges_(self, [[JavaUtilArrayList alloc] initWithInt:[((id<JavaUtilList>) nil_chk(resList)) size] * 2]);
  QueryGraph_setAndConsume_virtualNodes_(self, [[PointList alloc] initWithInt:[resList size] withBoolean:[((id<NodeAccess>) nil_chk(mainNodeAccess_)) is3D]]);
  QueryGraph_setAndConsume_queryResults_(self, [[JavaUtilArrayList alloc] initWithInt:[resList size]]);
  QueryGraph_set_virtualEdges_(nil_chk(baseGraph_), virtualEdges_);
  QueryGraph_set_virtualNodes_(baseGraph_, virtualNodes_);
  QueryGraph_set_queryResults_(baseGraph_, queryResults_);
  id<GnuTroveMapTIntObjectMap> edge2res = [[[GnuTroveMapHashTIntObjectHashMap alloc] initWithInt:[resList size]] autorelease];
  for (QueryResult * __strong res in resList) {
    if ([((QueryResult *) nil_chk(res)) getSnappedPosition] == QueryResult_PositionEnum_get_TOWER()) continue;
    id<EdgeIteratorState> closestEdge = [res getClosestEdge];
    if (closestEdge == nil) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$@", @"Do not call QueryGraph.lookup with invalid QueryResult ", res)] autorelease];
    jint base = [((id<EdgeIteratorState>) nil_chk(closestEdge)) getBaseNode];
    jboolean doReverse = base > [closestEdge getAdjNode];
    if (base == [closestEdge getAdjNode]) {
      PointList *pl = [closestEdge fetchWayGeometryWithInt:0];
      if ([((PointList *) nil_chk(pl)) size] > 1) doReverse = ([pl getLatitudeWithInt:0] > [pl getLatitudeWithInt:[pl size] - 1]);
    }
    if (doReverse) {
      closestEdge = [closestEdge detachWithBoolean:YES];
      PointList *fullPL = [((id<EdgeIteratorState>) nil_chk(closestEdge)) fetchWayGeometryWithInt:3];
      [res setClosestEdgeWithEdgeIteratorState:closestEdge];
      if ([res getSnappedPosition] == QueryResult_PositionEnum_get_PILLAR()) [res setWayIndexWithInt:[((PointList *) nil_chk(fullPL)) getSize] - [res getWayIndex] - 1];
      else [res setWayIndexWithInt:[((PointList *) nil_chk(fullPL)) getSize] - [res getWayIndex] - 2];
      if ([res getWayIndex] < 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$@$@", @"Problem with wayIndex while reversing closest edge:", closestEdge, @", ", res)] autorelease];
    }
    jint edgeId = [((id<EdgeIteratorState>) nil_chk(closestEdge)) getEdge];
    id<JavaUtilList> list = [edge2res getWithInt:edgeId];
    if (list == nil) {
      list = [[[JavaUtilArrayList alloc] initWithInt:5] autorelease];
      [edge2res putWithInt:edgeId withId:list];
    }
    [((id<JavaUtilList>) nil_chk(list)) addWithId:res];
  }
  [edge2res forEachValueWithGnuTroveProcedureTObjectProcedure:[[[QueryGraph_$3 alloc] initWithQueryGraph:self] autorelease]];
}

- (id<Graph>)getBaseGraph {
  return baseGraph_;
}

- (jboolean)isVirtualEdgeWithInt:(jint)edgeId {
  return edgeId >= mainEdges_;
}

- (jboolean)isVirtualNodeWithInt:(jint)nodeId {
  return nodeId >= mainNodes_;
}

- (QueryGraph *)setUseEdgeExplorerCacheWithBoolean:(jboolean)useEECache {
  self->useEdgeExplorerCache_ = useEECache;
  [((QueryGraph *) nil_chk(self->baseGraph_)) setUseEdgeExplorerCacheWithBoolean:useEECache];
  return self;
}

- (void)createEdgesWithInt:(jint)origTraversalKey
                   withInt:(jint)origRevTraversalKey
             withGHPoint3D:(GHPoint3D *)prevSnapped
                   withInt:(jint)prevWayIndex
             withGHPoint3D:(GHPoint3D *)currSnapped
                   withInt:(jint)wayIndex
             withPointList:(PointList *)fullPL
     withEdgeIteratorState:(id<EdgeIteratorState>)closestEdge
                   withInt:(jint)prevNodeId
                   withInt:(jint)nodeId
                  withLong:(jlong)reverseFlags {
  QueryGraph_createEdgesWithInt_withInt_withGHPoint3D_withInt_withGHPoint3D_withInt_withPointList_withEdgeIteratorState_withInt_withInt_withLong_(self, origTraversalKey, origRevTraversalKey, prevSnapped, prevWayIndex, currSnapped, wayIndex, fullPL, closestEdge, prevNodeId, nodeId, reverseFlags);
}

- (jboolean)enforceHeadingWithInt:(jint)nodeId
                       withDouble:(jdouble)favoredHeading
                      withBoolean:(jboolean)incoming {
  if (!QueryGraph_isInitialized(self)) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"QueryGraph.lookup has to be called in before heading enforcement"] autorelease];
  if (JavaLangDouble_isNaNWithDouble_(favoredHeading)) return NO;
  if (![self isVirtualNodeWithInt:nodeId]) return NO;
  jint virtNodeIDintern = nodeId - mainNodes_;
  favoredHeading = [((AngleCalc *) nil_chk(QueryGraph_AC_)) convertAzimuth2xaxisAngleWithDouble:favoredHeading];
  id<JavaUtilList> edgePositions = incoming ? JavaUtilArrays_asListWithNSObjectArray_([IOSObjectArray arrayWithObjects:(id[]){ JavaLangInteger_valueOfWithInt_(QueryGraph_VE_BASE), JavaLangInteger_valueOfWithInt_(QueryGraph_VE_ADJ_REV) } count:2 type:JavaLangInteger_class_()]) : JavaUtilArrays_asListWithNSObjectArray_([IOSObjectArray arrayWithObjects:(id[]){ JavaLangInteger_valueOfWithInt_(QueryGraph_VE_BASE_REV), JavaLangInteger_valueOfWithInt_(QueryGraph_VE_ADJ) } count:2 type:JavaLangInteger_class_()]);
  jboolean enforcementOccurred = NO;
  for (JavaLangInteger *boxed__ in edgePositions) {
    jint edgePos = [((JavaLangInteger *) nil_chk(boxed__)) intValue];
    VirtualEdgeIteratorState *edge = [((id<JavaUtilList>) nil_chk(virtualEdges_)) getWithInt:virtNodeIDintern * 4 + edgePos];
    PointList *wayGeo = [((VirtualEdgeIteratorState *) nil_chk(edge)) fetchWayGeometryWithInt:3];
    jdouble edgeOrientation;
    if (incoming) {
      jint numWayPoints = [((PointList *) nil_chk(wayGeo)) getSize];
      edgeOrientation = [QueryGraph_AC_ calcOrientationWithDouble:[wayGeo getLatWithInt:numWayPoints - 2] withDouble:[wayGeo getLonWithInt:numWayPoints - 2] withDouble:[wayGeo getLatWithInt:numWayPoints - 1] withDouble:[wayGeo getLonWithInt:numWayPoints - 1]];
    }
    else {
      edgeOrientation = [QueryGraph_AC_ calcOrientationWithDouble:[((PointList *) nil_chk(wayGeo)) getLatWithInt:0] withDouble:[wayGeo getLonWithInt:0] withDouble:[wayGeo getLatWithInt:1] withDouble:[wayGeo getLonWithInt:1]];
    }
    edgeOrientation = [QueryGraph_AC_ alignOrientationWithDouble:favoredHeading withDouble:edgeOrientation];
    jdouble delta = (edgeOrientation - favoredHeading);
    if (JavaLangMath_absWithDouble_(delta) > 1.74) {
      [edge setUnfavoredWithBoolean:YES];
      [((id<JavaUtilList>) nil_chk(modifiedEdges_)) addWithId:edge];
      VirtualEdgeIteratorState *reverseEdge = [virtualEdges_ getWithInt:virtNodeIDintern * 4 + QueryGraph_getPosOfReverseEdgeWithInt_(self, edgePos)];
      [((VirtualEdgeIteratorState *) nil_chk(reverseEdge)) setUnfavoredWithBoolean:YES];
      [modifiedEdges_ addWithId:reverseEdge];
      enforcementOccurred = YES;
    }
  }
  return enforcementOccurred;
}

- (jboolean)enforceHeadingByEdgeIdWithInt:(jint)nodeId
                                  withInt:(jint)edgeId
                              withBoolean:(jboolean)incoming {
  if (![self isVirtualNodeWithInt:nodeId]) return NO;
  VirtualEdgeIteratorState *incomingEdge = (VirtualEdgeIteratorState *) check_class_cast([self getEdgeIteratorStateWithInt:edgeId withInt:nodeId], [VirtualEdgeIteratorState class]);
  VirtualEdgeIteratorState *reverseEdge = (VirtualEdgeIteratorState *) check_class_cast([self getEdgeIteratorStateWithInt:edgeId withInt:[((VirtualEdgeIteratorState *) nil_chk(incomingEdge)) getBaseNode]], [VirtualEdgeIteratorState class]);
  [incomingEdge setUnfavoredWithBoolean:YES];
  [((id<JavaUtilList>) nil_chk(modifiedEdges_)) addWithId:incomingEdge];
  [((VirtualEdgeIteratorState *) nil_chk(reverseEdge)) setUnfavoredWithBoolean:YES];
  [modifiedEdges_ addWithId:reverseEdge];
  return YES;
}

- (void)clearUnfavoredStatus {
  for (VirtualEdgeIteratorState * __strong edge in nil_chk(modifiedEdges_)) {
    [((VirtualEdgeIteratorState *) nil_chk(edge)) setUnfavoredWithBoolean:NO];
  }
}

- (jint)getNodes {
  return [((PointList *) nil_chk(virtualNodes_)) getSize] + mainNodes_;
}

- (id<NodeAccess>)getNodeAccess {
  return nodeAccess_;
}

- (BBox *)getBounds {
  return [((id<Graph>) nil_chk(mainGraph_)) getBounds];
}

- (id<EdgeIteratorState>)getEdgeIteratorStateWithInt:(jint)origEdgeId
                                             withInt:(jint)adjNode {
  if (![self isVirtualEdgeWithInt:origEdgeId]) return [((id<Graph>) nil_chk(mainGraph_)) getEdgeIteratorStateWithInt:origEdgeId withInt:adjNode];
  jint edgeId = origEdgeId - mainEdges_;
  id<EdgeIteratorState> eis = [((id<JavaUtilList>) nil_chk(virtualEdges_)) getWithInt:edgeId];
  if ([((id<EdgeIteratorState>) nil_chk(eis)) getAdjNode] == adjNode || adjNode == JavaLangInteger_MIN_VALUE) return eis;
  edgeId = QueryGraph_getPosOfReverseEdgeWithInt_(self, edgeId);
  id<EdgeIteratorState> eis2 = [virtualEdges_ getWithInt:edgeId];
  if ([((id<EdgeIteratorState>) nil_chk(eis2)) getAdjNode] == adjNode) return eis2;
  @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$I$@$@", @"Edge ", origEdgeId, @" not found with adjNode:", adjNode, @". found edges were:", eis, @", ", eis2)] autorelease];
}

- (jint)getPosOfReverseEdgeWithInt:(jint)edgeId {
  return QueryGraph_getPosOfReverseEdgeWithInt_(self, edgeId);
}

- (id<EdgeExplorer>)createEdgeExplorerWithEdgeFilter:(id<EdgeFilter>)edgeFilter {
  if (!QueryGraph_isInitialized(self)) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Call lookup before using this graph"] autorelease];
  if (useEdgeExplorerCache_) {
    jint counter = -1;
    if ([edgeFilter isKindOfClass:[DefaultEdgeFilter class]]) {
      DefaultEdgeFilter *dee = (DefaultEdgeFilter *) check_class_cast(edgeFilter, [DefaultEdgeFilter class]);
      counter = 0;
      if ([((DefaultEdgeFilter *) nil_chk(dee)) acceptsBackward]) counter = 1;
      if ([dee acceptsForward]) counter += 2;
      if (counter == 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"You tried to use an edge filter blocking every access"] autorelease];
    }
    else if (edgeFilter == EdgeFilter_get_ALL_EDGES_()) {
      counter = 4;
    }
    if (counter >= 0) {
      id<EdgeExplorer> cached = [((id<JavaUtilMap>) nil_chk(cacheMap_)) getWithId:JavaLangInteger_valueOfWithInt_(counter)];
      if (cached == nil) {
        cached = QueryGraph_createUncachedEdgeExplorerWithEdgeFilter_(self, edgeFilter);
        [cacheMap_ putWithId:JavaLangInteger_valueOfWithInt_(counter) withId:cached];
      }
      return cached;
    }
  }
  return QueryGraph_createUncachedEdgeExplorerWithEdgeFilter_(self, edgeFilter);
}

- (id<EdgeExplorer>)createUncachedEdgeExplorerWithEdgeFilter:(id<EdgeFilter>)edgeFilter {
  return QueryGraph_createUncachedEdgeExplorerWithEdgeFilter_(self, edgeFilter);
}

- (void)addVirtualEdgesWithGnuTroveMapTIntObjectMap:(id<GnuTroveMapTIntObjectMap>)node2EdgeMap
                                     withEdgeFilter:(id<EdgeFilter>)filter
                                        withBoolean:(jboolean)base
                                            withInt:(jint)node
                                            withInt:(jint)virtNode {
  QueryGraph_addVirtualEdgesWithGnuTroveMapTIntObjectMap_withEdgeFilter_withBoolean_withInt_withInt_(self, node2EdgeMap, filter, base, node, virtNode);
}

- (void)fillVirtualEdgesWithGnuTroveMapTIntObjectMap:(id<GnuTroveMapTIntObjectMap>)node2Edge
                                             withInt:(jint)towerNode
                                    withEdgeExplorer:(id<EdgeExplorer>)mainExpl {
  if ([self isVirtualNodeWithInt:towerNode]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$@", @"Node should not be virtual:", towerNode, @", ", node2Edge)] autorelease];
  VirtualEdgeIterator *vIter = [((id<GnuTroveMapTIntObjectMap>) nil_chk(node2Edge)) getWithInt:towerNode];
  GnuTroveListArrayTIntArrayList *ignoreEdges = [[[GnuTroveListArrayTIntArrayList alloc] initWithInt:[((VirtualEdgeIterator *) nil_chk(vIter)) count] * 2] autorelease];
  while ([vIter next]) {
    id<EdgeIteratorState> edge = [((QueryResult *) nil_chk([((id<JavaUtilList>) nil_chk(queryResults_)) getWithInt:[vIter getAdjNode] - mainNodes_])) getClosestEdge];
    [ignoreEdges addWithInt:[((id<EdgeIteratorState>) nil_chk(edge)) getEdge]];
  }
  [vIter reset];
  id<EdgeIterator> iter = [((id<EdgeExplorer>) nil_chk(mainExpl)) setBaseNodeWithInt:towerNode];
  while ([((id<EdgeIterator>) nil_chk(iter)) next]) {
    if (![ignoreEdges containsWithInt:[iter getEdge]]) [vIter addWithEdgeIteratorState:[iter detachWithBoolean:NO]];
  }
}

- (jboolean)isInitialized {
  return QueryGraph_isInitialized(self);
}

- (id<EdgeExplorer>)createEdgeExplorer {
  return [self createEdgeExplorerWithEdgeFilter:EdgeFilter_get_ALL_EDGES_()];
}

- (id<AllEdgesIterator>)getAllEdges {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported yet."] autorelease];
}

- (id<EdgeIteratorState>)edgeWithInt:(jint)a
                             withInt:(jint)b {
  @throw QueryGraph_exc(self);
}

- (id<EdgeIteratorState>)edgeWithInt:(jint)a
                             withInt:(jint)b
                          withDouble:(jdouble)distance
                             withInt:(jint)flags {
  @throw QueryGraph_exc(self);
}

- (id<EdgeIteratorState>)edgeWithInt:(jint)a
                             withInt:(jint)b
                          withDouble:(jdouble)distance
                         withBoolean:(jboolean)bothDirections {
  @throw QueryGraph_exc(self);
}

- (id<Graph>)copyToWithGraph:(id<Graph>)g {
  @throw QueryGraph_exc(self);
}

- (id<GraphExtension>)getExtension {
  return wrappedExtension_;
}

- (JavaLangUnsupportedOperationException *)exc {
  return QueryGraph_exc(self);
}

- (void)dealloc {
  RELEASE_(mainGraph_);
  RELEASE_(mainNodeAccess_);
  RELEASE_(baseGraph_);
  RELEASE_(wrappedExtension_);
  RELEASE_(cacheMap_);
  RELEASE_(virtualEdges_);
  RELEASE_(queryResults_);
  RELEASE_(virtualNodes_);
  RELEASE_(nodeAccess_);
  RELEASE_(modifiedEdges_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(QueryGraph *)other {
  [super copyAllFieldsTo:other];
  QueryGraph_set_mainGraph_(other, mainGraph_);
  QueryGraph_set_mainNodeAccess_(other, mainNodeAccess_);
  other->mainNodes_ = mainNodes_;
  other->mainEdges_ = mainEdges_;
  QueryGraph_set_baseGraph_(other, baseGraph_);
  QueryGraph_set_wrappedExtension_(other, wrappedExtension_);
  QueryGraph_set_cacheMap_(other, cacheMap_);
  QueryGraph_set_virtualEdges_(other, virtualEdges_);
  QueryGraph_set_queryResults_(other, queryResults_);
  QueryGraph_set_virtualNodes_(other, virtualNodes_);
  QueryGraph_set_nodeAccess_(other, nodeAccess_);
  QueryGraph_set_modifiedEdges_(other, modifiedEdges_);
  other->useEdgeExplorerCache_ = useEdgeExplorerCache_;
}

+ (void)initialize {
  if (self == [QueryGraph class]) {
    JreStrongAssign(&QueryGraph_AC_, nil, Helper_get_ANGLE_CALC_());
    J2OBJC_SET_INITIALIZED(QueryGraph)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGraph:", "QueryGraph", NULL, 0x1, NULL },
    { "initWithGraph:withQueryGraph:", "QueryGraph", NULL, 0x2, NULL },
    { "lookupWithQueryResult:withQueryResult:", "lookup", "Lcom.graphhopper.routing.QueryGraph;", 0x1, NULL },
    { "lookupWithJavaUtilList:", "lookup", "V", 0x1, NULL },
    { "getBaseGraph", NULL, "Lcom.graphhopper.storage.Graph;", 0x1, NULL },
    { "isVirtualEdgeWithInt:", "isVirtualEdge", "Z", 0x1, NULL },
    { "isVirtualNodeWithInt:", "isVirtualNode", "Z", 0x1, NULL },
    { "setUseEdgeExplorerCacheWithBoolean:", "setUseEdgeExplorerCache", "Lcom.graphhopper.routing.QueryGraph;", 0x1, NULL },
    { "createEdgesWithInt:withInt:withGHPoint3D:withInt:withGHPoint3D:withInt:withPointList:withEdgeIteratorState:withInt:withInt:withLong:", "createEdges", "V", 0x2, NULL },
    { "enforceHeadingWithInt:withDouble:withBoolean:", "enforceHeading", "Z", 0x1, NULL },
    { "enforceHeadingByEdgeIdWithInt:withInt:withBoolean:", "enforceHeadingByEdgeId", "Z", 0x1, NULL },
    { "clearUnfavoredStatus", NULL, "V", 0x1, NULL },
    { "getNodes", NULL, "I", 0x1, NULL },
    { "getNodeAccess", NULL, "Lcom.graphhopper.storage.NodeAccess;", 0x1, NULL },
    { "getBounds", NULL, "Lcom.graphhopper.util.shapes.BBox;", 0x1, NULL },
    { "getEdgeIteratorStateWithInt:withInt:", "getEdgeIteratorState", "Lcom.graphhopper.util.EdgeIteratorState;", 0x1, NULL },
    { "getPosOfReverseEdgeWithInt:", "getPosOfReverseEdge", "I", 0x2, NULL },
    { "createEdgeExplorerWithEdgeFilter:", "createEdgeExplorer", "Lcom.graphhopper.util.EdgeExplorer;", 0x1, NULL },
    { "createUncachedEdgeExplorerWithEdgeFilter:", "createUncachedEdgeExplorer", "Lcom.graphhopper.util.EdgeExplorer;", 0x2, NULL },
    { "addVirtualEdgesWithGnuTroveMapTIntObjectMap:withEdgeFilter:withBoolean:withInt:withInt:", "addVirtualEdges", "V", 0x2, NULL },
    { "fillVirtualEdgesWithGnuTroveMapTIntObjectMap:withInt:withEdgeExplorer:", "fillVirtualEdges", "V", 0x0, NULL },
    { "isInitialized", NULL, "Z", 0x2, NULL },
    { "createEdgeExplorer", NULL, "Lcom.graphhopper.util.EdgeExplorer;", 0x1, NULL },
    { "getAllEdges", NULL, "Lcom.graphhopper.routing.util.AllEdgesIterator;", 0x1, NULL },
    { "edgeWithInt:withInt:", "edge", "Lcom.graphhopper.util.EdgeIteratorState;", 0x1, NULL },
    { "edgeWithInt:withInt:withDouble:withInt:", "edge", "Lcom.graphhopper.util.EdgeIteratorState;", 0x1, NULL },
    { "edgeWithInt:withInt:withDouble:withBoolean:", "edge", "Lcom.graphhopper.util.EdgeIteratorState;", 0x1, NULL },
    { "copyToWithGraph:", "copyTo", "Lcom.graphhopper.storage.Graph;", 0x1, NULL },
    { "getExtension", NULL, "Lcom.graphhopper.storage.GraphExtension;", 0x1, NULL },
    { "exc", NULL, "Ljava.lang.UnsupportedOperationException;", 0x2, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "VE_BASE_", NULL, 0x18, "I", NULL, .constantValue.asInt = QueryGraph_VE_BASE },
    { "VE_BASE_REV_", NULL, 0x18, "I", NULL, .constantValue.asInt = QueryGraph_VE_BASE_REV },
    { "VE_ADJ_", NULL, 0x18, "I", NULL, .constantValue.asInt = QueryGraph_VE_ADJ },
    { "VE_ADJ_REV_", NULL, 0x18, "I", NULL, .constantValue.asInt = QueryGraph_VE_ADJ_REV },
    { "AC_", NULL, 0x1a, "Lcom.graphhopper.util.AngleCalc;", &QueryGraph_AC_,  },
    { "mainGraph_", NULL, 0x12, "Lcom.graphhopper.storage.Graph;", NULL,  },
    { "mainNodeAccess_", NULL, 0x12, "Lcom.graphhopper.storage.NodeAccess;", NULL,  },
    { "mainNodes_", NULL, 0x12, "I", NULL,  },
    { "mainEdges_", NULL, 0x12, "I", NULL,  },
    { "baseGraph_", NULL, 0x12, "Lcom.graphhopper.routing.QueryGraph;", NULL,  },
    { "wrappedExtension_", NULL, 0x12, "Lcom.graphhopper.storage.GraphExtension;", NULL,  },
    { "cacheMap_", NULL, 0x12, "Ljava.util.Map;", NULL,  },
    { "virtualEdges_", NULL, 0x0, "Ljava.util.List;", NULL,  },
    { "queryResults_", NULL, 0x2, "Ljava.util.List;", NULL,  },
    { "virtualNodes_", NULL, 0x2, "Lcom.graphhopper.util.PointList;", NULL,  },
    { "nodeAccess_", NULL, 0x12, "Lcom.graphhopper.storage.NodeAccess;", NULL,  },
    { "modifiedEdges_", NULL, 0x2, "Ljava.util.List;", NULL,  },
    { "useEdgeExplorerCache_", NULL, 0x2, "Z", NULL,  },
  };
  static const J2ObjcClassInfo _QueryGraph = { 1, "QueryGraph", "com.graphhopper.routing", NULL, 0x1, 30, methods, 18, fields, 0, NULL};
  return &_QueryGraph;
}

@end

void QueryGraph_createEdgesWithInt_withInt_withGHPoint3D_withInt_withGHPoint3D_withInt_withPointList_withEdgeIteratorState_withInt_withInt_withLong_(QueryGraph *self, jint origTraversalKey, jint origRevTraversalKey, GHPoint3D *prevSnapped, jint prevWayIndex, GHPoint3D *currSnapped, jint wayIndex, PointList *fullPL, id<EdgeIteratorState> closestEdge, jint prevNodeId, jint nodeId, jlong reverseFlags) {
  jint max = wayIndex + 1;
  PointList *basePoints = [[[PointList alloc] initWithInt:max - prevWayIndex + 1 withBoolean:[((id<NodeAccess>) nil_chk(self->mainNodeAccess_)) is3D]] autorelease];
  [basePoints addWithDouble:((GHPoint3D *) nil_chk(prevSnapped))->lat_ withDouble:prevSnapped->lon_ withDouble:prevSnapped->ele_];
  for (jint i = prevWayIndex; i < max; i++) {
    [basePoints addWithPointAccess:fullPL withInt:i];
  }
  [basePoints addWithDouble:((GHPoint3D *) nil_chk(currSnapped))->lat_ withDouble:currSnapped->lon_ withDouble:currSnapped->ele_];
  PointList *baseReversePoints = [basePoints cloneWithBoolean:YES];
  jdouble baseDistance = [basePoints calcDistanceWithDistanceCalc:Helper_get_DIST_PLANE_()];
  jint virtEdgeId = self->mainEdges_ + [((id<JavaUtilList>) nil_chk(self->virtualEdges_)) size];
  VirtualEdgeIteratorState *baseEdge = [[[VirtualEdgeIteratorState alloc] initWithInt:origTraversalKey withInt:virtEdgeId withInt:prevNodeId withInt:nodeId withDouble:baseDistance withLong:[((id<EdgeIteratorState>) nil_chk(closestEdge)) getFlags] withNSString:[closestEdge getName] withPointList:basePoints] autorelease];
  VirtualEdgeIteratorState *baseReverseEdge = [[[VirtualEdgeIteratorState alloc] initWithInt:origRevTraversalKey withInt:virtEdgeId withInt:nodeId withInt:prevNodeId withDouble:baseDistance withLong:reverseFlags withNSString:[closestEdge getName] withPointList:baseReversePoints] autorelease];
  [self->virtualEdges_ addWithId:baseEdge];
  [self->virtualEdges_ addWithId:baseReverseEdge];
}

jint QueryGraph_getPosOfReverseEdgeWithInt_(QueryGraph *self, jint edgeId) {
  if (edgeId % 2 == 0) edgeId++;
  else edgeId--;
  return edgeId;
}

id<EdgeExplorer> QueryGraph_createUncachedEdgeExplorerWithEdgeFilter_(QueryGraph *self, id<EdgeFilter> edgeFilter) {
  id<GnuTroveMapTIntObjectMap> node2EdgeMap = [[[GnuTroveMapHashTIntObjectHashMap alloc] initWithInt:[((id<JavaUtilList>) nil_chk(self->queryResults_)) size] * 3] autorelease];
  id<EdgeExplorer> mainExplorer = [((id<Graph>) nil_chk(self->mainGraph_)) createEdgeExplorerWithEdgeFilter:edgeFilter];
  GnuTroveSetHashTIntHashSet *towerNodesToChange = [[[GnuTroveSetHashTIntHashSet alloc] initWithInt:[self->queryResults_ size]] autorelease];
  for (jint i = 0; i < [self->queryResults_ size]; i++) {
    VirtualEdgeIterator *virtEdgeIter = [[[VirtualEdgeIterator alloc] initWithInt:2] autorelease];
    id<EdgeIteratorState> baseRevEdge = [((id<JavaUtilList>) nil_chk(self->virtualEdges_)) getWithInt:i * 4 + QueryGraph_VE_BASE_REV];
    if ([((id<EdgeFilter>) nil_chk(edgeFilter)) acceptWithEdgeIteratorState:baseRevEdge]) [virtEdgeIter addWithEdgeIteratorState:baseRevEdge];
    id<EdgeIteratorState> adjEdge = [self->virtualEdges_ getWithInt:i * 4 + QueryGraph_VE_ADJ];
    if ([edgeFilter acceptWithEdgeIteratorState:adjEdge]) [virtEdgeIter addWithEdgeIteratorState:adjEdge];
    jint virtNode = self->mainNodes_ + i;
    [node2EdgeMap putWithInt:virtNode withId:virtEdgeIter];
    jint towerNode = [((id<EdgeIteratorState>) nil_chk(baseRevEdge)) getAdjNode];
    if (![self isVirtualNodeWithInt:towerNode]) {
      [towerNodesToChange addWithInt:towerNode];
      QueryGraph_addVirtualEdgesWithGnuTroveMapTIntObjectMap_withEdgeFilter_withBoolean_withInt_withInt_(self, node2EdgeMap, edgeFilter, YES, towerNode, i);
    }
    towerNode = [((id<EdgeIteratorState>) nil_chk(adjEdge)) getAdjNode];
    if (![self isVirtualNodeWithInt:towerNode]) {
      [towerNodesToChange addWithInt:towerNode];
      QueryGraph_addVirtualEdgesWithGnuTroveMapTIntObjectMap_withEdgeFilter_withBoolean_withInt_withInt_(self, node2EdgeMap, edgeFilter, NO, towerNode, i);
    }
  }
  [towerNodesToChange forEachWithGnuTroveProcedureTIntProcedure:[[[QueryGraph_$4 alloc] initWithQueryGraph:self withGnuTroveMapTIntObjectMap:node2EdgeMap withEdgeExplorer:mainExplorer] autorelease]];
  return [[[QueryGraph_$5 alloc] initWithGnuTroveMapTIntObjectMap:node2EdgeMap withEdgeExplorer:mainExplorer] autorelease];
}

void QueryGraph_addVirtualEdgesWithGnuTroveMapTIntObjectMap_withEdgeFilter_withBoolean_withInt_withInt_(QueryGraph *self, id<GnuTroveMapTIntObjectMap> node2EdgeMap, id<EdgeFilter> filter, jboolean base, jint node, jint virtNode) {
  VirtualEdgeIterator *existingIter = [((id<GnuTroveMapTIntObjectMap>) nil_chk(node2EdgeMap)) getWithInt:node];
  if (existingIter == nil) {
    existingIter = [[[VirtualEdgeIterator alloc] initWithInt:10] autorelease];
    [node2EdgeMap putWithInt:node withId:existingIter];
  }
  id<EdgeIteratorState> edge = base ? [((id<JavaUtilList>) nil_chk(self->virtualEdges_)) getWithInt:virtNode * 4 + QueryGraph_VE_BASE] : [((id<JavaUtilList>) nil_chk(self->virtualEdges_)) getWithInt:virtNode * 4 + QueryGraph_VE_ADJ_REV];
  if ([((id<EdgeFilter>) nil_chk(filter)) acceptWithEdgeIteratorState:edge]) [((VirtualEdgeIterator *) nil_chk(existingIter)) addWithEdgeIteratorState:edge];
}

jboolean QueryGraph_isInitialized(QueryGraph *self) {
  return self->queryResults_ != nil;
}

JavaLangUnsupportedOperationException *QueryGraph_exc(QueryGraph *self) {
  return [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"QueryGraph cannot be modified."] autorelease];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(QueryGraph)

@implementation QueryGraph_$2

- (QueryGraph *)setUseEdgeExplorerCacheWithBoolean:(jboolean)useEECache {
  ((QueryGraph *) nil_chk(baseGraph_))->useEdgeExplorerCache_ = useEECache;
  return baseGraph_;
}

- (instancetype)initWithGraph:(id<Graph>)arg$0
               withQueryGraph:(QueryGraph *)arg$1 {
  return [super initWithGraph:arg$0 withQueryGraph:arg$1];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "setUseEdgeExplorerCacheWithBoolean:", "setUseEdgeExplorerCache", "Lcom.graphhopper.routing.QueryGraph;", 0x1, NULL },
    { "initWithGraph:withQueryGraph:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcClassInfo _QueryGraph_$2 = { 1, "$2", "com.graphhopper.routing", "QueryGraph", 0x8000, 2, methods, 0, NULL, 0, NULL};
  return &_QueryGraph_$2;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(QueryGraph_$2)

@implementation QueryGraph_$3

- (jboolean)executeWithId:(id<JavaUtilList>)results {
  id<EdgeIteratorState> closestEdge = [((QueryResult *) nil_chk([((id<JavaUtilList>) nil_chk(results)) getWithInt:0])) getClosestEdge];
  PointList *fullPL = [((id<EdgeIteratorState>) nil_chk(closestEdge)) fetchWayGeometryWithInt:3];
  jint baseNode = [closestEdge getBaseNode];
  JavaUtilCollections_sortWithJavaUtilList_withJavaUtilComparator_(results, [[[QueryGraph_$3_$1 alloc] initWithPointList:fullPL] autorelease]);
  GHPoint3D *prevPoint = [((PointList *) nil_chk(fullPL)) toGHPointWithInt:0];
  jint adjNode = [closestEdge getAdjNode];
  jint origTraversalKey = GHUtility_createEdgeKeyWithInt_withInt_withInt_withBoolean_(baseNode, adjNode, [closestEdge getEdge], NO);
  jint origRevTraversalKey = GHUtility_createEdgeKeyWithInt_withInt_withInt_withBoolean_(baseNode, adjNode, [closestEdge getEdge], YES);
  jlong reverseFlags = [((id<EdgeIteratorState>) nil_chk([closestEdge detachWithBoolean:YES])) getFlags];
  jint prevWayIndex = 1;
  jint prevNodeId = baseNode;
  jint virtNodeId = [((PointList *) nil_chk(this$0_->virtualNodes_)) getSize] + this$0_->mainNodes_;
  jboolean addedEdges = NO;
  for (jint counter = 0; counter < [results size]; counter++) {
    QueryResult *res = [results getWithInt:counter];
    if ([((id<EdgeIteratorState>) nil_chk([((QueryResult *) nil_chk(res)) getClosestEdge])) getBaseNode] != baseNode) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$@$@", @"Base nodes have to be identical but were not: ", closestEdge, @" vs ", [res getClosestEdge])] autorelease];
    GHPoint3D *currSnapped = [res getSnappedPoint];
    if ([((GHPoint3D *) nil_chk(prevPoint)) isEqual:currSnapped]) {
      [res setClosestNodeWithInt:prevNodeId];
      continue;
    }
    [((id<JavaUtilList>) nil_chk(this$0_->queryResults_)) addWithId:res];
    QueryGraph_createEdgesWithInt_withInt_withGHPoint3D_withInt_withGHPoint3D_withInt_withPointList_withEdgeIteratorState_withInt_withInt_withLong_(this$0_, origTraversalKey, origRevTraversalKey, prevPoint, prevWayIndex, [res getSnappedPoint], [res getWayIndex], fullPL, closestEdge, prevNodeId, virtNodeId, reverseFlags);
    [this$0_->virtualNodes_ addWithDouble:((GHPoint3D *) nil_chk(currSnapped))->lat_ withDouble:currSnapped->lon_ withDouble:currSnapped->ele_];
    if (addedEdges) {
      [this$0_->virtualEdges_ addWithId:[this$0_->virtualEdges_ getWithInt:[((id<JavaUtilList>) nil_chk(this$0_->virtualEdges_)) size] - 2]];
      [this$0_->virtualEdges_ addWithId:[this$0_->virtualEdges_ getWithInt:[this$0_->virtualEdges_ size] - 2]];
    }
    addedEdges = YES;
    [res setClosestNodeWithInt:virtNodeId];
    prevNodeId = virtNodeId;
    prevWayIndex = [res getWayIndex] + 1;
    prevPoint = currSnapped;
    virtNodeId++;
  }
  if (addedEdges) QueryGraph_createEdgesWithInt_withInt_withGHPoint3D_withInt_withGHPoint3D_withInt_withPointList_withEdgeIteratorState_withInt_withInt_withLong_(this$0_, origTraversalKey, origRevTraversalKey, prevPoint, prevWayIndex, [fullPL toGHPointWithInt:[fullPL getSize] - 1], [fullPL getSize] - 2, fullPL, closestEdge, virtNodeId - 1, adjNode, reverseFlags);
  return YES;
}

- (instancetype)initWithQueryGraph:(QueryGraph *)outer$ {
  QueryGraph_$3_set_this$0_(self, outer$);
  return [super init];
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(QueryGraph_$3 *)other {
  [super copyAllFieldsTo:other];
  QueryGraph_$3_set_this$0_(other, this$0_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "executeWithJavaUtilList:", "execute", "Z", 0x1, NULL },
    { "initWithQueryGraph:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lcom.graphhopper.routing.QueryGraph;", NULL,  },
  };
  static const J2ObjcClassInfo _QueryGraph_$3 = { 1, "$3", "com.graphhopper.routing", "QueryGraph", 0x8000, 2, methods, 1, fields, 0, NULL};
  return &_QueryGraph_$3;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(QueryGraph_$3)

@implementation QueryGraph_$3_$1

- (jint)compareWithId:(QueryResult *)o1
               withId:(QueryResult *)o2 {
  jint diff = [((QueryResult *) nil_chk(o1)) getWayIndex] - [((QueryResult *) nil_chk(o2)) getWayIndex];
  if (diff == 0) {
    GHPoint *p1 = [o1 getSnappedPoint];
    GHPoint *p2 = [o2 getSnappedPoint];
    if ([((GHPoint *) nil_chk(p1)) isEqual:p2]) return 0;
    jdouble fromLat = [((PointList *) nil_chk(val$fullPL_)) getLatitudeWithInt:[o1 getWayIndex]];
    jdouble fromLon = [val$fullPL_ getLongitudeWithInt:[o1 getWayIndex]];
    if ([((DistancePlaneProjection *) nil_chk(Helper_get_DIST_PLANE_())) calcNormalizedDistWithDouble:fromLat withDouble:fromLon withDouble:p1->lat_ withDouble:p1->lon_] > [Helper_get_DIST_PLANE_() calcNormalizedDistWithDouble:fromLat withDouble:fromLon withDouble:((GHPoint *) nil_chk(p2))->lat_ withDouble:p2->lon_]) return 1;
    return -1;
  }
  return diff;
}

- (instancetype)initWithPointList:(PointList *)capture$0 {
  QueryGraph_$3_$1_set_val$fullPL_(self, capture$0);
  return [super init];
}

- (void)dealloc {
  RELEASE_(val$fullPL_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(QueryGraph_$3_$1 *)other {
  [super copyAllFieldsTo:other];
  QueryGraph_$3_$1_set_val$fullPL_(other, val$fullPL_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "compareWithQueryResult:withQueryResult:", "compare", "I", 0x1, NULL },
    { "initWithPointList:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "val$fullPL_", NULL, 0x1012, "Lcom.graphhopper.util.PointList;", NULL,  },
  };
  static const J2ObjcClassInfo _QueryGraph_$3_$1 = { 1, "$1", "com.graphhopper.routing", "QueryGraph$$3", 0x8000, 2, methods, 1, fields, 0, NULL};
  return &_QueryGraph_$3_$1;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(QueryGraph_$3_$1)

@implementation QueryGraph_$4

- (jboolean)executeWithInt:(jint)value {
  [this$0_ fillVirtualEdgesWithGnuTroveMapTIntObjectMap:val$node2EdgeMap_ withInt:value withEdgeExplorer:val$mainExplorer_];
  return YES;
}

- (instancetype)initWithQueryGraph:(QueryGraph *)outer$
      withGnuTroveMapTIntObjectMap:(id<GnuTroveMapTIntObjectMap>)capture$0
                  withEdgeExplorer:(id<EdgeExplorer>)capture$1 {
  QueryGraph_$4_set_this$0_(self, outer$);
  QueryGraph_$4_set_val$node2EdgeMap_(self, capture$0);
  QueryGraph_$4_set_val$mainExplorer_(self, capture$1);
  return [super init];
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(val$node2EdgeMap_);
  RELEASE_(val$mainExplorer_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(QueryGraph_$4 *)other {
  [super copyAllFieldsTo:other];
  QueryGraph_$4_set_this$0_(other, this$0_);
  QueryGraph_$4_set_val$node2EdgeMap_(other, val$node2EdgeMap_);
  QueryGraph_$4_set_val$mainExplorer_(other, val$mainExplorer_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "executeWithInt:", "execute", "Z", 0x1, NULL },
    { "initWithQueryGraph:withGnuTroveMapTIntObjectMap:withEdgeExplorer:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lcom.graphhopper.routing.QueryGraph;", NULL,  },
    { "val$node2EdgeMap_", NULL, 0x1012, "Lgnu.trove.map.TIntObjectMap;", NULL,  },
    { "val$mainExplorer_", NULL, 0x1012, "Lcom.graphhopper.util.EdgeExplorer;", NULL,  },
  };
  static const J2ObjcClassInfo _QueryGraph_$4 = { 1, "$4", "com.graphhopper.routing", "QueryGraph", 0x8000, 2, methods, 3, fields, 0, NULL};
  return &_QueryGraph_$4;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(QueryGraph_$4)

@implementation QueryGraph_$5

- (id<EdgeIterator>)setBaseNodeWithInt:(jint)baseNode {
  VirtualEdgeIterator *iter = [((id<GnuTroveMapTIntObjectMap>) nil_chk(val$node2EdgeMap_)) getWithInt:baseNode];
  if (iter != nil) return [iter reset];
  return [((id<EdgeExplorer>) nil_chk(val$mainExplorer_)) setBaseNodeWithInt:baseNode];
}

- (instancetype)initWithGnuTroveMapTIntObjectMap:(id<GnuTroveMapTIntObjectMap>)capture$0
                                withEdgeExplorer:(id<EdgeExplorer>)capture$1 {
  QueryGraph_$5_set_val$node2EdgeMap_(self, capture$0);
  QueryGraph_$5_set_val$mainExplorer_(self, capture$1);
  return [super init];
}

- (void)dealloc {
  RELEASE_(val$node2EdgeMap_);
  RELEASE_(val$mainExplorer_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(QueryGraph_$5 *)other {
  [super copyAllFieldsTo:other];
  QueryGraph_$5_set_val$node2EdgeMap_(other, val$node2EdgeMap_);
  QueryGraph_$5_set_val$mainExplorer_(other, val$mainExplorer_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "setBaseNodeWithInt:", "setBaseNode", "Lcom.graphhopper.util.EdgeIterator;", 0x1, NULL },
    { "initWithGnuTroveMapTIntObjectMap:withEdgeExplorer:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "val$node2EdgeMap_", NULL, 0x1012, "Lgnu.trove.map.TIntObjectMap;", NULL,  },
    { "val$mainExplorer_", NULL, 0x1012, "Lcom.graphhopper.util.EdgeExplorer;", NULL,  },
  };
  static const J2ObjcClassInfo _QueryGraph_$5 = { 1, "$5", "com.graphhopper.routing", "QueryGraph", 0x8000, 2, methods, 2, fields, 0, NULL};
  return &_QueryGraph_$5;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(QueryGraph_$5)
