//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/storage/Storable.java
//

#ifndef _Storable_H_
#define _Storable_H_

#include "J2ObjC_header.h"
#include "java/io/Closeable.h"

/**
 @brief Interface for a storage abstraction.
 Currently is serves just the purpose to ensure the same methods and names through all kind of 'storable' things in graphhopper. <p> Then the lifecycle is identical for all such objects: <ol> <li>object creation via new</li> <li>optional configuration via additional setters and getters which are not in this interface</li> <li>if(!storable.loadExisting()) storable.create()</li> <li>usage storable and optional flush() calls in-between. Keep in mind that some data structure could require a call to increase memory while usage. E.g. DataAccess.ensureCapacity()</li> <li>Finally do close() which does no flush()</li> </ol> <p>
 @author Peter Karich
 */
@protocol Storable < JavaIoCloseable, NSObject, JavaObject >
/**
 @return true if successfully loaded from persistent storage.
 */
- (jboolean)loadExisting;

/**
 @brief Creates the underlying storage.
 First operation if it cannot be loaded.
 */
- (id)createWithLong:(jlong)byteCount;

/**
 @brief This method makes sure that the underlying data is written to the storage.
 Keep in mind that a disc normally has an IO cache so that flush() is (less) probably not save against power loses.
 */
- (void)flush;

/**
 @brief This method makes sure that the underlying used resources are released.
 WARNING: it does NOT flush on close!
 */
- (void)close;

- (jboolean)isClosed;

/**
 @return the allocated storage size in bytes
 */
- (jlong)getCapacity;

@end

J2OBJC_EMPTY_STATIC_INIT(Storable)

#define ComGraphhopperStorageStorable Storable

J2OBJC_TYPE_LITERAL_HEADER(Storable)

#endif // _Storable_H_
