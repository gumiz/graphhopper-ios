//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
//

#include "J2ObjC_source.h"
#include "com/graphhopper/storage/BaseGraph.h"
#include "com/graphhopper/storage/DataAccess.h"
#include "com/graphhopper/storage/GHNodeAccess.h"
#include "com/graphhopper/storage/GraphExtension.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/shapes/BBox.h"
#include "java/lang/AssertionError.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalStateException.h"

__attribute__((unused)) static void GHNodeAccess_setNodeWithInt_withDouble_withDouble_withDouble_(GHNodeAccess *self, jint nodeId, jdouble lat, jdouble lon, jdouble ele);
__attribute__((unused)) static jdouble GHNodeAccess_getLatitudeWithInt_(GHNodeAccess *self, jint nodeId);
__attribute__((unused)) static jdouble GHNodeAccess_getLongitudeWithInt_(GHNodeAccess *self, jint nodeId);
__attribute__((unused)) static jdouble GHNodeAccess_getElevationWithInt_(GHNodeAccess *self, jint nodeId);
__attribute__((unused)) static jboolean GHNodeAccess_is3D(GHNodeAccess *self);

@interface GHNodeAccess () {
 @public
  BaseGraph *that_;
  jboolean elevation_;
}
@end

J2OBJC_FIELD_SETTER(GHNodeAccess, that_, BaseGraph *)

@implementation GHNodeAccess

- (instancetype)initWithBaseGraph:(BaseGraph *)that
                      withBoolean:(jboolean)withElevation {
  if (self = [super init]) {
    GHNodeAccess_set_that_(self, that);
    self->elevation_ = withElevation;
  }
  return self;
}

- (void)ensureNodeWithInt:(jint)nodeId {
  [((BaseGraph *) nil_chk(that_)) ensureNodeIndexWithInt:nodeId];
}

- (void)setNodeWithInt:(jint)nodeId
            withDouble:(jdouble)lat
            withDouble:(jdouble)lon {
  GHNodeAccess_setNodeWithInt_withDouble_withDouble_withDouble_(self, nodeId, lat, lon, JavaLangDouble_NaN);
}

- (void)setNodeWithInt:(jint)nodeId
            withDouble:(jdouble)lat
            withDouble:(jdouble)lon
            withDouble:(jdouble)ele {
  GHNodeAccess_setNodeWithInt_withDouble_withDouble_withDouble_(self, nodeId, lat, lon, ele);
}

- (jdouble)getLatitudeWithInt:(jint)nodeId {
  return GHNodeAccess_getLatitudeWithInt_(self, nodeId);
}

- (jdouble)getLongitudeWithInt:(jint)nodeId {
  return GHNodeAccess_getLongitudeWithInt_(self, nodeId);
}

- (jdouble)getElevationWithInt:(jint)nodeId {
  return GHNodeAccess_getElevationWithInt_(self, nodeId);
}

- (jdouble)getEleWithInt:(jint)nodeId {
  return GHNodeAccess_getElevationWithInt_(self, nodeId);
}

- (jdouble)getLatWithInt:(jint)nodeId {
  return GHNodeAccess_getLatitudeWithInt_(self, nodeId);
}

- (jdouble)getLonWithInt:(jint)nodeId {
  return GHNodeAccess_getLongitudeWithInt_(self, nodeId);
}

- (void)setAdditionalNodeFieldWithInt:(jint)index
                              withInt:(jint)additionalValue {
  if ([((id<GraphExtension>) nil_chk(((BaseGraph *) nil_chk(that_))->extStorage_)) isRequireNodeField] && that_->N_ADDITIONAL_ >= 0) {
    [that_ ensureNodeIndexWithInt:index];
    jlong tmp = (jlong) index * that_->nodeEntryBytes_;
    [((id<DataAccess>) nil_chk(that_->nodes_)) setIntWithLong:tmp + that_->N_ADDITIONAL_ withInt:additionalValue];
  }
  else {
    @throw [[[JavaLangAssertionError alloc] initWithId:@"This graph does not provide an additional node field"] autorelease];
  }
}

- (jint)getAdditionalNodeFieldWithInt:(jint)index {
  if ([((id<GraphExtension>) nil_chk(((BaseGraph *) nil_chk(that_))->extStorage_)) isRequireNodeField] && that_->N_ADDITIONAL_ >= 0) return [((id<DataAccess>) nil_chk(that_->nodes_)) getIntWithLong:(jlong) index * that_->nodeEntryBytes_ + that_->N_ADDITIONAL_];
  else @throw [[[JavaLangAssertionError alloc] initWithId:@"This graph does not provide an additional node field"] autorelease];
}

- (jboolean)is3D {
  return GHNodeAccess_is3D(self);
}

- (jint)getDimension {
  if (elevation_) return 3;
  return 2;
}

- (void)dealloc {
  RELEASE_(that_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(GHNodeAccess *)other {
  [super copyAllFieldsTo:other];
  GHNodeAccess_set_that_(other, that_);
  other->elevation_ = elevation_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithBaseGraph:withBoolean:", "GHNodeAccess", NULL, 0x1, NULL },
    { "ensureNodeWithInt:", "ensureNode", "V", 0x1, NULL },
    { "setNodeWithInt:withDouble:withDouble:", "setNode", "V", 0x11, NULL },
    { "setNodeWithInt:withDouble:withDouble:withDouble:", "setNode", "V", 0x11, NULL },
    { "getLatitudeWithInt:", "getLatitude", "D", 0x11, NULL },
    { "getLongitudeWithInt:", "getLongitude", "D", 0x11, NULL },
    { "getElevationWithInt:", "getElevation", "D", 0x11, NULL },
    { "getEleWithInt:", "getEle", "D", 0x11, NULL },
    { "getLatWithInt:", "getLat", "D", 0x11, NULL },
    { "getLonWithInt:", "getLon", "D", 0x11, NULL },
    { "setAdditionalNodeFieldWithInt:withInt:", "setAdditionalNodeField", "V", 0x11, NULL },
    { "getAdditionalNodeFieldWithInt:", "getAdditionalNodeField", "I", 0x11, NULL },
    { "is3D", NULL, "Z", 0x11, NULL },
    { "getDimension", NULL, "I", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "that_", NULL, 0x12, "Lcom.graphhopper.storage.BaseGraph;", NULL,  },
    { "elevation_", NULL, 0x12, "Z", NULL,  },
  };
  static const J2ObjcClassInfo _GHNodeAccess = { 1, "GHNodeAccess", "com.graphhopper.storage", NULL, 0x0, 14, methods, 2, fields, 0, NULL};
  return &_GHNodeAccess;
}

@end

void GHNodeAccess_setNodeWithInt_withDouble_withDouble_withDouble_(GHNodeAccess *self, jint nodeId, jdouble lat, jdouble lon, jdouble ele) {
  [((BaseGraph *) nil_chk(self->that_)) ensureNodeIndexWithInt:nodeId];
  jlong tmp = (jlong) nodeId * self->that_->nodeEntryBytes_;
  [((id<DataAccess>) nil_chk(self->that_->nodes_)) setIntWithLong:tmp + self->that_->N_LAT_ withInt:Helper_degreeToIntWithDouble_(lat)];
  [self->that_->nodes_ setIntWithLong:tmp + self->that_->N_LON_ withInt:Helper_degreeToIntWithDouble_(lon)];
  if (GHNodeAccess_is3D(self)) {
    [self->that_->nodes_ setIntWithLong:tmp + self->that_->N_ELE_ withInt:Helper_eleToIntWithDouble_(ele)];
    [((BBox *) nil_chk(self->that_->bounds_)) updateWithDouble:lat withDouble:lon withDouble:ele];
  }
  else {
    [((BBox *) nil_chk(self->that_->bounds_)) updateWithDouble:lat withDouble:lon];
  }
  if ([((id<GraphExtension>) nil_chk(self->that_->extStorage_)) isRequireNodeField]) [self->that_->nodes_ setIntWithLong:tmp + self->that_->N_ADDITIONAL_ withInt:[self->that_->extStorage_ getDefaultNodeFieldValue]];
}

jdouble GHNodeAccess_getLatitudeWithInt_(GHNodeAccess *self, jint nodeId) {
  return Helper_intToDegreeWithInt_([((id<DataAccess>) nil_chk(((BaseGraph *) nil_chk(self->that_))->nodes_)) getIntWithLong:(jlong) nodeId * self->that_->nodeEntryBytes_ + self->that_->N_LAT_]);
}

jdouble GHNodeAccess_getLongitudeWithInt_(GHNodeAccess *self, jint nodeId) {
  return Helper_intToDegreeWithInt_([((id<DataAccess>) nil_chk(((BaseGraph *) nil_chk(self->that_))->nodes_)) getIntWithLong:(jlong) nodeId * self->that_->nodeEntryBytes_ + self->that_->N_LON_]);
}

jdouble GHNodeAccess_getElevationWithInt_(GHNodeAccess *self, jint nodeId) {
  if (!self->elevation_) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Cannot access elevation - 3D is not enabled"] autorelease];
  return Helper_intToEleWithInt_([((id<DataAccess>) nil_chk(((BaseGraph *) nil_chk(self->that_))->nodes_)) getIntWithLong:(jlong) nodeId * self->that_->nodeEntryBytes_ + self->that_->N_ELE_]);
}

jboolean GHNodeAccess_is3D(GHNodeAccess *self) {
  return self->elevation_;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GHNodeAccess)
