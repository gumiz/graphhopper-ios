//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
//

#include "J2ObjC_source.h"
#include "com/graphhopper/storage/DataAccess.h"
#include "com/graphhopper/storage/Directory.h"
#include "com/graphhopper/storage/Graph.h"
#include "com/graphhopper/storage/GraphExtension.h"
#include "com/graphhopper/storage/NodeAccess.h"
#include "com/graphhopper/storage/TurnCostExtension.h"
#include "com/graphhopper/util/EdgeIterator.h"
#include "java/lang/AssertionError.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/UnsupportedOperationException.h"

__attribute__((unused)) static jint TurnCostExtension_nextTurnCostEntryIndex(TurnCostExtension *self);
__attribute__((unused)) static jlong TurnCostExtension_nextCostFlagsWithInt_withInt_withInt_(TurnCostExtension *self, jint edgeFrom, jint nodeVia, jint edgeTo);
__attribute__((unused)) static void TurnCostExtension_ensureTurnCostIndexWithInt_(TurnCostExtension *self, jint nodeIndex);

@interface TurnCostExtension () {
 @public
  jint TC_FROM_, TC_TO_, TC_FLAGS_, TC_NEXT_;
  id<DataAccess> turnCosts_;
  jint turnCostsEntryIndex_;
  jint turnCostsEntryBytes_;
  jint turnCostsCount_;
  id<NodeAccess> nodeAccess_;
}

- (jint)nextTurnCostEntryIndex;

- (jlong)nextCostFlagsWithInt:(jint)edgeFrom
                      withInt:(jint)nodeVia
                      withInt:(jint)edgeTo;

- (void)ensureTurnCostIndexWithInt:(jint)nodeIndex;
@end

J2OBJC_FIELD_SETTER(TurnCostExtension, turnCosts_, id<DataAccess>)
J2OBJC_FIELD_SETTER(TurnCostExtension, nodeAccess_, id<NodeAccess>)

@implementation TurnCostExtension

- (instancetype)init {
  if (self = [super init]) {
    turnCostsEntryIndex_ = -4;
    TC_FROM_ = TurnCostExtension_nextTurnCostEntryIndex(self);
    TC_TO_ = TurnCostExtension_nextTurnCostEntryIndex(self);
    TC_FLAGS_ = TurnCostExtension_nextTurnCostEntryIndex(self);
    TC_NEXT_ = TurnCostExtension_nextTurnCostEntryIndex(self);
    turnCostsEntryBytes_ = turnCostsEntryIndex_ + 4;
    turnCostsCount_ = 0;
  }
  return self;
}

- (void)init__WithGraph:(id<Graph>)graph
          withDirectory:(id<Directory>)dir {
  if (turnCostsCount_ > 0) @throw [[[JavaLangAssertionError alloc] initWithId:@"The turn cost storage must be initialized only once."] autorelease];
  TurnCostExtension_set_nodeAccess_(self, [((id<Graph>) nil_chk(graph)) getNodeAccess]);
  TurnCostExtension_set_turnCosts_(self, [((id<Directory>) nil_chk(dir)) findWithNSString:@"turn_costs"]);
}

- (jint)nextTurnCostEntryIndex {
  return TurnCostExtension_nextTurnCostEntryIndex(self);
}

- (void)setSegmentSizeWithInt:(jint)bytes {
  [((id<DataAccess>) nil_chk(turnCosts_)) setSegmentSizeWithInt:bytes];
}

- (TurnCostExtension *)createWithLong:(jlong)initBytes {
  [((id<DataAccess>) nil_chk(turnCosts_)) createWithLong:(jlong) initBytes * turnCostsEntryBytes_];
  return self;
}

- (void)flush {
  [((id<DataAccess>) nil_chk(turnCosts_)) setHeaderWithInt:0 withInt:turnCostsEntryBytes_];
  [turnCosts_ setHeaderWithInt:1 * 4 withInt:turnCostsCount_];
  [turnCosts_ flush];
}

- (void)close {
  [((id<DataAccess>) nil_chk(turnCosts_)) close];
}

- (jlong)getCapacity {
  return [((id<DataAccess>) nil_chk(turnCosts_)) getCapacity];
}

- (jboolean)loadExisting {
  if (![((id<DataAccess>) nil_chk(turnCosts_)) loadExisting]) return NO;
  turnCostsEntryBytes_ = [turnCosts_ getHeaderWithInt:0];
  turnCostsCount_ = [turnCosts_ getHeaderWithInt:4];
  return YES;
}

- (void)addTurnInfoWithInt:(jint)fromEdge
                   withInt:(jint)viaNode
                   withInt:(jint)toEdge
                  withLong:(jlong)turnFlags {
  if (turnFlags == TurnCostExtension_EMPTY_FLAGS) return;
  jint newEntryIndex = turnCostsCount_;
  turnCostsCount_++;
  TurnCostExtension_ensureTurnCostIndexWithInt_(self, newEntryIndex);
  jint previousEntryIndex = [((id<NodeAccess>) nil_chk(nodeAccess_)) getAdditionalNodeFieldWithInt:viaNode];
  if (previousEntryIndex == TurnCostExtension_NO_TURN_ENTRY) {
    [nodeAccess_ setAdditionalNodeFieldWithInt:viaNode withInt:newEntryIndex];
  }
  else {
    jint i = 0;
    jint tmp = previousEntryIndex;
    while ((tmp = [((id<DataAccess>) nil_chk(turnCosts_)) getIntWithLong:(jlong) tmp * turnCostsEntryBytes_ + TC_NEXT_]) != TurnCostExtension_NO_TURN_ENTRY) {
      previousEntryIndex = tmp;
      if (i++ > 1000) {
        @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Something unexpected happened. A node probably will not have 1000+ relations."] autorelease];
      }
    }
    [turnCosts_ setIntWithLong:(jlong) previousEntryIndex * turnCostsEntryBytes_ + TC_NEXT_ withInt:newEntryIndex];
  }
  jlong costsBase = (jlong) newEntryIndex * turnCostsEntryBytes_;
  [((id<DataAccess>) nil_chk(turnCosts_)) setIntWithLong:costsBase + TC_FROM_ withInt:fromEdge];
  [turnCosts_ setIntWithLong:costsBase + TC_TO_ withInt:toEdge];
  [turnCosts_ setIntWithLong:costsBase + TC_FLAGS_ withInt:(jint) turnFlags];
  [turnCosts_ setIntWithLong:costsBase + TC_NEXT_ withInt:TurnCostExtension_NO_TURN_ENTRY];
}

- (jlong)getTurnCostFlagsWithInt:(jint)edgeFrom
                         withInt:(jint)nodeVia
                         withInt:(jint)edgeTo {
  if (edgeFrom == EdgeIterator_NO_EDGE || edgeTo == EdgeIterator_NO_EDGE) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"from and to edge cannot be NO_EDGE"] autorelease];
  if (nodeVia < 0) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"via node cannot be negative"] autorelease];
  return TurnCostExtension_nextCostFlagsWithInt_withInt_withInt_(self, edgeFrom, nodeVia, edgeTo);
}

- (jlong)nextCostFlagsWithInt:(jint)edgeFrom
                      withInt:(jint)nodeVia
                      withInt:(jint)edgeTo {
  return TurnCostExtension_nextCostFlagsWithInt_withInt_withInt_(self, edgeFrom, nodeVia, edgeTo);
}

- (void)ensureTurnCostIndexWithInt:(jint)nodeIndex {
  TurnCostExtension_ensureTurnCostIndexWithInt_(self, nodeIndex);
}

- (jboolean)isRequireNodeField {
  return YES;
}

- (jboolean)isRequireEdgeField {
  return NO;
}

- (jint)getDefaultNodeFieldValue {
  return TurnCostExtension_NO_TURN_ENTRY;
}

- (jint)getDefaultEdgeFieldValue {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported by this storage"] autorelease];
}

- (id<GraphExtension>)copyToWithGraphExtension:(id<GraphExtension>)clonedStorage {
  if (!([clonedStorage isKindOfClass:[TurnCostExtension class]])) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"the extended storage to clone must be the same"] autorelease];
  }
  TurnCostExtension *clonedTC = (TurnCostExtension *) check_class_cast(clonedStorage, [TurnCostExtension class]);
  [((id<DataAccess>) nil_chk(turnCosts_)) copyToWithDataAccess:((TurnCostExtension *) nil_chk(clonedTC))->turnCosts_];
  clonedTC->turnCostsCount_ = turnCostsCount_;
  return clonedStorage;
}

- (jboolean)isClosed {
  return [((id<DataAccess>) nil_chk(turnCosts_)) isClosed];
}

- (NSString *)description {
  return @"turn_cost";
}

- (void)dealloc {
  RELEASE_(turnCosts_);
  RELEASE_(nodeAccess_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(TurnCostExtension *)other {
  [super copyAllFieldsTo:other];
  other->TC_FROM_ = TC_FROM_;
  other->TC_TO_ = TC_TO_;
  other->TC_FLAGS_ = TC_FLAGS_;
  other->TC_NEXT_ = TC_NEXT_;
  TurnCostExtension_set_turnCosts_(other, turnCosts_);
  other->turnCostsEntryIndex_ = turnCostsEntryIndex_;
  other->turnCostsEntryBytes_ = turnCostsEntryBytes_;
  other->turnCostsCount_ = turnCostsCount_;
  TurnCostExtension_set_nodeAccess_(other, nodeAccess_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "TurnCostExtension", NULL, 0x1, NULL },
    { "init__WithGraph:withDirectory:", "init", "V", 0x1, NULL },
    { "nextTurnCostEntryIndex", NULL, "I", 0x2, NULL },
    { "setSegmentSizeWithInt:", "setSegmentSize", "V", 0x1, NULL },
    { "createWithLong:", "create", "Lcom.graphhopper.storage.TurnCostExtension;", 0x1, NULL },
    { "flush", NULL, "V", 0x1, NULL },
    { "close", NULL, "V", 0x1, NULL },
    { "getCapacity", NULL, "J", 0x1, NULL },
    { "loadExisting", NULL, "Z", 0x1, NULL },
    { "addTurnInfoWithInt:withInt:withInt:withLong:", "addTurnInfo", "V", 0x1, NULL },
    { "getTurnCostFlagsWithInt:withInt:withInt:", "getTurnCostFlags", "J", 0x1, NULL },
    { "nextCostFlagsWithInt:withInt:withInt:", "nextCostFlags", "J", 0x2, NULL },
    { "ensureTurnCostIndexWithInt:", "ensureTurnCostIndex", "V", 0x2, NULL },
    { "isRequireNodeField", NULL, "Z", 0x1, NULL },
    { "isRequireEdgeField", NULL, "Z", 0x1, NULL },
    { "getDefaultNodeFieldValue", NULL, "I", 0x1, NULL },
    { "getDefaultEdgeFieldValue", NULL, "I", 0x1, NULL },
    { "copyToWithGraphExtension:", "copyTo", "Lcom.graphhopper.storage.GraphExtension;", 0x1, NULL },
    { "isClosed", NULL, "Z", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "NO_TURN_ENTRY_", NULL, 0x1a, "I", NULL, .constantValue.asInt = TurnCostExtension_NO_TURN_ENTRY },
    { "EMPTY_FLAGS_", NULL, 0x1a, "J", NULL, .constantValue.asLong = TurnCostExtension_EMPTY_FLAGS },
    { "TC_FROM_", NULL, 0x12, "I", NULL,  },
    { "TC_TO_", NULL, 0x12, "I", NULL,  },
    { "TC_FLAGS_", NULL, 0x12, "I", NULL,  },
    { "TC_NEXT_", NULL, 0x12, "I", NULL,  },
    { "turnCosts_", NULL, 0x2, "Lcom.graphhopper.storage.DataAccess;", NULL,  },
    { "turnCostsEntryIndex_", NULL, 0x2, "I", NULL,  },
    { "turnCostsEntryBytes_", NULL, 0x2, "I", NULL,  },
    { "turnCostsCount_", NULL, 0x2, "I", NULL,  },
    { "nodeAccess_", NULL, 0x2, "Lcom.graphhopper.storage.NodeAccess;", NULL,  },
  };
  static const J2ObjcClassInfo _TurnCostExtension = { 1, "TurnCostExtension", "com.graphhopper.storage", NULL, 0x1, 20, methods, 11, fields, 0, NULL};
  return &_TurnCostExtension;
}

@end

jint TurnCostExtension_nextTurnCostEntryIndex(TurnCostExtension *self) {
  self->turnCostsEntryIndex_ += 4;
  return self->turnCostsEntryIndex_;
}

jlong TurnCostExtension_nextCostFlagsWithInt_withInt_withInt_(TurnCostExtension *self, jint edgeFrom, jint nodeVia, jint edgeTo) {
  jint turnCostIndex = [((id<NodeAccess>) nil_chk(self->nodeAccess_)) getAdditionalNodeFieldWithInt:nodeVia];
  jint i = 0;
  for (; i < 1000; i++) {
    if (turnCostIndex == TurnCostExtension_NO_TURN_ENTRY) break;
    jlong turnCostPtr = (jlong) turnCostIndex * self->turnCostsEntryBytes_;
    if (edgeFrom == [((id<DataAccess>) nil_chk(self->turnCosts_)) getIntWithLong:turnCostPtr + self->TC_FROM_]) {
      if (edgeTo == [self->turnCosts_ getIntWithLong:turnCostPtr + self->TC_TO_]) return [self->turnCosts_ getIntWithLong:turnCostPtr + self->TC_FLAGS_];
    }
    jint nextTurnCostIndex = [self->turnCosts_ getIntWithLong:turnCostPtr + self->TC_NEXT_];
    if (nextTurnCostIndex == turnCostIndex) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"something went wrong: next entry would be the same"] autorelease];
    turnCostIndex = nextTurnCostIndex;
  }
  if (i > 1000) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"something went wrong: there seems to be no end of the turn cost-list!?"] autorelease];
  return TurnCostExtension_EMPTY_FLAGS;
}

void TurnCostExtension_ensureTurnCostIndexWithInt_(TurnCostExtension *self, jint nodeIndex) {
  [((id<DataAccess>) nil_chk(self->turnCosts_)) ensureCapacityWithLong:((jlong) nodeIndex + 4) * self->turnCostsEntryBytes_];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(TurnCostExtension)
