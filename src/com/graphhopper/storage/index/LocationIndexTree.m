//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/coll/GHBitSet.h"
#include "com/graphhopper/coll/GHTBitSet.h"
#include "com/graphhopper/geohash/SpatialKeyAlgo.h"
#include "com/graphhopper/routing/util/AllEdgesIterator.h"
#include "com/graphhopper/routing/util/EdgeFilter.h"
#include "com/graphhopper/storage/CHGraph.h"
#include "com/graphhopper/storage/DataAccess.h"
#include "com/graphhopper/storage/Directory.h"
#include "com/graphhopper/storage/Graph.h"
#include "com/graphhopper/storage/NodeAccess.h"
#include "com/graphhopper/storage/index/BresenhamLine.h"
#include "com/graphhopper/storage/index/LocationIndex.h"
#include "com/graphhopper/storage/index/LocationIndexTree.h"
#include "com/graphhopper/storage/index/PointEmitter.h"
#include "com/graphhopper/storage/index/QueryResult.h"
#include "com/graphhopper/util/BitUtil.h"
#include "com/graphhopper/util/DistanceCalc.h"
#include "com/graphhopper/util/DistanceCalcEarth.h"
#include "com/graphhopper/util/DistancePlaneProjection.h"
#include "com/graphhopper/util/EdgeExplorer.h"
#include "com/graphhopper/util/EdgeIterator.h"
#include "com/graphhopper/util/EdgeIteratorState.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/PointList.h"
#include "com/graphhopper/util/StopWatch.h"
#include "com/graphhopper/util/shapes/BBox.h"
#include "com/graphhopper/util/shapes/GHPoint.h"
#include "gnu/trove/iterator/TIntIterator.h"
#include "gnu/trove/list/array/TIntArrayList.h"
#include "gnu/trove/set/hash/TIntHashSet.h"
#include "java/lang/Double.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/Collection.h"
#include "java/util/List.h"
#include "org/slf4j/Logger.h"
#include "org/slf4j/LoggerFactory.h"

__attribute__((unused)) static LocationIndexTree *LocationIndexTree_initEntriesWithIntArray_(LocationIndexTree *self, IOSIntArray *entries);
__attribute__((unused)) static jbyte LocationIndexTree_getShiftWithInt_(LocationIndexTree *self, jint entries);
__attribute__((unused)) static jlong LocationIndexTree_getBitmaskWithInt_(LocationIndexTree *self, jint shift);
__attribute__((unused)) static void LocationIndexTree_fillIDsWithLong_withInt_withGnuTroveSetHashTIntHashSet_withInt_(LocationIndexTree *self, jlong keyPart, jint intIndex, GnuTroveSetHashTIntHashSet *set, jint depth);
__attribute__((unused)) static jlong LocationIndexTree_createReverseKeyWithDouble_withDouble_(LocationIndexTree *self, jdouble lat, jdouble lon);
__attribute__((unused)) static jlong LocationIndexTree_createReverseKeyWithLong_(LocationIndexTree *self, jlong key);
__attribute__((unused)) static jdouble LocationIndexTree_calculateRMinWithDouble_withDouble_withInt_(LocationIndexTree *self, jdouble lat, jdouble lon, jint paddingTiles);
__attribute__((unused)) static jboolean LocationIndexTree_findNetworkEntriesWithDouble_withDouble_withGnuTroveSetHashTIntHashSet_withInt_(LocationIndexTree *self, jdouble queryLat, jdouble queryLon, GnuTroveSetHashTIntHashSet *foundEntries, jint iteration);
__attribute__((unused)) static jdouble LocationIndexTree_calcMinDistanceWithDouble_withDouble_withGnuTroveSetHashTIntHashSet_(LocationIndexTree *self, jdouble queryLat, jdouble queryLon, GnuTroveSetHashTIntHashSet *pointset);
__attribute__((unused)) static void LocationIndexTree_findNetworkEntriesSingleRegionWithGnuTroveSetHashTIntHashSet_withDouble_withDouble_(LocationIndexTree *self, GnuTroveSetHashTIntHashSet *storedNetworkEntryIds, jdouble queryLat, jdouble queryLon);

@interface LocationIndexTree () {
 @public
  id<OrgSlf4jLogger> logger_;
  jint MAGIC_INT_;
  id<NodeAccess> nodeAccess_;
  id<DistanceCalc> preciseDistCalc_;
  IOSIntArray *entries_;
  IOSByteArray *shifts_;
  IOSLongArray *bitmasks_;
  jint minResolutionInMeter_;
  jdouble deltaLat_;
  jdouble deltaLon_;
  jint initSizeLeafEntries_;
  jboolean initialized_;
  /**
   @brief If normed distance is smaller than this value the node or edge is 'identical' and the algorithm can stop search.
   */
  jdouble equalNormedDelta_;
}

- (LocationIndexTree *)initEntriesWithIntArray:(IOSIntArray *)entries OBJC_METHOD_FAMILY_NONE;

- (jbyte)getShiftWithInt:(jint)entries;

- (jlong)getBitmaskWithInt:(jint)shift;
@end

J2OBJC_FIELD_SETTER(LocationIndexTree, logger_, id<OrgSlf4jLogger>)
J2OBJC_FIELD_SETTER(LocationIndexTree, nodeAccess_, id<NodeAccess>)
J2OBJC_FIELD_SETTER(LocationIndexTree, preciseDistCalc_, id<DistanceCalc>)
J2OBJC_FIELD_SETTER(LocationIndexTree, entries_, IOSIntArray *)
J2OBJC_FIELD_SETTER(LocationIndexTree, shifts_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LocationIndexTree, bitmasks_, IOSLongArray *)

@interface LocationIndexTree_InMemConstructionIndex () {
 @public
  LocationIndexTree *this$0_;
}
@end

J2OBJC_FIELD_SETTER(LocationIndexTree_InMemConstructionIndex, this$0_, LocationIndexTree *)

@interface LocationIndexTree_InMemConstructionIndex_$1 () {
 @public
  LocationIndexTree_InMemConstructionIndex *this$0_;
  jint val$nodeA_;
}
@end

J2OBJC_FIELD_SETTER(LocationIndexTree_InMemConstructionIndex_$1, this$0_, LocationIndexTree_InMemConstructionIndex *)

@interface LocationIndexTree_$1 () {
 @public
  LocationIndexTree *this$0_;
  jdouble val$queryLat_;
  jdouble val$queryLon_;
  id<GHBitSet> val$checkBitset_;
  id<EdgeFilter> val$edgeFilter_;
  QueryResult *val$closestMatch_;
  id<EdgeExplorer> val$explorer_;
}
@end

J2OBJC_FIELD_SETTER(LocationIndexTree_$1, this$0_, LocationIndexTree *)
J2OBJC_FIELD_SETTER(LocationIndexTree_$1, val$checkBitset_, id<GHBitSet>)
J2OBJC_FIELD_SETTER(LocationIndexTree_$1, val$edgeFilter_, id<EdgeFilter>)
J2OBJC_FIELD_SETTER(LocationIndexTree_$1, val$closestMatch_, QueryResult *)
J2OBJC_FIELD_SETTER(LocationIndexTree_$1, val$explorer_, id<EdgeExplorer>)

@interface LocationIndexTree_XFirstSearchCheck () {
 @public
  LocationIndexTree *this$0_;
}
@end

J2OBJC_FIELD_SETTER(LocationIndexTree_XFirstSearchCheck, this$0_, LocationIndexTree *)

@interface LocationIndexTree_$1_$1 () {
 @public
  LocationIndexTree_$1 *this$1_;
}
@end

J2OBJC_FIELD_SETTER(LocationIndexTree_$1_$1, this$1_, LocationIndexTree_$1 *)

@implementation LocationIndexTree

- (instancetype)initWithGraph:(id<Graph>)g
                withDirectory:(id<Directory>)dir {
  if (self = [super init]) {
    LocationIndexTree_set_logger_(self, OrgSlf4jLoggerFactory_getLoggerWithIOSClass_([self getClass]));
    LocationIndexTree_set_distCalc_(self, Helper_get_DIST_PLANE_());
    maxRegionSearch_ = 4;
    LocationIndexTree_set_preciseDistCalc_(self, Helper_get_DIST_EARTH_());
    minResolutionInMeter_ = 300;
    initSizeLeafEntries_ = 4;
    initialized_ = NO;
    if ([CHGraph_class_() isInstance:g]) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Use base graph for LocationIndexTree instead of CHGraph"] autorelease];
    MAGIC_INT_ = JavaLangInteger_MAX_VALUE / 22316;
    LocationIndexTree_set_graph_(self, g);
    LocationIndexTree_set_nodeAccess_(self, [((id<Graph>) nil_chk(g)) getNodeAccess]);
    LocationIndexTree_set_dataAccess_(self, [((id<Directory>) nil_chk(dir)) findWithNSString:@"location_index"]);
  }
  return self;
}

- (jint)getMinResolutionInMeter {
  return minResolutionInMeter_;
}

- (LocationIndexTree *)setMinResolutionInMeterWithInt:(jint)minResolutionInMeter {
  self->minResolutionInMeter_ = minResolutionInMeter;
  return self;
}

- (LocationIndexTree *)setMaxRegionSearchWithInt:(jint)numTiles {
  if (numTiles < 1) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$I", @"Region of location index must be at least 1 but was ", numTiles)] autorelease];
  if (numTiles % 2 == 1) numTiles++;
  self->maxRegionSearch_ = numTiles;
  return self;
}

- (void)prepareAlgo {
  equalNormedDelta_ = [((id<DistanceCalc>) nil_chk(distCalc_)) calcNormalizedDistWithDouble:0.1];
  BBox *bounds = [((id<Graph>) nil_chk(graph_)) getBounds];
  if ([graph_ getNodes] == 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Cannot create location index of empty graph!"] autorelease];
  if (![((BBox *) nil_chk(bounds)) isValid]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$@", @"Cannot create location index when graph has invalid bounds: ", bounds)] autorelease];
  jdouble lat = JavaLangMath_minWithDouble_withDouble_(JavaLangMath_absWithDouble_(bounds->maxLat_), JavaLangMath_absWithDouble_(bounds->minLat_));
  jdouble maxDistInMeter = JavaLangMath_maxWithDouble_withDouble_((bounds->maxLat_ - bounds->minLat_) / 360 * DistanceCalcEarth_C, (bounds->maxLon_ - bounds->minLon_) / 360 * [((id<DistanceCalc>) nil_chk(preciseDistCalc_)) calcCircumferenceWithDouble:lat]);
  jdouble tmp = maxDistInMeter / minResolutionInMeter_;
  tmp = tmp * tmp;
  GnuTroveListArrayTIntArrayList *tmpEntries = [[[GnuTroveListArrayTIntArrayList alloc] init] autorelease];
  tmp /= 4;
  while (tmp > 1) {
    jint tmpNo;
    if (tmp >= 64) {
      tmpNo = 64;
    }
    else if (tmp >= 16) {
      tmpNo = 16;
    }
    else if (tmp >= 4) {
      tmpNo = 4;
    }
    else {
      break;
    }
    [tmpEntries addWithInt:tmpNo];
    tmp /= tmpNo;
  }
  [tmpEntries addWithInt:4];
  LocationIndexTree_initEntriesWithIntArray_(self, [tmpEntries toArray]);
  jint shiftSum = 0;
  jlong parts = 1;
  for (jint i = 0; i < ((IOSByteArray *) nil_chk(shifts_))->size_; i++) {
    shiftSum += IOSByteArray_Get(shifts_, i);
    parts *= IOSIntArray_Get(nil_chk(entries_), i);
  }
  if (shiftSum > 64) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"sum of all shifts does not fit into a long variable"] autorelease];
  LocationIndexTree_set_keyAlgo_(self, [((SpatialKeyAlgo *) [[[SpatialKeyAlgo alloc] initWithInt:shiftSum] autorelease]) boundsWithBBox:bounds]);
  parts = JavaLangMath_roundWithDouble_(JavaLangMath_sqrtWithDouble_(parts));
  deltaLat_ = (bounds->maxLat_ - bounds->minLat_) / parts;
  deltaLon_ = (bounds->maxLon_ - bounds->minLon_) / parts;
}

- (LocationIndexTree *)initEntriesWithIntArray:(IOSIntArray *)entries {
  return LocationIndexTree_initEntriesWithIntArray_(self, entries);
}

- (jbyte)getShiftWithInt:(jint)entries {
  return LocationIndexTree_getShiftWithInt_(self, entries);
}

- (jlong)getBitmaskWithInt:(jint)shift {
  return LocationIndexTree_getBitmaskWithInt_(self, shift);
}

- (LocationIndexTree_InMemConstructionIndex *)getPrepareInMemIndex {
  LocationIndexTree_InMemConstructionIndex *memIndex = [[[LocationIndexTree_InMemConstructionIndex alloc] initWithLocationIndexTree:self withInt:IOSIntArray_Get(nil_chk(entries_), 0)] autorelease];
  [memIndex prepare];
  return memIndex;
}

- (jint)findIDWithDouble:(jdouble)lat
              withDouble:(jdouble)lon {
  QueryResult *res = [self findClosestWithDouble:lat withDouble:lon withEdgeFilter:EdgeFilter_get_ALL_EDGES_()];
  if (![((QueryResult *) nil_chk(res)) isValid]) return -1;
  return [res getClosestNode];
}

- (id<LocationIndex>)setResolutionWithInt:(jint)minResolutionInMeter {
  if (minResolutionInMeter <= 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Negative precision is not allowed!"] autorelease];
  [self setMinResolutionInMeterWithInt:minResolutionInMeter];
  return self;
}

- (id<LocationIndex>)setApproximationWithBoolean:(jboolean)approx {
  if (approx) LocationIndexTree_set_distCalc_(self, Helper_get_DIST_PLANE_());
  else LocationIndexTree_set_distCalc_(self, Helper_get_DIST_EARTH_());
  return self;
}

- (LocationIndexTree *)createWithLong:(jlong)size {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Use prepareIndex instead."] autorelease];
}

- (jboolean)loadExisting {
  if (initialized_) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Call loadExisting only once"] autorelease];
  if (![((id<DataAccess>) nil_chk(dataAccess_)) loadExisting]) return NO;
  if ([dataAccess_ getHeaderWithInt:0] != MAGIC_INT_) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I", @"incorrect location index version, expected:", MAGIC_INT_)] autorelease];
  if ([dataAccess_ getHeaderWithInt:1 * 4] != [self calcChecksum]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$I", @"location index was opened with incorrect graph: ", [dataAccess_ getHeaderWithInt:1 * 4], @" vs. ", [self calcChecksum])] autorelease];
  [self setMinResolutionInMeterWithInt:[dataAccess_ getHeaderWithInt:2 * 4]];
  [self prepareAlgo];
  initialized_ = YES;
  return YES;
}

- (void)flush {
  [((id<DataAccess>) nil_chk(dataAccess_)) setHeaderWithInt:0 withInt:MAGIC_INT_];
  [dataAccess_ setHeaderWithInt:1 * 4 withInt:[self calcChecksum]];
  [dataAccess_ setHeaderWithInt:2 * 4 withInt:minResolutionInMeter_];
  [dataAccess_ flush];
}

- (id<LocationIndex>)prepareIndex {
  if (initialized_) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Call prepareIndex only once"] autorelease];
  StopWatch *sw = [((StopWatch *) [[[StopWatch alloc] init] autorelease]) start];
  [self prepareAlgo];
  LocationIndexTree_InMemConstructionIndex *inMem = [self getPrepareInMemIndex];
  [((id<DataAccess>) nil_chk(dataAccess_)) createWithLong:64 * 1024];
  @try {
    [inMem storeWithLocationIndexTree_InMemEntry:((LocationIndexTree_InMemConstructionIndex *) nil_chk(inMem))->root_ withInt:LocationIndexTree_START_POINTER];
    [self flush];
  }
  @catch (JavaLangException *ex) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$$", @"Problem while storing location index. ", Helper_getMemInfo()) withJavaLangThrowable:ex] autorelease];
  }
  jfloat entriesPerLeaf = (jfloat) ((LocationIndexTree_InMemConstructionIndex *) nil_chk(inMem))->size_ / inMem->leafs_;
  initialized_ = YES;
  [((id<OrgSlf4jLogger>) nil_chk(logger_)) infoWithNSString:JreStrcat("$F$$$$$I$I$I$$$F", @"location index created in ", [((StopWatch *) nil_chk([((StopWatch *) nil_chk(sw)) stop])) getSeconds], @"s, size:", Helper_nfWithLong_(inMem->size_), @", leafs:", Helper_nfWithLong_(inMem->leafs_), @", precision:", minResolutionInMeter_, @", depth:", ((IOSIntArray *) nil_chk(entries_))->size_, @", checksum:", [self calcChecksum], @", entries:", JavaUtilArrays_toStringWithIntArray_(entries_), @", entriesPerLeaf:", entriesPerLeaf)];
  return self;
}

- (jint)calcChecksum {
  return [((id<Graph>) nil_chk(graph_)) getNodes];
}

- (void)close {
  [((id<DataAccess>) nil_chk(dataAccess_)) close];
}

- (jboolean)isClosed {
  return [((id<DataAccess>) nil_chk(dataAccess_)) isClosed];
}

- (jlong)getCapacity {
  return [((id<DataAccess>) nil_chk(dataAccess_)) getCapacity];
}

- (void)setSegmentSizeWithInt:(jint)bytes {
  [((id<DataAccess>) nil_chk(dataAccess_)) setSegmentSizeWithInt:bytes];
}

- (GnuTroveListArrayTIntArrayList *)getEntries {
  return [[[GnuTroveListArrayTIntArrayList alloc] initWithIntArray:entries_] autorelease];
}

- (void)fillIDsWithLong:(jlong)keyPart
                withInt:(jint)intIndex
withGnuTroveSetHashTIntHashSet:(GnuTroveSetHashTIntHashSet *)set
                withInt:(jint)depth {
  LocationIndexTree_fillIDsWithLong_withInt_withGnuTroveSetHashTIntHashSet_withInt_(self, keyPart, intIndex, set, depth);
}

- (jlong)createReverseKeyWithDouble:(jdouble)lat
                         withDouble:(jdouble)lon {
  return LocationIndexTree_createReverseKeyWithDouble_withDouble_(self, lat, lon);
}

- (jlong)createReverseKeyWithLong:(jlong)key {
  return LocationIndexTree_createReverseKeyWithLong_(self, key);
}

- (jdouble)calculateRMinWithDouble:(jdouble)lat
                        withDouble:(jdouble)lon {
  return LocationIndexTree_calculateRMinWithDouble_withDouble_withInt_(self, lat, lon, 0);
}

- (jdouble)calculateRMinWithDouble:(jdouble)lat
                        withDouble:(jdouble)lon
                           withInt:(jint)paddingTiles {
  return LocationIndexTree_calculateRMinWithDouble_withDouble_withInt_(self, lat, lon, paddingTiles);
}

- (jdouble)getDeltaLat {
  return deltaLat_;
}

- (jdouble)getDeltaLon {
  return deltaLon_;
}

- (GHPoint *)getCenterWithDouble:(jdouble)lat
                      withDouble:(jdouble)lon {
  GHPoint *query = [[[GHPoint alloc] initWithDouble:lat withDouble:lon] autorelease];
  jlong key = [((SpatialKeyAlgo *) nil_chk(keyAlgo_)) encodeWithGHPoint:query];
  GHPoint *center = [[[GHPoint alloc] init] autorelease];
  [keyAlgo_ decodeWithLong:key withGHPoint:center];
  return center;
}

- (jboolean)findNetworkEntriesWithDouble:(jdouble)queryLat
                              withDouble:(jdouble)queryLon
          withGnuTroveSetHashTIntHashSet:(GnuTroveSetHashTIntHashSet *)foundEntries
                                 withInt:(jint)iteration {
  return LocationIndexTree_findNetworkEntriesWithDouble_withDouble_withGnuTroveSetHashTIntHashSet_withInt_(self, queryLat, queryLon, foundEntries, iteration);
}

- (jdouble)calcMinDistanceWithDouble:(jdouble)queryLat
                          withDouble:(jdouble)queryLon
      withGnuTroveSetHashTIntHashSet:(GnuTroveSetHashTIntHashSet *)pointset {
  return LocationIndexTree_calcMinDistanceWithDouble_withDouble_withGnuTroveSetHashTIntHashSet_(self, queryLat, queryLon, pointset);
}

- (void)findNetworkEntriesSingleRegionWithGnuTroveSetHashTIntHashSet:(GnuTroveSetHashTIntHashSet *)storedNetworkEntryIds
                                                          withDouble:(jdouble)queryLat
                                                          withDouble:(jdouble)queryLon {
  LocationIndexTree_findNetworkEntriesSingleRegionWithGnuTroveSetHashTIntHashSet_withDouble_withDouble_(self, storedNetworkEntryIds, queryLat, queryLon);
}

- (QueryResult *)findClosestWithDouble:(jdouble)queryLat
                            withDouble:(jdouble)queryLon
                        withEdgeFilter:(id<EdgeFilter>)edgeFilter {
  if ([self isClosed]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"You need to create a new LocationIndex instance as it is already closed"] autorelease];
  GnuTroveSetHashTIntHashSet *allCollectedEntryIds = [[[GnuTroveSetHashTIntHashSet alloc] init] autorelease];
  QueryResult *closestMatch = [[[QueryResult alloc] initWithDouble:queryLat withDouble:queryLon] autorelease];
  for (jint iteration = 0; iteration < maxRegionSearch_; iteration++) {
    GnuTroveSetHashTIntHashSet *storedNetworkEntryIds = [[[GnuTroveSetHashTIntHashSet alloc] init] autorelease];
    jboolean earlyFinish = LocationIndexTree_findNetworkEntriesWithDouble_withDouble_withGnuTroveSetHashTIntHashSet_withInt_(self, queryLat, queryLon, storedNetworkEntryIds, iteration);
    [storedNetworkEntryIds removeAllWithGnuTroveTIntCollection:allCollectedEntryIds];
    [allCollectedEntryIds addAllWithGnuTroveTIntCollection:storedNetworkEntryIds];
    id<GHBitSet> checkBitset = [[[GHTBitSet alloc] initWithGnuTroveSetHashTIntHashSet:[[[GnuTroveSetHashTIntHashSet alloc] initWithGnuTroveTIntCollection:storedNetworkEntryIds] autorelease]] autorelease];
    id<EdgeExplorer> explorer = [((id<Graph>) nil_chk(graph_)) createEdgeExplorer];
    [storedNetworkEntryIds forEachWithGnuTroveProcedureTIntProcedure:[[[LocationIndexTree_$1 alloc] initWithLocationIndexTree:self withDouble:queryLat withDouble:queryLon withGHBitSet:checkBitset withEdgeFilter:edgeFilter withQueryResult:closestMatch withEdgeExplorer:explorer] autorelease]];
    if (earlyFinish && [closestMatch isValid]) break;
  }
  if ([closestMatch isValid]) {
    [closestMatch setQueryDistanceWithDouble:[((id<DistanceCalc>) nil_chk(distCalc_)) calcDenormalizedDistWithDouble:[closestMatch getQueryDistance]]];
    [closestMatch calcSnappedPointWithDistanceCalc:distCalc_];
  }
  return closestMatch;
}

- (void)dealloc {
  RELEASE_(graph_);
  RELEASE_(dataAccess_);
  RELEASE_(logger_);
  RELEASE_(nodeAccess_);
  RELEASE_(distCalc_);
  RELEASE_(keyAlgo_);
  RELEASE_(preciseDistCalc_);
  RELEASE_(entries_);
  RELEASE_(shifts_);
  RELEASE_(bitmasks_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(LocationIndexTree *)other {
  [super copyAllFieldsTo:other];
  LocationIndexTree_set_graph_(other, graph_);
  LocationIndexTree_set_dataAccess_(other, dataAccess_);
  LocationIndexTree_set_logger_(other, logger_);
  other->MAGIC_INT_ = MAGIC_INT_;
  LocationIndexTree_set_nodeAccess_(other, nodeAccess_);
  LocationIndexTree_set_distCalc_(other, distCalc_);
  LocationIndexTree_set_keyAlgo_(other, keyAlgo_);
  other->maxRegionSearch_ = maxRegionSearch_;
  LocationIndexTree_set_preciseDistCalc_(other, preciseDistCalc_);
  LocationIndexTree_set_entries_(other, entries_);
  LocationIndexTree_set_shifts_(other, shifts_);
  LocationIndexTree_set_bitmasks_(other, bitmasks_);
  other->minResolutionInMeter_ = minResolutionInMeter_;
  other->deltaLat_ = deltaLat_;
  other->deltaLon_ = deltaLon_;
  other->initSizeLeafEntries_ = initSizeLeafEntries_;
  other->initialized_ = initialized_;
  other->equalNormedDelta_ = equalNormedDelta_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGraph:withDirectory:", "LocationIndexTree", NULL, 0x1, NULL },
    { "getMinResolutionInMeter", NULL, "I", 0x1, NULL },
    { "setMinResolutionInMeterWithInt:", "setMinResolutionInMeter", "Lcom.graphhopper.storage.index.LocationIndexTree;", 0x1, NULL },
    { "setMaxRegionSearchWithInt:", "setMaxRegionSearch", "Lcom.graphhopper.storage.index.LocationIndexTree;", 0x1, NULL },
    { "prepareAlgo", NULL, "V", 0x0, NULL },
    { "initEntriesWithIntArray:", "initEntries", "Lcom.graphhopper.storage.index.LocationIndexTree;", 0x2, NULL },
    { "getShiftWithInt:", "getShift", "B", 0x2, NULL },
    { "getBitmaskWithInt:", "getBitmask", "J", 0x2, NULL },
    { "getPrepareInMemIndex", NULL, "Lcom.graphhopper.storage.index.LocationIndexTree$InMemConstructionIndex;", 0x0, NULL },
    { "findIDWithDouble:withDouble:", "findID", "I", 0x1, NULL },
    { "setResolutionWithInt:", "setResolution", "Lcom.graphhopper.storage.index.LocationIndex;", 0x1, NULL },
    { "setApproximationWithBoolean:", "setApproximation", "Lcom.graphhopper.storage.index.LocationIndex;", 0x1, NULL },
    { "createWithLong:", "create", "Lcom.graphhopper.storage.index.LocationIndexTree;", 0x1, NULL },
    { "loadExisting", NULL, "Z", 0x1, NULL },
    { "flush", NULL, "V", 0x1, NULL },
    { "prepareIndex", NULL, "Lcom.graphhopper.storage.index.LocationIndex;", 0x1, NULL },
    { "calcChecksum", NULL, "I", 0x0, NULL },
    { "close", NULL, "V", 0x1, NULL },
    { "isClosed", NULL, "Z", 0x1, NULL },
    { "getCapacity", NULL, "J", 0x1, NULL },
    { "setSegmentSizeWithInt:", "setSegmentSize", "V", 0x1, NULL },
    { "getEntries", NULL, "Lgnu.trove.list.array.TIntArrayList;", 0x0, NULL },
    { "fillIDsWithLong:withInt:withGnuTroveSetHashTIntHashSet:withInt:", "fillIDs", "V", 0x10, NULL },
    { "createReverseKeyWithDouble:withDouble:", "createReverseKey", "J", 0x10, NULL },
    { "createReverseKeyWithLong:", "createReverseKey", "J", 0x10, NULL },
    { "calculateRMinWithDouble:withDouble:", "calculateRMin", "D", 0x10, NULL },
    { "calculateRMinWithDouble:withDouble:withInt:", "calculateRMin", "D", 0x10, NULL },
    { "getDeltaLat", NULL, "D", 0x0, NULL },
    { "getDeltaLon", NULL, "D", 0x0, NULL },
    { "getCenterWithDouble:withDouble:", "getCenter", "Lcom.graphhopper.util.shapes.GHPoint;", 0x0, NULL },
    { "findNetworkEntriesWithDouble:withDouble:withGnuTroveSetHashTIntHashSet:withInt:", "findNetworkEntries", "Z", 0x11, NULL },
    { "calcMinDistanceWithDouble:withDouble:withGnuTroveSetHashTIntHashSet:", "calcMinDistance", "D", 0x10, NULL },
    { "findNetworkEntriesSingleRegionWithGnuTroveSetHashTIntHashSet:withDouble:withDouble:", "findNetworkEntriesSingleRegion", "V", 0x10, NULL },
    { "findClosestWithDouble:withDouble:withEdgeFilter:", "findClosest", "Lcom.graphhopper.storage.index.QueryResult;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "START_POINTER_", NULL, 0x18, "I", NULL, .constantValue.asInt = LocationIndexTree_START_POINTER },
    { "graph_", NULL, 0x14, "Lcom.graphhopper.storage.Graph;", NULL,  },
    { "dataAccess_", NULL, 0x10, "Lcom.graphhopper.storage.DataAccess;", NULL,  },
    { "logger_", NULL, 0x12, "Lorg.slf4j.Logger;", NULL,  },
    { "MAGIC_INT_", NULL, 0x12, "I", NULL,  },
    { "nodeAccess_", NULL, 0x12, "Lcom.graphhopper.storage.NodeAccess;", NULL,  },
    { "distCalc_", NULL, 0x4, "Lcom.graphhopper.util.DistanceCalc;", NULL,  },
    { "keyAlgo_", NULL, 0x4, "Lcom.graphhopper.geohash.SpatialKeyAlgo;", NULL,  },
    { "maxRegionSearch_", NULL, 0x0, "I", NULL,  },
    { "preciseDistCalc_", NULL, 0x2, "Lcom.graphhopper.util.DistanceCalc;", NULL,  },
    { "entries_", NULL, 0x2, "[I", NULL,  },
    { "shifts_", NULL, 0x2, "[B", NULL,  },
    { "bitmasks_", NULL, 0x2, "[J", NULL,  },
    { "minResolutionInMeter_", NULL, 0x2, "I", NULL,  },
    { "deltaLat_", NULL, 0x2, "D", NULL,  },
    { "deltaLon_", NULL, 0x2, "D", NULL,  },
    { "initSizeLeafEntries_", NULL, 0x2, "I", NULL,  },
    { "initialized_", NULL, 0x2, "Z", NULL,  },
    { "equalNormedDelta_", NULL, 0x2, "D", NULL,  },
  };
  static const J2ObjcClassInfo _LocationIndexTree = { 1, "LocationIndexTree", "com.graphhopper.storage.index", NULL, 0x1, 34, methods, 19, fields, 0, NULL};
  return &_LocationIndexTree;
}

@end

LocationIndexTree *LocationIndexTree_initEntriesWithIntArray_(LocationIndexTree *self, IOSIntArray *entries) {
  if (((IOSIntArray *) nil_chk(entries))->size_ < 1) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"depth needs to be at least 1"] autorelease];
  }
  LocationIndexTree_set_entries_(self, entries);
  jint depth = entries->size_;
  LocationIndexTree_setAndConsume_shifts_(self, [IOSByteArray newArrayWithLength:depth]);
  LocationIndexTree_setAndConsume_bitmasks_(self, [IOSLongArray newArrayWithLength:depth]);
  jint lastEntry = IOSIntArray_Get(entries, 0);
  for (jint i = 0; i < depth; i++) {
    if (lastEntry < IOSIntArray_Get(entries, i)) {
      @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$$", @"entries should decrease or stay but was:", JavaUtilArrays_toStringWithIntArray_(entries))] autorelease];
    }
    lastEntry = IOSIntArray_Get(entries, i);
    *IOSByteArray_GetRef(self->shifts_, i) = LocationIndexTree_getShiftWithInt_(self, IOSIntArray_Get(entries, i));
    *IOSLongArray_GetRef(self->bitmasks_, i) = LocationIndexTree_getBitmaskWithInt_(self, IOSByteArray_Get(self->shifts_, i));
  }
  return self;
}

jbyte LocationIndexTree_getShiftWithInt_(LocationIndexTree *self, jint entries) {
  jbyte b = (jbyte) JavaLangMath_roundWithDouble_(JavaLangMath_logWithDouble_(entries) / JavaLangMath_logWithDouble_(2));
  if (b <= 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$B", @"invalid shift:", b)] autorelease];
  return b;
}

jlong LocationIndexTree_getBitmaskWithInt_(LocationIndexTree *self, jint shift) {
  jlong bm = (LShift64(1LL, shift)) - 1;
  if (bm <= 0) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$J", @"invalid bitmask:", bm)] autorelease];
  }
  return bm;
}

void LocationIndexTree_fillIDsWithLong_withInt_withGnuTroveSetHashTIntHashSet_withInt_(LocationIndexTree *self, jlong keyPart, jint intIndex, GnuTroveSetHashTIntHashSet *set, jint depth) {
  jlong pointer = LShift64((jlong) intIndex, 2);
  if (depth == ((IOSIntArray *) nil_chk(self->entries_))->size_) {
    jint value = [((id<DataAccess>) nil_chk(self->dataAccess_)) getIntWithLong:pointer];
    if (value < 0) {
      [((GnuTroveSetHashTIntHashSet *) nil_chk(set)) addWithInt:-(value + 1)];
    }
    else {
      jlong max = (jlong) value * 4;
      for (jlong leafIndex = pointer + 4; leafIndex < max; leafIndex += 4) {
        [((GnuTroveSetHashTIntHashSet *) nil_chk(set)) addWithInt:[self->dataAccess_ getIntWithLong:leafIndex]];
      }
    }
    return;
  }
  jint offset = LShift32((jint) (IOSLongArray_Get(nil_chk(self->bitmasks_), depth) & keyPart), 2);
  jint value = [((id<DataAccess>) nil_chk(self->dataAccess_)) getIntWithLong:pointer + offset];
  if (value > 0) {
    LocationIndexTree_fillIDsWithLong_withInt_withGnuTroveSetHashTIntHashSet_withInt_(self, URShift64(keyPart, IOSByteArray_Get(nil_chk(self->shifts_), depth)), value, set, depth + 1);
  }
}

jlong LocationIndexTree_createReverseKeyWithDouble_withDouble_(LocationIndexTree *self, jdouble lat, jdouble lon) {
  return [((BitUtil *) nil_chk(BitUtil_get_BIG_())) reverseWithLong:[((SpatialKeyAlgo *) nil_chk(self->keyAlgo_)) encodeWithDouble:lat withDouble:lon] withInt:[self->keyAlgo_ getBits]];
}

jlong LocationIndexTree_createReverseKeyWithLong_(LocationIndexTree *self, jlong key) {
  return [((BitUtil *) nil_chk(BitUtil_get_BIG_())) reverseWithLong:key withInt:[((SpatialKeyAlgo *) nil_chk(self->keyAlgo_)) getBits]];
}

jdouble LocationIndexTree_calculateRMinWithDouble_withDouble_withInt_(LocationIndexTree *self, jdouble lat, jdouble lon, jint paddingTiles) {
  GHPoint *query = [[[GHPoint alloc] initWithDouble:lat withDouble:lon] autorelease];
  jlong key = [((SpatialKeyAlgo *) nil_chk(self->keyAlgo_)) encodeWithGHPoint:query];
  GHPoint *center = [[[GHPoint alloc] init] autorelease];
  [self->keyAlgo_ decodeWithLong:key withGHPoint:center];
  jdouble minLat = center->lat_ - (0.5 + paddingTiles) * self->deltaLat_;
  jdouble maxLat = center->lat_ + (0.5 + paddingTiles) * self->deltaLat_;
  jdouble minLon = center->lon_ - (0.5 + paddingTiles) * self->deltaLon_;
  jdouble maxLon = center->lon_ + (0.5 + paddingTiles) * self->deltaLon_;
  jdouble dSouthernLat = query->lat_ - minLat;
  jdouble dNorthernLat = maxLat - query->lat_;
  jdouble dWesternLon = query->lon_ - minLon;
  jdouble dEasternLon = maxLon - query->lon_;
  jdouble dMinLat, dMinLon;
  if (dSouthernLat < dNorthernLat) {
    dMinLat = [((id<DistanceCalc>) nil_chk(self->distCalc_)) calcDistWithDouble:query->lat_ withDouble:query->lon_ withDouble:minLat withDouble:query->lon_];
  }
  else {
    dMinLat = [((id<DistanceCalc>) nil_chk(self->distCalc_)) calcDistWithDouble:query->lat_ withDouble:query->lon_ withDouble:maxLat withDouble:query->lon_];
  }
  if (dWesternLon < dEasternLon) {
    dMinLon = [((id<DistanceCalc>) nil_chk(self->distCalc_)) calcDistWithDouble:query->lat_ withDouble:query->lon_ withDouble:query->lat_ withDouble:minLon];
  }
  else {
    dMinLon = [((id<DistanceCalc>) nil_chk(self->distCalc_)) calcDistWithDouble:query->lat_ withDouble:query->lon_ withDouble:query->lat_ withDouble:maxLon];
  }
  jdouble rMin = JavaLangMath_minWithDouble_withDouble_(dMinLat, dMinLon);
  return rMin;
}

jboolean LocationIndexTree_findNetworkEntriesWithDouble_withDouble_withGnuTroveSetHashTIntHashSet_withInt_(LocationIndexTree *self, jdouble queryLat, jdouble queryLon, GnuTroveSetHashTIntHashSet *foundEntries, jint iteration) {
  for (jint yreg = -iteration; yreg <= iteration; yreg++) {
    jdouble subqueryLat = queryLat + yreg * self->deltaLat_;
    jdouble subqueryLonA = queryLon - iteration * self->deltaLon_;
    jdouble subqueryLonB = queryLon + iteration * self->deltaLon_;
    LocationIndexTree_findNetworkEntriesSingleRegionWithGnuTroveSetHashTIntHashSet_withDouble_withDouble_(self, foundEntries, subqueryLat, subqueryLonA);
    if (iteration > 0) LocationIndexTree_findNetworkEntriesSingleRegionWithGnuTroveSetHashTIntHashSet_withDouble_withDouble_(self, foundEntries, subqueryLat, subqueryLonB);
  }
  for (jint xreg = -iteration + 1; xreg <= iteration - 1; xreg++) {
    jdouble subqueryLon = queryLon + xreg * self->deltaLon_;
    jdouble subqueryLatA = queryLat - iteration * self->deltaLat_;
    jdouble subqueryLatB = queryLat + iteration * self->deltaLat_;
    LocationIndexTree_findNetworkEntriesSingleRegionWithGnuTroveSetHashTIntHashSet_withDouble_withDouble_(self, foundEntries, subqueryLatA, subqueryLon);
    LocationIndexTree_findNetworkEntriesSingleRegionWithGnuTroveSetHashTIntHashSet_withDouble_withDouble_(self, foundEntries, subqueryLatB, subqueryLon);
  }
  if (iteration % 2 != 0) {
    if (![((GnuTroveSetHashTIntHashSet *) nil_chk(foundEntries)) isEmpty]) {
      jdouble rMin = LocationIndexTree_calculateRMinWithDouble_withDouble_withInt_(self, queryLat, queryLon, iteration);
      jdouble minDistance = LocationIndexTree_calcMinDistanceWithDouble_withDouble_withGnuTroveSetHashTIntHashSet_(self, queryLat, queryLon, foundEntries);
      if (minDistance < rMin) return YES;
    }
  }
  return NO;
}

jdouble LocationIndexTree_calcMinDistanceWithDouble_withDouble_withGnuTroveSetHashTIntHashSet_(LocationIndexTree *self, jdouble queryLat, jdouble queryLon, GnuTroveSetHashTIntHashSet *pointset) {
  jdouble min = JavaLangDouble_MAX_VALUE;
  id<GnuTroveIteratorTIntIterator> itr = [((GnuTroveSetHashTIntHashSet *) nil_chk(pointset)) iterator];
  while ([((id<GnuTroveIteratorTIntIterator>) nil_chk(itr)) hasNext]) {
    jint node = [itr next];
    jdouble lat = [((id<NodeAccess>) nil_chk(self->nodeAccess_)) getLatWithInt:node];
    jdouble lon = [self->nodeAccess_ getLonWithInt:node];
    jdouble dist = [((id<DistanceCalc>) nil_chk(self->distCalc_)) calcDistWithDouble:queryLat withDouble:queryLon withDouble:lat withDouble:lon];
    if (dist < min) {
      min = dist;
    }
  }
  return min;
}

void LocationIndexTree_findNetworkEntriesSingleRegionWithGnuTroveSetHashTIntHashSet_withDouble_withDouble_(LocationIndexTree *self, GnuTroveSetHashTIntHashSet *storedNetworkEntryIds, jdouble queryLat, jdouble queryLon) {
  jlong keyPart = LocationIndexTree_createReverseKeyWithDouble_withDouble_(self, queryLat, queryLon);
  LocationIndexTree_fillIDsWithLong_withInt_withGnuTroveSetHashTIntHashSet_withInt_(self, keyPart, LocationIndexTree_START_POINTER, storedNetworkEntryIds, 0);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LocationIndexTree)

@implementation LocationIndexTree_SortedIntSet

- (instancetype)init {
  return [super init];
}

- (instancetype)initWithInt:(jint)capacity {
  return [super initWithInt:capacity];
}

- (jboolean)addOnceWithInt:(jint)value {
  jint foundIndex = [self binarySearchWithInt:value];
  if (foundIndex >= 0) {
    return NO;
  }
  foundIndex = -foundIndex - 1;
  [self insertWithInt:foundIndex withInt:value];
  return YES;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "SortedIntSet", NULL, 0x1, NULL },
    { "initWithInt:", "SortedIntSet", NULL, 0x1, NULL },
    { "addOnceWithInt:", "addOnce", "Z", 0x1, NULL },
  };
  static const J2ObjcClassInfo _LocationIndexTree_SortedIntSet = { 1, "SortedIntSet", "com.graphhopper.storage.index", "LocationIndexTree", 0x8, 3, methods, 0, NULL, 0, NULL};
  return &_LocationIndexTree_SortedIntSet;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LocationIndexTree_SortedIntSet)

@interface LocationIndexTree_InMemEntry : NSObject
@end

@implementation LocationIndexTree_InMemEntry

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "isLeaf", NULL, "Z", 0x401, NULL },
  };
  static const J2ObjcClassInfo _LocationIndexTree_InMemEntry = { 1, "InMemEntry", "com.graphhopper.storage.index", "LocationIndexTree", 0x200, 1, methods, 0, NULL, 0, NULL};
  return &_LocationIndexTree_InMemEntry;
}

@end

J2OBJC_INTERFACE_TYPE_LITERAL_SOURCE(LocationIndexTree_InMemEntry)

@implementation LocationIndexTree_InMemLeafEntry

- (instancetype)initWithInt:(jint)count
                   withLong:(jlong)key {
  return [super initWithInt:count];
}

- (jboolean)addNodeWithInt:(jint)nodeId {
  return [self addOnceWithInt:nodeId];
}

- (jboolean)isLeaf {
  return YES;
}

- (NSString *)description {
  return JreStrcat("$$", @"LEAF  ", [super description]);
}

- (GnuTroveListArrayTIntArrayList *)getResults {
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithInt:withLong:", "InMemLeafEntry", NULL, 0x1, NULL },
    { "addNodeWithInt:", "addNode", "Z", 0x1, NULL },
    { "isLeaf", NULL, "Z", 0x11, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "getResults", NULL, "Lgnu.trove.list.array.TIntArrayList;", 0x0, NULL },
  };
  static const J2ObjcClassInfo _LocationIndexTree_InMemLeafEntry = { 1, "InMemLeafEntry", "com.graphhopper.storage.index", "LocationIndexTree", 0x8, 5, methods, 0, NULL, 0, NULL};
  return &_LocationIndexTree_InMemLeafEntry;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LocationIndexTree_InMemLeafEntry)

@implementation LocationIndexTree_InMemTreeEntry

- (instancetype)initWithInt:(jint)subEntryNo {
  if (self = [super init]) {
    LocationIndexTree_InMemTreeEntry_setAndConsume_subEntries_(self, [IOSObjectArray newArrayWithLength:subEntryNo type:LocationIndexTree_InMemEntry_class_()]);
  }
  return self;
}

- (id<LocationIndexTree_InMemEntry>)getSubEntryWithInt:(jint)index {
  return IOSObjectArray_Get(nil_chk(subEntries_), index);
}

- (void)setSubEntryWithInt:(jint)index
withLocationIndexTree_InMemEntry:(id<LocationIndexTree_InMemEntry>)subEntry {
  IOSObjectArray_Set(nil_chk(self->subEntries_), index, subEntry);
}

- (id<JavaUtilCollection>)getSubEntriesForDebug {
  id<JavaUtilList> list = [[[JavaUtilArrayList alloc] init] autorelease];
  {
    IOSObjectArray *a__ = subEntries_;
    id<LocationIndexTree_InMemEntry> const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    id<LocationIndexTree_InMemEntry> const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      id<LocationIndexTree_InMemEntry> e = *b__++;
      if (e != nil) {
        [list addWithId:e];
      }
    }
  }
  return list;
}

- (jboolean)isLeaf {
  return NO;
}

- (NSString *)description {
  return @"TREE";
}

- (void)dealloc {
  RELEASE_(subEntries_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(LocationIndexTree_InMemTreeEntry *)other {
  [super copyAllFieldsTo:other];
  LocationIndexTree_InMemTreeEntry_set_subEntries_(other, subEntries_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithInt:", "InMemTreeEntry", NULL, 0x1, NULL },
    { "getSubEntryWithInt:", "getSubEntry", "Lcom.graphhopper.storage.index.LocationIndexTree$InMemEntry;", 0x1, NULL },
    { "setSubEntryWithInt:withLocationIndexTree_InMemEntry:", "setSubEntry", "V", 0x1, NULL },
    { "getSubEntriesForDebug", NULL, "Ljava.util.Collection;", 0x1, NULL },
    { "isLeaf", NULL, "Z", 0x11, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "subEntries_", NULL, 0x0, "[Lcom.graphhopper.storage.index.LocationIndexTree$InMemEntry;", NULL,  },
  };
  static const J2ObjcClassInfo _LocationIndexTree_InMemTreeEntry = { 1, "InMemTreeEntry", "com.graphhopper.storage.index", "LocationIndexTree", 0x8, 6, methods, 1, fields, 0, NULL};
  return &_LocationIndexTree_InMemTreeEntry;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LocationIndexTree_InMemTreeEntry)

@implementation LocationIndexTree_InMemConstructionIndex

- (instancetype)initWithLocationIndexTree:(LocationIndexTree *)outer$
                                  withInt:(jint)noOfSubEntries {
  LocationIndexTree_InMemConstructionIndex_set_this$0_(self, outer$);
  if (self = [super init]) {
    LocationIndexTree_InMemConstructionIndex_setAndConsume_root_(self, [[LocationIndexTree_InMemTreeEntry alloc] initWithInt:noOfSubEntries]);
  }
  return self;
}

- (void)prepare {
  id<EdgeIterator> allIter = [((id<Graph>) nil_chk(this$0_->graph_)) getAllEdges];
  @try {
    while ([((id<EdgeIterator>) nil_chk(allIter)) next]) {
      jint nodeA = [allIter getBaseNode];
      jint nodeB = [allIter getAdjNode];
      jdouble lat1 = [((id<NodeAccess>) nil_chk(this$0_->nodeAccess_)) getLatitudeWithInt:nodeA];
      jdouble lon1 = [this$0_->nodeAccess_ getLongitudeWithInt:nodeA];
      jdouble lat2;
      jdouble lon2;
      PointList *points = [allIter fetchWayGeometryWithInt:0];
      jint len = [((PointList *) nil_chk(points)) getSize];
      for (jint i = 0; i < len; i++) {
        lat2 = [points getLatitudeWithInt:i];
        lon2 = [points getLongitudeWithInt:i];
        [self addNodeWithInt:nodeA withInt:nodeB withDouble:lat1 withDouble:lon1 withDouble:lat2 withDouble:lon2];
        lat1 = lat2;
        lon1 = lon2;
      }
      lat2 = [this$0_->nodeAccess_ getLatitudeWithInt:nodeB];
      lon2 = [this$0_->nodeAccess_ getLongitudeWithInt:nodeB];
      [self addNodeWithInt:nodeA withInt:nodeB withDouble:lat1 withDouble:lon1 withDouble:lat2 withDouble:lon2];
    }
  }
  @catch (JavaLangException *ex) {
    [((id<OrgSlf4jLogger>) nil_chk(this$0_->logger_)) errorWithNSString:JreStrcat("$I$I$I", @"Problem! base:", [((id<EdgeIterator>) nil_chk(allIter)) getBaseNode], @", adj:", [allIter getAdjNode], @", edge:", [allIter getEdge]) withJavaLangThrowable:ex];
  }
}

- (void)addNodeWithInt:(jint)nodeA
               withInt:(jint)nodeB
            withDouble:(jdouble)lat1
            withDouble:(jdouble)lon1
            withDouble:(jdouble)lat2
            withDouble:(jdouble)lon2 {
  id<PointEmitter> pointEmitter = [[[LocationIndexTree_InMemConstructionIndex_$1 alloc] initWithLocationIndexTree_InMemConstructionIndex:self withInt:nodeA] autorelease];
  if (![((id<DistanceCalc>) nil_chk(this$0_->distCalc_)) isCrossBoundaryWithDouble:lon1 withDouble:lon2]) {
    BresenhamLine_calcPointsWithDouble_withDouble_withDouble_withDouble_withPointEmitter_withDouble_withDouble_withDouble_withDouble_(lat1, lon1, lat2, lon2, pointEmitter, ((BBox *) nil_chk([((id<Graph>) nil_chk(this$0_->graph_)) getBounds]))->minLat_, ((BBox *) nil_chk([this$0_->graph_ getBounds]))->minLon_, this$0_->deltaLat_, this$0_->deltaLon_);
  }
}

- (void)addNodeWithLocationIndexTree_InMemEntry:(id<LocationIndexTree_InMemEntry>)entry_
                                        withInt:(jint)nodeId
                                        withInt:(jint)depth
                                       withLong:(jlong)keyPart
                                       withLong:(jlong)key {
  if ([((id<LocationIndexTree_InMemEntry>) nil_chk(entry_)) isLeaf]) {
    LocationIndexTree_InMemLeafEntry *leafEntry = (LocationIndexTree_InMemLeafEntry *) check_class_cast(entry_, [LocationIndexTree_InMemLeafEntry class]);
    [leafEntry addNodeWithInt:nodeId];
  }
  else {
    jint index = (jint) (IOSLongArray_Get(nil_chk(this$0_->bitmasks_), depth) & keyPart);
    keyPart = URShift64(keyPart, IOSByteArray_Get(nil_chk(this$0_->shifts_), depth));
    LocationIndexTree_InMemTreeEntry *treeEntry = ((LocationIndexTree_InMemTreeEntry *) check_class_cast(entry_, [LocationIndexTree_InMemTreeEntry class]));
    id<LocationIndexTree_InMemEntry> subentry = [treeEntry getSubEntryWithInt:index];
    depth++;
    if (subentry == nil) {
      if (depth == ((IOSIntArray *) nil_chk(this$0_->entries_))->size_) {
        subentry = [[[LocationIndexTree_InMemLeafEntry alloc] initWithInt:this$0_->initSizeLeafEntries_ withLong:key] autorelease];
      }
      else {
        subentry = [[[LocationIndexTree_InMemTreeEntry alloc] initWithInt:IOSIntArray_Get(this$0_->entries_, depth)] autorelease];
      }
      [treeEntry setSubEntryWithInt:index withLocationIndexTree_InMemEntry:subentry];
    }
    [self addNodeWithLocationIndexTree_InMemEntry:subentry withInt:nodeId withInt:depth withLong:keyPart withLong:key];
  }
}

- (id<JavaUtilCollection>)getEntriesOfWithInt:(jint)selectDepth {
  id<JavaUtilList> list = [[[JavaUtilArrayList alloc] init] autorelease];
  [self fillLayerWithJavaUtilCollection:list withInt:selectDepth withInt:0 withJavaUtilCollection:[((LocationIndexTree_InMemTreeEntry *) nil_chk(((LocationIndexTree_InMemTreeEntry *) check_class_cast(root_, [LocationIndexTree_InMemTreeEntry class])))) getSubEntriesForDebug]];
  return list;
}

- (void)fillLayerWithJavaUtilCollection:(id<JavaUtilCollection>)list
                                withInt:(jint)selectDepth
                                withInt:(jint)depth
                 withJavaUtilCollection:(id<JavaUtilCollection>)entries {
  for (id<LocationIndexTree_InMemEntry> __strong entry_ in nil_chk(entries)) {
    if (selectDepth == depth) {
      [((id<JavaUtilCollection>) nil_chk(list)) addWithId:entry_];
    }
    else if ([entry_ isKindOfClass:[LocationIndexTree_InMemTreeEntry class]]) {
      [self fillLayerWithJavaUtilCollection:list withInt:selectDepth withInt:depth + 1 withJavaUtilCollection:[((LocationIndexTree_InMemTreeEntry *) nil_chk(((LocationIndexTree_InMemTreeEntry *) check_class_cast(entry_, [LocationIndexTree_InMemTreeEntry class])))) getSubEntriesForDebug]];
    }
  }
}

- (NSString *)print {
  JavaLangStringBuilder *sb = [[[JavaLangStringBuilder alloc] init] autorelease];
  [self printWithLocationIndexTree_InMemEntry:root_ withJavaLangStringBuilder:sb withLong:0 withInt:0];
  return [sb description];
}

- (void)printWithLocationIndexTree_InMemEntry:(id<LocationIndexTree_InMemEntry>)e
                    withJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                     withLong:(jlong)key
                                      withInt:(jint)depth {
  if ([((id<LocationIndexTree_InMemEntry>) nil_chk(e)) isLeaf]) {
    LocationIndexTree_InMemLeafEntry *leaf = (LocationIndexTree_InMemLeafEntry *) check_class_cast(e, [LocationIndexTree_InMemLeafEntry class]);
    jint bits = [((SpatialKeyAlgo *) nil_chk(this$0_->keyAlgo_)) getBits];
    [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:[BitUtil_get_BIG_() toBitStringWithLong:[((BitUtil *) nil_chk(BitUtil_get_BIG_())) reverseWithLong:key withInt:bits] withInt:bits]])) appendWithNSString:@"  "];
    GnuTroveListArrayTIntArrayList *entries = [leaf getResults];
    for (jint i = 0; i < [((GnuTroveListArrayTIntArrayList *) nil_chk(entries)) size]; i++) {
      [((JavaLangStringBuilder *) nil_chk([sb appendWithInt:[leaf getWithInt:i]])) appendWithChar:','];
    }
    [sb appendWithChar:0x000a];
  }
  else {
    LocationIndexTree_InMemTreeEntry *tree = (LocationIndexTree_InMemTreeEntry *) check_class_cast(e, [LocationIndexTree_InMemTreeEntry class]);
    key = LShift64(key, IOSByteArray_Get(nil_chk(this$0_->shifts_), depth));
    for (jint counter = 0; counter < ((IOSObjectArray *) nil_chk(tree->subEntries_))->size_; counter++) {
      id<LocationIndexTree_InMemEntry> sube = IOSObjectArray_Get(tree->subEntries_, counter);
      if (sube != nil) {
        [self printWithLocationIndexTree_InMemEntry:sube withJavaLangStringBuilder:sb withLong:key | counter withInt:depth + 1];
      }
    }
  }
}

- (jint)storeWithLocationIndexTree_InMemEntry:(id<LocationIndexTree_InMemEntry>)entry_
                                      withInt:(jint)intIndex {
  jlong refPointer = (jlong) intIndex * 4;
  if ([((id<LocationIndexTree_InMemEntry>) nil_chk(entry_)) isLeaf]) {
    LocationIndexTree_InMemLeafEntry *leaf = ((LocationIndexTree_InMemLeafEntry *) check_class_cast(entry_, [LocationIndexTree_InMemLeafEntry class]));
    GnuTroveListArrayTIntArrayList *entries = [leaf getResults];
    jint len = [((GnuTroveListArrayTIntArrayList *) nil_chk(entries)) size];
    if (len == 0) {
      return intIndex;
    }
    size_ += len;
    intIndex++;
    leafs_++;
    [((id<DataAccess>) nil_chk(this$0_->dataAccess_)) ensureCapacityWithLong:(jlong) (intIndex + len + 1) * 4];
    if (len == 1) {
      [this$0_->dataAccess_ setIntWithLong:refPointer withInt:-[entries getWithInt:0] - 1];
    }
    else {
      for (jint index = 0; index < len; index++, intIndex++) {
        [this$0_->dataAccess_ setIntWithLong:(jlong) intIndex * 4 withInt:[entries getWithInt:index]];
      }
      [this$0_->dataAccess_ setIntWithLong:refPointer withInt:intIndex];
    }
  }
  else {
    LocationIndexTree_InMemTreeEntry *treeEntry = ((LocationIndexTree_InMemTreeEntry *) check_class_cast(entry_, [LocationIndexTree_InMemTreeEntry class]));
    jint len = ((IOSObjectArray *) nil_chk(treeEntry->subEntries_))->size_;
    intIndex += len;
    for (jint subCounter = 0; subCounter < len; subCounter++, refPointer += 4) {
      id<LocationIndexTree_InMemEntry> subEntry = IOSObjectArray_Get(treeEntry->subEntries_, subCounter);
      if (subEntry == nil) {
        continue;
      }
      [((id<DataAccess>) nil_chk(this$0_->dataAccess_)) ensureCapacityWithLong:(jlong) (intIndex + 1) * 4];
      jint beforeIntIndex = intIndex;
      intIndex = [self storeWithLocationIndexTree_InMemEntry:subEntry withInt:beforeIntIndex];
      if (intIndex == beforeIntIndex) {
        [this$0_->dataAccess_ setIntWithLong:refPointer withInt:0];
      }
      else {
        [this$0_->dataAccess_ setIntWithLong:refPointer withInt:beforeIntIndex];
      }
    }
  }
  return intIndex;
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(root_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(LocationIndexTree_InMemConstructionIndex *)other {
  [super copyAllFieldsTo:other];
  LocationIndexTree_InMemConstructionIndex_set_this$0_(other, this$0_);
  other->size_ = size_;
  other->leafs_ = leafs_;
  LocationIndexTree_InMemConstructionIndex_set_root_(other, root_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithLocationIndexTree:withInt:", "InMemConstructionIndex", NULL, 0x1, NULL },
    { "prepare", NULL, "V", 0x0, NULL },
    { "addNodeWithInt:withInt:withDouble:withDouble:withDouble:withDouble:", "addNode", "V", 0x0, NULL },
    { "addNodeWithLocationIndexTree_InMemEntry:withInt:withInt:withLong:withLong:", "addNode", "V", 0x0, NULL },
    { "getEntriesOfWithInt:", "getEntriesOf", "Ljava.util.Collection;", 0x0, NULL },
    { "fillLayerWithJavaUtilCollection:withInt:withInt:withJavaUtilCollection:", "fillLayer", "V", 0x0, NULL },
    { "print", NULL, "Ljava.lang.String;", 0x0, NULL },
    { "printWithLocationIndexTree_InMemEntry:withJavaLangStringBuilder:withLong:withInt:", "print", "V", 0x0, NULL },
    { "storeWithLocationIndexTree_InMemEntry:withInt:", "store", "I", 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lcom.graphhopper.storage.index.LocationIndexTree;", NULL,  },
    { "size_", NULL, 0x0, "I", NULL,  },
    { "leafs_", NULL, 0x0, "I", NULL,  },
    { "root_", NULL, 0x0, "Lcom.graphhopper.storage.index.LocationIndexTree$InMemTreeEntry;", NULL,  },
  };
  static const J2ObjcClassInfo _LocationIndexTree_InMemConstructionIndex = { 1, "InMemConstructionIndex", "com.graphhopper.storage.index", "LocationIndexTree", 0x0, 9, methods, 4, fields, 0, NULL};
  return &_LocationIndexTree_InMemConstructionIndex;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LocationIndexTree_InMemConstructionIndex)

@implementation LocationIndexTree_InMemConstructionIndex_$1

- (void)setWithDouble:(jdouble)lat
           withDouble:(jdouble)lon {
  jlong key = [((SpatialKeyAlgo *) nil_chk(this$0_->this$0_->keyAlgo_)) encodeWithDouble:lat withDouble:lon];
  jlong keyPart = LocationIndexTree_createReverseKeyWithLong_(this$0_->this$0_, key);
  [this$0_ addNodeWithLocationIndexTree_InMemEntry:this$0_->root_ withInt:val$nodeA_ withInt:0 withLong:keyPart withLong:key];
}

- (instancetype)initWithLocationIndexTree_InMemConstructionIndex:(LocationIndexTree_InMemConstructionIndex *)outer$
                                                         withInt:(jint)capture$0 {
  LocationIndexTree_InMemConstructionIndex_$1_set_this$0_(self, outer$);
  val$nodeA_ = capture$0;
  return [super init];
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(LocationIndexTree_InMemConstructionIndex_$1 *)other {
  [super copyAllFieldsTo:other];
  LocationIndexTree_InMemConstructionIndex_$1_set_this$0_(other, this$0_);
  other->val$nodeA_ = val$nodeA_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "setWithDouble:withDouble:", "set", "V", 0x1, NULL },
    { "initWithLocationIndexTree_InMemConstructionIndex:withInt:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lcom.graphhopper.storage.index.LocationIndexTree$InMemConstructionIndex;", NULL,  },
    { "val$nodeA_", NULL, 0x1012, "I", NULL,  },
  };
  static const J2ObjcClassInfo _LocationIndexTree_InMemConstructionIndex_$1 = { 1, "$1", "com.graphhopper.storage.index", "LocationIndexTree$InMemConstructionIndex", 0x8000, 2, methods, 2, fields, 0, NULL};
  return &_LocationIndexTree_InMemConstructionIndex_$1;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LocationIndexTree_InMemConstructionIndex_$1)

@implementation LocationIndexTree_$1

- (jboolean)executeWithInt:(jint)networkEntryNodeId {
  [((LocationIndexTree_$1_$1 *) [[[LocationIndexTree_$1_$1 alloc] initWithLocationIndexTree_$1:self withDouble:val$queryLat_ withDouble:val$queryLon_ withGHBitSet:val$checkBitset_ withEdgeFilter:val$edgeFilter_] autorelease]) startWithEdgeExplorer:val$explorer_ withInt:networkEntryNodeId];
  return YES;
}

- (instancetype)initWithLocationIndexTree:(LocationIndexTree *)outer$
                               withDouble:(jdouble)capture$0
                               withDouble:(jdouble)capture$1
                             withGHBitSet:(id<GHBitSet>)capture$2
                           withEdgeFilter:(id<EdgeFilter>)capture$3
                          withQueryResult:(QueryResult *)capture$4
                         withEdgeExplorer:(id<EdgeExplorer>)capture$5 {
  LocationIndexTree_$1_set_this$0_(self, outer$);
  val$queryLat_ = capture$0;
  val$queryLon_ = capture$1;
  LocationIndexTree_$1_set_val$checkBitset_(self, capture$2);
  LocationIndexTree_$1_set_val$edgeFilter_(self, capture$3);
  LocationIndexTree_$1_set_val$closestMatch_(self, capture$4);
  LocationIndexTree_$1_set_val$explorer_(self, capture$5);
  return [super init];
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(val$checkBitset_);
  RELEASE_(val$edgeFilter_);
  RELEASE_(val$closestMatch_);
  RELEASE_(val$explorer_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(LocationIndexTree_$1 *)other {
  [super copyAllFieldsTo:other];
  LocationIndexTree_$1_set_this$0_(other, this$0_);
  other->val$queryLat_ = val$queryLat_;
  other->val$queryLon_ = val$queryLon_;
  LocationIndexTree_$1_set_val$checkBitset_(other, val$checkBitset_);
  LocationIndexTree_$1_set_val$edgeFilter_(other, val$edgeFilter_);
  LocationIndexTree_$1_set_val$closestMatch_(other, val$closestMatch_);
  LocationIndexTree_$1_set_val$explorer_(other, val$explorer_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "executeWithInt:", "execute", "Z", 0x1, NULL },
    { "initWithLocationIndexTree:withDouble:withDouble:withGHBitSet:withEdgeFilter:withQueryResult:withEdgeExplorer:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lcom.graphhopper.storage.index.LocationIndexTree;", NULL,  },
    { "val$queryLat_", NULL, 0x1012, "D", NULL,  },
    { "val$queryLon_", NULL, 0x1012, "D", NULL,  },
    { "val$checkBitset_", NULL, 0x1012, "Lcom.graphhopper.coll.GHBitSet;", NULL,  },
    { "val$edgeFilter_", NULL, 0x1012, "Lcom.graphhopper.routing.util.EdgeFilter;", NULL,  },
    { "val$closestMatch_", NULL, 0x1012, "Lcom.graphhopper.storage.index.QueryResult;", NULL,  },
    { "val$explorer_", NULL, 0x1012, "Lcom.graphhopper.util.EdgeExplorer;", NULL,  },
  };
  static const J2ObjcClassInfo _LocationIndexTree_$1 = { 1, "$1", "com.graphhopper.storage.index", "LocationIndexTree", 0x8000, 2, methods, 7, fields, 0, NULL};
  return &_LocationIndexTree_$1;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LocationIndexTree_$1)

@implementation LocationIndexTree_XFirstSearchCheck

- (instancetype)initWithLocationIndexTree:(LocationIndexTree *)outer$
                               withDouble:(jdouble)queryLat
                               withDouble:(jdouble)queryLon
                             withGHBitSet:(id<GHBitSet>)checkBitset
                           withEdgeFilter:(id<EdgeFilter>)edgeFilter {
  LocationIndexTree_XFirstSearchCheck_set_this$0_(self, outer$);
  if (self = [super init]) {
    goFurther__ = YES;
    self->queryLat_ = queryLat;
    self->queryLon_ = queryLon;
    LocationIndexTree_XFirstSearchCheck_set_checkBitset_(self, checkBitset);
    LocationIndexTree_XFirstSearchCheck_set_edgeFilter_(self, edgeFilter);
  }
  return self;
}

- (id<GHBitSet>)createBitSet {
  return checkBitset_;
}

- (jboolean)goFurtherWithInt:(jint)baseNode {
  currNode_ = baseNode;
  currLat_ = [((id<NodeAccess>) nil_chk(this$0_->nodeAccess_)) getLatitudeWithInt:baseNode];
  currLon_ = [this$0_->nodeAccess_ getLongitudeWithInt:baseNode];
  currNormedDist_ = [((id<DistanceCalc>) nil_chk(this$0_->distCalc_)) calcNormalizedDistWithDouble:queryLat_ withDouble:queryLon_ withDouble:currLat_ withDouble:currLon_];
  return goFurther__;
}

- (jboolean)checkAdjacentWithEdgeIteratorState:(id<EdgeIteratorState>)currEdge {
  goFurther__ = NO;
  if (![((id<EdgeFilter>) nil_chk(edgeFilter_)) acceptWithEdgeIteratorState:currEdge]) {
    return YES;
  }
  jint tmpClosestNode = currNode_;
  if ([self checkWithInt:tmpClosestNode withDouble:currNormedDist_ withInt:0 withEdgeIteratorState:currEdge withQueryResult_PositionEnum:QueryResult_PositionEnum_get_TOWER()]) {
    if (currNormedDist_ <= this$0_->equalNormedDelta_) return NO;
  }
  jint adjNode = [((id<EdgeIteratorState>) nil_chk(currEdge)) getAdjNode];
  jdouble adjLat = [((id<NodeAccess>) nil_chk(this$0_->nodeAccess_)) getLatitudeWithInt:adjNode];
  jdouble adjLon = [this$0_->nodeAccess_ getLongitudeWithInt:adjNode];
  jdouble adjDist = [((id<DistanceCalc>) nil_chk(this$0_->distCalc_)) calcNormalizedDistWithDouble:adjLat withDouble:adjLon withDouble:queryLat_ withDouble:queryLon_];
  if (adjDist < currNormedDist_) tmpClosestNode = adjNode;
  jdouble tmpLat = currLat_;
  jdouble tmpLon = currLon_;
  jdouble tmpNormedDist;
  PointList *pointList = [currEdge fetchWayGeometryWithInt:2];
  jint len = [((PointList *) nil_chk(pointList)) getSize];
  for (jint pointIndex = 0; pointIndex < len; pointIndex++) {
    jdouble wayLat = [pointList getLatitudeWithInt:pointIndex];
    jdouble wayLon = [pointList getLongitudeWithInt:pointIndex];
    QueryResult_PositionEnum *pos = QueryResult_PositionEnum_get_EDGE();
    if ([this$0_->distCalc_ isCrossBoundaryWithDouble:tmpLon withDouble:wayLon]) {
      tmpLat = wayLat;
      tmpLon = wayLon;
      continue;
    }
    if ([this$0_->distCalc_ validEdgeDistanceWithDouble:queryLat_ withDouble:queryLon_ withDouble:tmpLat withDouble:tmpLon withDouble:wayLat withDouble:wayLon]) {
      tmpNormedDist = [this$0_->distCalc_ calcNormalizedEdgeDistanceWithDouble:queryLat_ withDouble:queryLon_ withDouble:tmpLat withDouble:tmpLon withDouble:wayLat withDouble:wayLon];
      [self checkWithInt:tmpClosestNode withDouble:tmpNormedDist withInt:pointIndex withEdgeIteratorState:currEdge withQueryResult_PositionEnum:pos];
    }
    else {
      if (pointIndex + 1 == len) {
        tmpNormedDist = adjDist;
        pos = QueryResult_PositionEnum_get_TOWER();
      }
      else {
        tmpNormedDist = [this$0_->distCalc_ calcNormalizedDistWithDouble:queryLat_ withDouble:queryLon_ withDouble:wayLat withDouble:wayLon];
        pos = QueryResult_PositionEnum_get_PILLAR();
      }
      [self checkWithInt:tmpClosestNode withDouble:tmpNormedDist withInt:pointIndex + 1 withEdgeIteratorState:currEdge withQueryResult_PositionEnum:pos];
    }
    if (tmpNormedDist <= this$0_->equalNormedDelta_) return NO;
    tmpLat = wayLat;
    tmpLon = wayLon;
  }
  return [self getQueryDistance] > this$0_->equalNormedDelta_;
}

- (jdouble)getQueryDistance {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (jboolean)checkWithInt:(jint)node
              withDouble:(jdouble)normedDist
                 withInt:(jint)wayIndex
   withEdgeIteratorState:(id<EdgeIteratorState>)iter
withQueryResult_PositionEnum:(QueryResult_PositionEnum *)pos {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(checkBitset_);
  RELEASE_(edgeFilter_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(LocationIndexTree_XFirstSearchCheck *)other {
  [super copyAllFieldsTo:other];
  LocationIndexTree_XFirstSearchCheck_set_this$0_(other, this$0_);
  other->queryLat_ = queryLat_;
  other->queryLon_ = queryLon_;
  LocationIndexTree_XFirstSearchCheck_set_checkBitset_(other, checkBitset_);
  LocationIndexTree_XFirstSearchCheck_set_edgeFilter_(other, edgeFilter_);
  other->goFurther__ = goFurther__;
  other->currNormedDist_ = currNormedDist_;
  other->currLat_ = currLat_;
  other->currLon_ = currLon_;
  other->currNode_ = currNode_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithLocationIndexTree:withDouble:withDouble:withGHBitSet:withEdgeFilter:", "XFirstSearchCheck", NULL, 0x1, NULL },
    { "createBitSet", NULL, "Lcom.graphhopper.coll.GHBitSet;", 0x4, NULL },
    { "goFurtherWithInt:", "goFurther", "Z", 0x4, NULL },
    { "checkAdjacentWithEdgeIteratorState:", "checkAdjacent", "Z", 0x4, NULL },
    { "getQueryDistance", NULL, "D", 0x404, NULL },
    { "checkWithInt:withDouble:withInt:withEdgeIteratorState:withQueryResult_PositionEnum:", "check", "Z", 0x404, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lcom.graphhopper.storage.index.LocationIndexTree;", NULL,  },
    { "queryLat_", NULL, 0x10, "D", NULL,  },
    { "queryLon_", NULL, 0x10, "D", NULL,  },
    { "checkBitset_", NULL, 0x10, "Lcom.graphhopper.coll.GHBitSet;", NULL,  },
    { "edgeFilter_", NULL, 0x10, "Lcom.graphhopper.routing.util.EdgeFilter;", NULL,  },
    { "goFurther__", "goFurther", 0x0, "Z", NULL,  },
    { "currNormedDist_", NULL, 0x0, "D", NULL,  },
    { "currLat_", NULL, 0x0, "D", NULL,  },
    { "currLon_", NULL, 0x0, "D", NULL,  },
    { "currNode_", NULL, 0x0, "I", NULL,  },
  };
  static const J2ObjcClassInfo _LocationIndexTree_XFirstSearchCheck = { 1, "XFirstSearchCheck", "com.graphhopper.storage.index", "LocationIndexTree", 0x404, 6, methods, 10, fields, 0, NULL};
  return &_LocationIndexTree_XFirstSearchCheck;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LocationIndexTree_XFirstSearchCheck)

@implementation LocationIndexTree_$1_$1

- (jdouble)getQueryDistance {
  return [((QueryResult *) nil_chk(this$1_->val$closestMatch_)) getQueryDistance];
}

- (jboolean)checkWithInt:(jint)node
              withDouble:(jdouble)normedDist
                 withInt:(jint)wayIndex
   withEdgeIteratorState:(id<EdgeIteratorState>)edge
withQueryResult_PositionEnum:(QueryResult_PositionEnum *)pos {
  if (normedDist < [((QueryResult *) nil_chk(this$1_->val$closestMatch_)) getQueryDistance]) {
    [this$1_->val$closestMatch_ setQueryDistanceWithDouble:normedDist];
    [this$1_->val$closestMatch_ setClosestNodeWithInt:node];
    [this$1_->val$closestMatch_ setClosestEdgeWithEdgeIteratorState:[((id<EdgeIteratorState>) nil_chk(edge)) detachWithBoolean:NO]];
    [this$1_->val$closestMatch_ setWayIndexWithInt:wayIndex];
    [this$1_->val$closestMatch_ setSnappedPositionWithQueryResult_PositionEnum:pos];
    return YES;
  }
  return NO;
}

- (instancetype)initWithLocationIndexTree_$1:(LocationIndexTree_$1 *)outer$
                                  withDouble:(jdouble)arg$0
                                  withDouble:(jdouble)arg$1
                                withGHBitSet:(id<GHBitSet>)arg$2
                              withEdgeFilter:(id<EdgeFilter>)arg$3 {
  LocationIndexTree_$1_$1_set_this$1_(self, outer$);
  return [super initWithLocationIndexTree:outer$->this$0_ withDouble:arg$0 withDouble:arg$1 withGHBitSet:arg$2 withEdgeFilter:arg$3];
}

- (void)dealloc {
  RELEASE_(this$1_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(LocationIndexTree_$1_$1 *)other {
  [super copyAllFieldsTo:other];
  LocationIndexTree_$1_$1_set_this$1_(other, this$1_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "getQueryDistance", NULL, "D", 0x4, NULL },
    { "checkWithInt:withDouble:withInt:withEdgeIteratorState:withQueryResult_PositionEnum:", "check", "Z", 0x4, NULL },
    { "initWithLocationIndexTree_$1:withDouble:withDouble:withGHBitSet:withEdgeFilter:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$1_", NULL, 0x1012, "Lcom.graphhopper.storage.index.LocationIndexTree$1;", NULL,  },
  };
  static const J2ObjcClassInfo _LocationIndexTree_$1_$1 = { 1, "$1", "com.graphhopper.storage.index", "LocationIndexTree$$1", 0x8000, 3, methods, 1, fields, 0, NULL};
  return &_LocationIndexTree_$1_$1;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LocationIndexTree_$1_$1)
