//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
//

#ifndef _LocationIndexTree_H_
#define _LocationIndexTree_H_

@class GHPoint;
@class GnuTroveSetHashTIntHashSet;
@class IOSByteArray;
@class IOSIntArray;
@class IOSLongArray;
@class IOSObjectArray;
@class JavaLangStringBuilder;
@class LocationIndexTree_InMemConstructionIndex;
@class QueryResult;
@class QueryResult_PositionEnum;
@class SpatialKeyAlgo;
@protocol DataAccess;
@protocol Directory;
@protocol DistanceCalc;
@protocol EdgeExplorer;
@protocol EdgeFilter;
@protocol EdgeIteratorState;
@protocol GHBitSet;
@protocol Graph;
@protocol JavaUtilCollection;
@protocol NodeAccess;
@protocol OrgSlf4jLogger;

#include "J2ObjC_header.h"
#include "com/graphhopper/storage/index/LocationIndex.h"
#include "com/graphhopper/storage/index/PointEmitter.h"
#include "com/graphhopper/util/BreadthFirstSearch.h"
#include "gnu/trove/list/array/TIntArrayList.h"
#include "gnu/trove/procedure/TIntProcedure.h"

#define LocationIndexTree_START_POINTER 1

/**
 @brief This implementation implements an n-tree to get the closest node or edge from GPS coordinates.
 <p> All leafs are at the same depth, otherwise it is quite complicated to calculate the bresenham line for different resolutions, especially if a leaf node could be split into a tree-node and resolution changes. <p>
 @author Peter Karich
 */
@interface LocationIndexTree : NSObject < LocationIndex > {
 @public
  id<Graph> graph_;
  id<DataAccess> dataAccess_;
  id<DistanceCalc> distCalc_;
  SpatialKeyAlgo *keyAlgo_;
  jint maxRegionSearch_;
}

/**
 @param g the graph for which this index should do the lookup based on latitude,longitude.
 */
- (instancetype)initWithGraph:(id<Graph>)g
                withDirectory:(id<Directory>)dir;

- (jint)getMinResolutionInMeter;

/**
 @brief Minimum width in meter of one tile.
 Decrease this if you need faster queries, but keep in mind that then queries with different coordinates are more likely to fail.
 */
- (LocationIndexTree *)setMinResolutionInMeterWithInt:(jint)minResolutionInMeter;

/**
 @brief Searches also neighbouring tiles until the maximum distance from the query point is reached (minResolutionInMeter*regionAround).
 Set to 1 for to force avoiding a fall back, good if you have strict performance and lookup-quality requirements. Default is 4.
 */
- (LocationIndexTree *)setMaxRegionSearchWithInt:(jint)numTiles;

- (void)prepareAlgo;

- (LocationIndexTree_InMemConstructionIndex *)getPrepareInMemIndex;

- (jint)findIDWithDouble:(jdouble)lat
              withDouble:(jdouble)lon;

- (id<LocationIndex>)setResolutionWithInt:(jint)minResolutionInMeter;

- (id<LocationIndex>)setApproximationWithBoolean:(jboolean)approx;

- (LocationIndexTree *)createWithLong:(jlong)size;

- (jboolean)loadExisting;

- (void)flush;

- (id<LocationIndex>)prepareIndex;

- (jint)calcChecksum;

- (void)close;

- (jboolean)isClosed;

- (jlong)getCapacity;

- (void)setSegmentSizeWithInt:(jint)bytes;

- (GnuTroveListArrayTIntArrayList *)getEntries;

- (void)fillIDsWithLong:(jlong)keyPart
                withInt:(jint)intIndex
withGnuTroveSetHashTIntHashSet:(GnuTroveSetHashTIntHashSet *)set
                withInt:(jint)depth;

- (jlong)createReverseKeyWithDouble:(jdouble)lat
                         withDouble:(jdouble)lon;

- (jlong)createReverseKeyWithLong:(jlong)key;

/**
 @brief calculate the distance to the nearest tile border for a given lat/lon coordinate in the context of a spatial key tile.
 <p>
 */
- (jdouble)calculateRMinWithDouble:(jdouble)lat
                        withDouble:(jdouble)lon;

/**
 @brief Calculates the distance to the nearest tile border, where the tile border is the rectangular region with dimension 2*paddingTiles + 1 and where the center tile contains the given lat/lon coordinate
 */
- (jdouble)calculateRMinWithDouble:(jdouble)lat
                        withDouble:(jdouble)lon
                           withInt:(jint)paddingTiles;

/**
 @brief Provide info about tilesize for testing / visualization
 */
- (jdouble)getDeltaLat;

- (jdouble)getDeltaLon;

- (GHPoint *)getCenterWithDouble:(jdouble)lat
                      withDouble:(jdouble)lon;

/**
 @brief This method collects the node indices from the quad tree data structure in a certain order which makes sure not too many nodes are collected as well as no nodes will be missing.
 See discussion at issue #221. <p>
 @return true if no further call of this method is required. False otherwise, ie. a next iteration is necessary and no early finish possible.
 */
- (jboolean)findNetworkEntriesWithDouble:(jdouble)queryLat
                              withDouble:(jdouble)queryLon
          withGnuTroveSetHashTIntHashSet:(GnuTroveSetHashTIntHashSet *)foundEntries
                                 withInt:(jint)iteration;

- (jdouble)calcMinDistanceWithDouble:(jdouble)queryLat
                          withDouble:(jdouble)queryLon
      withGnuTroveSetHashTIntHashSet:(GnuTroveSetHashTIntHashSet *)pointset;

- (void)findNetworkEntriesSingleRegionWithGnuTroveSetHashTIntHashSet:(GnuTroveSetHashTIntHashSet *)storedNetworkEntryIds
                                                          withDouble:(jdouble)queryLat
                                                          withDouble:(jdouble)queryLon;

- (QueryResult *)findClosestWithDouble:(jdouble)queryLat
                            withDouble:(jdouble)queryLon
                        withEdgeFilter:(id<EdgeFilter>)edgeFilter;

@end

J2OBJC_EMPTY_STATIC_INIT(LocationIndexTree)

J2OBJC_FIELD_SETTER(LocationIndexTree, graph_, id<Graph>)
J2OBJC_FIELD_SETTER(LocationIndexTree, dataAccess_, id<DataAccess>)
J2OBJC_FIELD_SETTER(LocationIndexTree, distCalc_, id<DistanceCalc>)
J2OBJC_FIELD_SETTER(LocationIndexTree, keyAlgo_, SpatialKeyAlgo *)

CF_EXTERN_C_BEGIN

J2OBJC_STATIC_FIELD_GETTER(LocationIndexTree, START_POINTER, jint)
CF_EXTERN_C_END

typedef LocationIndexTree ComGraphhopperStorageIndexLocationIndexTree;

J2OBJC_TYPE_LITERAL_HEADER(LocationIndexTree)

@interface LocationIndexTree_SortedIntSet : GnuTroveListArrayTIntArrayList {
}

- (instancetype)init;

- (instancetype)initWithInt:(jint)capacity;

/**
 @brief Allow adding a value only once
 */
- (jboolean)addOnceWithInt:(jint)value;

@end

J2OBJC_EMPTY_STATIC_INIT(LocationIndexTree_SortedIntSet)

CF_EXTERN_C_BEGIN
CF_EXTERN_C_END

J2OBJC_TYPE_LITERAL_HEADER(LocationIndexTree_SortedIntSet)

@protocol LocationIndexTree_InMemEntry < NSObject, JavaObject >

- (jboolean)isLeaf;

@end

J2OBJC_EMPTY_STATIC_INIT(LocationIndexTree_InMemEntry)

J2OBJC_TYPE_LITERAL_HEADER(LocationIndexTree_InMemEntry)

@interface LocationIndexTree_InMemLeafEntry : LocationIndexTree_SortedIntSet < LocationIndexTree_InMemEntry > {
}

- (instancetype)initWithInt:(jint)count
                   withLong:(jlong)key;

- (jboolean)addNodeWithInt:(jint)nodeId;

- (jboolean)isLeaf;

- (NSString *)description;

- (GnuTroveListArrayTIntArrayList *)getResults;

@end

J2OBJC_EMPTY_STATIC_INIT(LocationIndexTree_InMemLeafEntry)

CF_EXTERN_C_BEGIN
CF_EXTERN_C_END

J2OBJC_TYPE_LITERAL_HEADER(LocationIndexTree_InMemLeafEntry)

@interface LocationIndexTree_InMemTreeEntry : NSObject < LocationIndexTree_InMemEntry > {
 @public
  IOSObjectArray *subEntries_;
}

- (instancetype)initWithInt:(jint)subEntryNo;

- (id<LocationIndexTree_InMemEntry>)getSubEntryWithInt:(jint)index;

- (void)setSubEntryWithInt:(jint)index
withLocationIndexTree_InMemEntry:(id<LocationIndexTree_InMemEntry>)subEntry;

- (id<JavaUtilCollection>)getSubEntriesForDebug;

- (jboolean)isLeaf;

- (NSString *)description;

@end

J2OBJC_EMPTY_STATIC_INIT(LocationIndexTree_InMemTreeEntry)

J2OBJC_FIELD_SETTER(LocationIndexTree_InMemTreeEntry, subEntries_, IOSObjectArray *)

CF_EXTERN_C_BEGIN
CF_EXTERN_C_END

J2OBJC_TYPE_LITERAL_HEADER(LocationIndexTree_InMemTreeEntry)

@interface LocationIndexTree_InMemConstructionIndex : NSObject {
 @public
  jint size_;
  jint leafs_;
  LocationIndexTree_InMemTreeEntry *root_;
}

- (instancetype)initWithLocationIndexTree:(LocationIndexTree *)outer$
                                  withInt:(jint)noOfSubEntries;

- (void)prepare;

- (void)addNodeWithInt:(jint)nodeA
               withInt:(jint)nodeB
            withDouble:(jdouble)lat1
            withDouble:(jdouble)lon1
            withDouble:(jdouble)lat2
            withDouble:(jdouble)lon2;

- (void)addNodeWithLocationIndexTree_InMemEntry:(id<LocationIndexTree_InMemEntry>)entry_
                                        withInt:(jint)nodeId
                                        withInt:(jint)depth
                                       withLong:(jlong)keyPart
                                       withLong:(jlong)key;

- (id<JavaUtilCollection>)getEntriesOfWithInt:(jint)selectDepth;

- (void)fillLayerWithJavaUtilCollection:(id<JavaUtilCollection>)list
                                withInt:(jint)selectDepth
                                withInt:(jint)depth
                 withJavaUtilCollection:(id<JavaUtilCollection>)entries;

- (NSString *)print;

- (void)printWithLocationIndexTree_InMemEntry:(id<LocationIndexTree_InMemEntry>)e
                    withJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                     withLong:(jlong)key
                                      withInt:(jint)depth;

- (jint)storeWithLocationIndexTree_InMemEntry:(id<LocationIndexTree_InMemEntry>)entry_
                                      withInt:(jint)intIndex;

@end

J2OBJC_EMPTY_STATIC_INIT(LocationIndexTree_InMemConstructionIndex)

J2OBJC_FIELD_SETTER(LocationIndexTree_InMemConstructionIndex, root_, LocationIndexTree_InMemTreeEntry *)

CF_EXTERN_C_BEGIN
CF_EXTERN_C_END

J2OBJC_TYPE_LITERAL_HEADER(LocationIndexTree_InMemConstructionIndex)

@interface LocationIndexTree_InMemConstructionIndex_$1 : NSObject < PointEmitter > {
}

- (void)setWithDouble:(jdouble)lat
           withDouble:(jdouble)lon;

- (instancetype)initWithLocationIndexTree_InMemConstructionIndex:(LocationIndexTree_InMemConstructionIndex *)outer$
                                                         withInt:(jint)capture$0;

@end

J2OBJC_EMPTY_STATIC_INIT(LocationIndexTree_InMemConstructionIndex_$1)

CF_EXTERN_C_BEGIN
CF_EXTERN_C_END

J2OBJC_TYPE_LITERAL_HEADER(LocationIndexTree_InMemConstructionIndex_$1)

@interface LocationIndexTree_$1 : NSObject < GnuTroveProcedureTIntProcedure > {
}

- (jboolean)executeWithInt:(jint)networkEntryNodeId;

- (instancetype)initWithLocationIndexTree:(LocationIndexTree *)outer$
                               withDouble:(jdouble)capture$0
                               withDouble:(jdouble)capture$1
                             withGHBitSet:(id<GHBitSet>)capture$2
                           withEdgeFilter:(id<EdgeFilter>)capture$3
                          withQueryResult:(QueryResult *)capture$4
                         withEdgeExplorer:(id<EdgeExplorer>)capture$5;

@end

J2OBJC_EMPTY_STATIC_INIT(LocationIndexTree_$1)

CF_EXTERN_C_BEGIN
CF_EXTERN_C_END

J2OBJC_TYPE_LITERAL_HEADER(LocationIndexTree_$1)

/**
 @brief Make it possible to collect nearby location also for other purposes.
 */
@interface LocationIndexTree_XFirstSearchCheck : BreadthFirstSearch {
 @public
  jdouble queryLat_;
  jdouble queryLon_;
  id<GHBitSet> checkBitset_;
  id<EdgeFilter> edgeFilter_;
  jboolean goFurther__;
  jdouble currNormedDist_;
  jdouble currLat_;
  jdouble currLon_;
  jint currNode_;
}

- (instancetype)initWithLocationIndexTree:(LocationIndexTree *)outer$
                               withDouble:(jdouble)queryLat
                               withDouble:(jdouble)queryLon
                             withGHBitSet:(id<GHBitSet>)checkBitset
                           withEdgeFilter:(id<EdgeFilter>)edgeFilter;

- (id<GHBitSet>)createBitSet;

- (jboolean)goFurtherWithInt:(jint)baseNode;

- (jboolean)checkAdjacentWithEdgeIteratorState:(id<EdgeIteratorState>)currEdge;

- (jdouble)getQueryDistance;

- (jboolean)checkWithInt:(jint)node
              withDouble:(jdouble)normedDist
                 withInt:(jint)wayIndex
   withEdgeIteratorState:(id<EdgeIteratorState>)iter
withQueryResult_PositionEnum:(QueryResult_PositionEnum *)pos;

@end

J2OBJC_EMPTY_STATIC_INIT(LocationIndexTree_XFirstSearchCheck)

J2OBJC_FIELD_SETTER(LocationIndexTree_XFirstSearchCheck, checkBitset_, id<GHBitSet>)
J2OBJC_FIELD_SETTER(LocationIndexTree_XFirstSearchCheck, edgeFilter_, id<EdgeFilter>)

CF_EXTERN_C_BEGIN
CF_EXTERN_C_END

J2OBJC_TYPE_LITERAL_HEADER(LocationIndexTree_XFirstSearchCheck)

@interface LocationIndexTree_$1_$1 : LocationIndexTree_XFirstSearchCheck {
}

- (jdouble)getQueryDistance;

- (jboolean)checkWithInt:(jint)node
              withDouble:(jdouble)normedDist
                 withInt:(jint)wayIndex
   withEdgeIteratorState:(id<EdgeIteratorState>)edge
withQueryResult_PositionEnum:(QueryResult_PositionEnum *)pos;

- (instancetype)initWithLocationIndexTree_$1:(LocationIndexTree_$1 *)outer$
                                  withDouble:(jdouble)arg$0
                                  withDouble:(jdouble)arg$1
                                withGHBitSet:(id<GHBitSet>)arg$2
                              withEdgeFilter:(id<EdgeFilter>)arg$3;

@end

J2OBJC_EMPTY_STATIC_INIT(LocationIndexTree_$1_$1)

CF_EXTERN_C_BEGIN
CF_EXTERN_C_END

J2OBJC_TYPE_LITERAL_HEADER(LocationIndexTree_$1_$1)

#endif // _LocationIndexTree_H_
