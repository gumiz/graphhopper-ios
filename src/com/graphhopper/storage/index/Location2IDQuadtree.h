//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
//

#ifndef _Location2IDQuadtree_H_
#define _Location2IDQuadtree_H_

@class QueryResult;
@protocol DataAccess;
@protocol Directory;
@protocol DistanceCalc;
@protocol EdgeFilter;
@protocol GHBitSet;
@protocol Graph;
@protocol KeyAlgo;
@protocol NodeAccess;
@protocol OrgSlf4jLogger;

#include "J2ObjC_header.h"
#include "com/graphhopper/storage/index/LocationIndex.h"
#include "com/graphhopper/util/BreadthFirstSearch.h"

#define Location2IDQuadtree_MAGIC_INT 174507

/**
 @brief This class implements map matching and returns a node index from lat,lon coordinate.
 This implementation is the a very memory efficient representation for areas with lots of node and edges, but lacks precision. No edge distances are measured. <p>
 @author Peter Karich
 */
@interface Location2IDQuadtree : NSObject < LocationIndex > {
 @public
  id<DistanceCalc> distCalc_;
}

- (instancetype)initWithGraph:(id<Graph>)g
                withDirectory:(id<Directory>)dir;

- (id<LocationIndex>)setApproximationWithBoolean:(jboolean)approxDist;

- (jlong)getCapacity;

/**
 @brief Loads the index from disc if exists.
 Make sure you are using the identical graph which was used while flushing this index. <p>
 @return if loading from file was successfully.
 */
- (jboolean)loadExisting;

- (id<LocationIndex>)createWithLong:(jlong)size;

- (id<LocationIndex>)setResolutionWithInt:(jint)resolution;

/**
 @brief Fill quadtree which will span a raster over the entire specified graph g.
 But do this in a pre-defined resolution which is controlled via capacity. This datastructure then uses approx. capacity * 4 bytes. So maximum capacity is 2^30 where the quadtree would cover the world boundaries every 1.3km - IMO enough for EU or US networks.
 */
- (id<LocationIndex>)prepareIndex;

- (void)initAlgoWithInt:(jint)lat
                withInt:(jint)lon OBJC_METHOD_FAMILY_NONE;

- (jdouble)getMaxRasterWidthMeter;

- (jdouble)getNormedDistWithInt:(jint)from
                        withInt:(jint)to;

/**
 @return the node id (corresponding to a coordinate) closest to the specified lat,lon.
 */
- (jint)findIDWithDouble:(jdouble)lat
              withDouble:(jdouble)lon;

- (QueryResult *)findClosestWithDouble:(jdouble)queryLat
                            withDouble:(jdouble)queryLon
                        withEdgeFilter:(id<EdgeFilter>)edgeFilter;

- (void)goFurtherHookWithInt:(jint)n;

- (void)flush;

- (void)close;

- (jboolean)isClosed;

- (void)setSegmentSizeWithInt:(jint)bytes;

@end

J2OBJC_EMPTY_STATIC_INIT(Location2IDQuadtree)

J2OBJC_FIELD_SETTER(Location2IDQuadtree, distCalc_, id<DistanceCalc>)

CF_EXTERN_C_BEGIN

J2OBJC_STATIC_FIELD_GETTER(Location2IDQuadtree, MAGIC_INT, jint)
CF_EXTERN_C_END

typedef Location2IDQuadtree ComGraphhopperStorageIndexLocation2IDQuadtree;

J2OBJC_TYPE_LITERAL_HEADER(Location2IDQuadtree)

@interface Location2IDQuadtree_$1 : BreadthFirstSearch {
}

- (id<GHBitSet>)createBitSet;

- (jboolean)goFurtherWithInt:(jint)baseNode;

- (instancetype)initWithLocation2IDQuadtree:(Location2IDQuadtree *)outer$
                                    withInt:(jint)capture$0
                                 withDouble:(jdouble)capture$1
                                 withDouble:(jdouble)capture$2
                            withQueryResult:(QueryResult *)capture$3;

@end

J2OBJC_EMPTY_STATIC_INIT(Location2IDQuadtree_$1)

CF_EXTERN_C_BEGIN
CF_EXTERN_C_END

J2OBJC_TYPE_LITERAL_HEADER(Location2IDQuadtree_$1)

#endif // _Location2IDQuadtree_H_
