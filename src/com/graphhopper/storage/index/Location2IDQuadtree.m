//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/coll/GHBitSet.h"
#include "com/graphhopper/coll/GHBitSetImpl.h"
#include "com/graphhopper/coll/GHTBitSet.h"
#include "com/graphhopper/geohash/KeyAlgo.h"
#include "com/graphhopper/geohash/LinearKeyAlgo.h"
#include "com/graphhopper/routing/util/EdgeFilter.h"
#include "com/graphhopper/storage/DataAccess.h"
#include "com/graphhopper/storage/Directory.h"
#include "com/graphhopper/storage/Graph.h"
#include "com/graphhopper/storage/NodeAccess.h"
#include "com/graphhopper/storage/RAMDirectory.h"
#include "com/graphhopper/storage/index/Location2IDQuadtree.h"
#include "com/graphhopper/storage/index/LocationIndex.h"
#include "com/graphhopper/storage/index/QueryResult.h"
#include "com/graphhopper/util/DistanceCalc.h"
#include "com/graphhopper/util/DistancePlaneProjection.h"
#include "com/graphhopper/util/EdgeExplorer.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/StopWatch.h"
#include "com/graphhopper/util/shapes/BBox.h"
#include "com/graphhopper/util/shapes/GHPoint.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/util/Arrays.h"
#include "org/slf4j/Logger.h"
#include "org/slf4j/LoggerFactory.h"

__attribute__((unused)) static void Location2IDQuadtree_initLatLonSizeWithInt_(Location2IDQuadtree *self, jint size);
__attribute__((unused)) static void Location2IDQuadtree_initBuffer(Location2IDQuadtree *self);
__attribute__((unused)) static id<GHBitSet> Location2IDQuadtree_fillQuadtreeWithInt_(Location2IDQuadtree *self, jint size);
__attribute__((unused)) static jint Location2IDQuadtree_fillEmptyIndicesWithGHBitSet_(Location2IDQuadtree *self, id<GHBitSet> filledIndices);

@interface Location2IDQuadtree () {
 @public
  id<OrgSlf4jLogger> logger_;
  id<DataAccess> index_;
  id<Graph> graph_;
  id<NodeAccess> nodeAccess_;
  id<KeyAlgo> keyAlgo_;
  jdouble maxRasterWidth2InMeterNormed_;
  jint lonSize_, latSize_;
}

- (void)initLatLonSizeWithInt:(jint)size OBJC_METHOD_FAMILY_NONE;

- (void)initBuffer OBJC_METHOD_FAMILY_NONE;

- (id<GHBitSet>)fillQuadtreeWithInt:(jint)size;

- (jint)fillEmptyIndicesWithGHBitSet:(id<GHBitSet>)filledIndices;
@end

J2OBJC_FIELD_SETTER(Location2IDQuadtree, logger_, id<OrgSlf4jLogger>)
J2OBJC_FIELD_SETTER(Location2IDQuadtree, index_, id<DataAccess>)
J2OBJC_FIELD_SETTER(Location2IDQuadtree, graph_, id<Graph>)
J2OBJC_FIELD_SETTER(Location2IDQuadtree, nodeAccess_, id<NodeAccess>)
J2OBJC_FIELD_SETTER(Location2IDQuadtree, keyAlgo_, id<KeyAlgo>)

@interface Location2IDQuadtree_$1 () {
 @public
  Location2IDQuadtree *this$0_;
  jint val$id_;
  jdouble val$queryLat_;
  jdouble val$queryLon_;
  QueryResult *val$res_;
}
@end

J2OBJC_FIELD_SETTER(Location2IDQuadtree_$1, this$0_, Location2IDQuadtree *)
J2OBJC_FIELD_SETTER(Location2IDQuadtree_$1, val$res_, QueryResult *)

@implementation Location2IDQuadtree

- (instancetype)initWithGraph:(id<Graph>)g
                withDirectory:(id<Directory>)dir {
  if (self = [super init]) {
    Location2IDQuadtree_set_logger_(self, OrgSlf4jLoggerFactory_getLoggerWithIOSClass_([self getClass]));
    Location2IDQuadtree_set_distCalc_(self, Helper_get_DIST_PLANE_());
    Location2IDQuadtree_set_graph_(self, g);
    Location2IDQuadtree_set_nodeAccess_(self, [((id<Graph>) nil_chk(g)) getNodeAccess]);
    Location2IDQuadtree_set_index_(self, [((id<Directory>) nil_chk(dir)) findWithNSString:@"loc2id_index"]);
    [self setResolutionWithInt:100 * 100];
  }
  return self;
}

- (id<LocationIndex>)setApproximationWithBoolean:(jboolean)approxDist {
  if (approxDist) Location2IDQuadtree_set_distCalc_(self, Helper_get_DIST_PLANE_());
  else Location2IDQuadtree_set_distCalc_(self, Helper_get_DIST_EARTH_());
  return self;
}

- (jlong)getCapacity {
  return [((id<DataAccess>) nil_chk(index_)) getCapacity] / 4;
}

- (jboolean)loadExisting {
  if (![((id<DataAccess>) nil_chk(index_)) loadExisting]) return NO;
  if ([index_ getHeaderWithInt:0] != Location2IDQuadtree_MAGIC_INT) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"incorrect loc2id index version"] autorelease];
  jint lat = [index_ getHeaderWithInt:1 * 4];
  jint lon = [index_ getHeaderWithInt:2 * 4];
  jint checksum = [index_ getHeaderWithInt:3 * 4];
  if (checksum != [((id<Graph>) nil_chk(graph_)) getNodes]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$I", @"index was created from a different graph with ", checksum, @". Current nodes:", [graph_ getNodes])] autorelease];
  [self initAlgoWithInt:lat withInt:lon];
  return YES;
}

- (id<LocationIndex>)createWithLong:(jlong)size {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:@"Not supported. Use prepareIndex instead."] autorelease];
}

- (id<LocationIndex>)setResolutionWithInt:(jint)resolution {
  Location2IDQuadtree_initLatLonSizeWithInt_(self, resolution);
  return self;
}

- (id<LocationIndex>)prepareIndex {
  Location2IDQuadtree_initBuffer(self);
  [self initAlgoWithInt:latSize_ withInt:lonSize_];
  StopWatch *sw = [((StopWatch *) [[[StopWatch alloc] init] autorelease]) start];
  id<GHBitSet> filledIndices = Location2IDQuadtree_fillQuadtreeWithInt_(self, latSize_ * lonSize_);
  jint fillQT = [((id<GHBitSet>) nil_chk(filledIndices)) getCardinality];
  jfloat res1 = [((StopWatch *) nil_chk([((StopWatch *) nil_chk(sw)) stop])) getSeconds];
  sw = [((StopWatch *) [[[StopWatch alloc] init] autorelease]) start];
  jint counter = Location2IDQuadtree_fillEmptyIndicesWithGHBitSet_(self, filledIndices);
  jfloat fillEmpty = [((StopWatch *) nil_chk([((StopWatch *) nil_chk(sw)) stop])) getSeconds];
  [((id<OrgSlf4jLogger>) nil_chk(logger_)) infoWithNSString:JreStrcat("$F$J$I$I$FC", @"filled quadtree index array in ", res1, @"s. size is ", [self getCapacity], @" (", fillQT, @"). filled empty ", counter, @" in ", fillEmpty, 's')];
  [self flush];
  return self;
}

- (void)initLatLonSizeWithInt:(jint)size {
  Location2IDQuadtree_initLatLonSizeWithInt_(self, size);
}

- (void)initBuffer {
  Location2IDQuadtree_initBuffer(self);
}

- (void)initAlgoWithInt:(jint)lat
                withInt:(jint)lon {
  self->latSize_ = lat;
  self->lonSize_ = lon;
  BBox *b = [((id<Graph>) nil_chk(graph_)) getBounds];
  Location2IDQuadtree_set_keyAlgo_(self, [((LinearKeyAlgo *) [[[LinearKeyAlgo alloc] initWithInt:lat withInt:lon] autorelease]) setBoundsWithBBox:b]);
  jdouble max = JavaLangMath_maxWithDouble_withDouble_([((id<DistanceCalc>) nil_chk(distCalc_)) calcDistWithDouble:((BBox *) nil_chk(b))->minLat_ withDouble:b->minLon_ withDouble:b->minLat_ withDouble:b->maxLon_], [distCalc_ calcDistWithDouble:b->minLat_ withDouble:b->minLon_ withDouble:b->maxLat_ withDouble:b->minLon_]);
  maxRasterWidth2InMeterNormed_ = [distCalc_ calcNormalizedDistWithDouble:max / JavaLangMath_sqrtWithDouble_([self getCapacity]) * 2];
}

- (jdouble)getMaxRasterWidthMeter {
  return [((id<DistanceCalc>) nil_chk(distCalc_)) calcDenormalizedDistWithDouble:maxRasterWidth2InMeterNormed_] / 2;
}

- (id<GHBitSet>)fillQuadtreeWithInt:(jint)size {
  return Location2IDQuadtree_fillQuadtreeWithInt_(self, size);
}

- (jint)fillEmptyIndicesWithGHBitSet:(id<GHBitSet>)filledIndices {
  return Location2IDQuadtree_fillEmptyIndicesWithGHBitSet_(self, filledIndices);
}

- (jdouble)getNormedDistWithInt:(jint)from
                        withInt:(jint)to {
  jint fromX = from % lonSize_;
  jint fromY = from / lonSize_;
  jint toX = to % lonSize_;
  jint toY = to / lonSize_;
  jint dx = (toX - fromX);
  jint dy = (toY - fromY);
  return dx * dx + dy * dy;
}

- (jint)findIDWithDouble:(jdouble)lat
              withDouble:(jdouble)lon {
  return [((QueryResult *) nil_chk([self findClosestWithDouble:lat withDouble:lon withEdgeFilter:EdgeFilter_get_ALL_EDGES_()])) getClosestNode];
}

- (QueryResult *)findClosestWithDouble:(jdouble)queryLat
                            withDouble:(jdouble)queryLon
                        withEdgeFilter:(id<EdgeFilter>)edgeFilter {
  if ([self isClosed]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"You need to create a new LocationIndex instance as it is already closed"] autorelease];
  if (edgeFilter != EdgeFilter_get_ALL_EDGES_()) @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:JreStrcat("$$", @"edge filters are not yet implemented for ", [Location2IDQuadtree_class_() getSimpleName])] autorelease];
  jlong key = [((id<KeyAlgo>) nil_chk(keyAlgo_)) encodeWithDouble:queryLat withDouble:queryLon];
  jint id_ = [((id<DataAccess>) nil_chk(index_)) getIntWithLong:key * 4];
  jdouble mainLat = [((id<NodeAccess>) nil_chk(nodeAccess_)) getLatitudeWithInt:id_];
  jdouble mainLon = [nodeAccess_ getLongitudeWithInt:id_];
  QueryResult *res = [[[QueryResult alloc] initWithDouble:queryLat withDouble:queryLon] autorelease];
  [res setClosestNodeWithInt:id_];
  [res setQueryDistanceWithDouble:[((id<DistanceCalc>) nil_chk(distCalc_)) calcNormalizedDistWithDouble:queryLat withDouble:queryLon withDouble:mainLat withDouble:mainLon]];
  [self goFurtherHookWithInt:id_];
  [((Location2IDQuadtree_$1 *) [[[Location2IDQuadtree_$1 alloc] initWithLocation2IDQuadtree:self withInt:id_ withDouble:queryLat withDouble:queryLon withQueryResult:res] autorelease]) startWithEdgeExplorer:[((id<Graph>) nil_chk(graph_)) createEdgeExplorer] withInt:id_];
  [res setQueryDistanceWithDouble:[distCalc_ calcDenormalizedDistWithDouble:[res getQueryDistance]]];
  return res;
}

- (void)goFurtherHookWithInt:(jint)n {
}

- (void)flush {
  [((id<DataAccess>) nil_chk(index_)) setHeaderWithInt:0 withInt:Location2IDQuadtree_MAGIC_INT];
  [index_ setHeaderWithInt:1 * 4 withInt:latSize_];
  [index_ setHeaderWithInt:2 * 4 withInt:lonSize_];
  [index_ setHeaderWithInt:3 * 4 withInt:[((id<Graph>) nil_chk(graph_)) getNodes]];
  [index_ flush];
}

- (void)close {
  [((id<DataAccess>) nil_chk(index_)) close];
}

- (jboolean)isClosed {
  return [((id<DataAccess>) nil_chk(index_)) isClosed];
}

- (void)setSegmentSizeWithInt:(jint)bytes {
  [((id<DataAccess>) nil_chk(index_)) setSegmentSizeWithInt:bytes];
}

- (void)dealloc {
  RELEASE_(logger_);
  RELEASE_(index_);
  RELEASE_(graph_);
  RELEASE_(nodeAccess_);
  RELEASE_(distCalc_);
  RELEASE_(keyAlgo_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(Location2IDQuadtree *)other {
  [super copyAllFieldsTo:other];
  Location2IDQuadtree_set_logger_(other, logger_);
  Location2IDQuadtree_set_index_(other, index_);
  Location2IDQuadtree_set_graph_(other, graph_);
  Location2IDQuadtree_set_nodeAccess_(other, nodeAccess_);
  Location2IDQuadtree_set_distCalc_(other, distCalc_);
  Location2IDQuadtree_set_keyAlgo_(other, keyAlgo_);
  other->maxRasterWidth2InMeterNormed_ = maxRasterWidth2InMeterNormed_;
  other->lonSize_ = lonSize_;
  other->latSize_ = latSize_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGraph:withDirectory:", "Location2IDQuadtree", NULL, 0x1, NULL },
    { "setApproximationWithBoolean:", "setApproximation", "Lcom.graphhopper.storage.index.LocationIndex;", 0x1, NULL },
    { "getCapacity", NULL, "J", 0x1, NULL },
    { "loadExisting", NULL, "Z", 0x1, NULL },
    { "createWithLong:", "create", "Lcom.graphhopper.storage.index.LocationIndex;", 0x1, NULL },
    { "setResolutionWithInt:", "setResolution", "Lcom.graphhopper.storage.index.LocationIndex;", 0x1, NULL },
    { "prepareIndex", NULL, "Lcom.graphhopper.storage.index.LocationIndex;", 0x1, NULL },
    { "initLatLonSizeWithInt:", "initLatLonSize", "V", 0x2, NULL },
    { "initBuffer", NULL, "V", 0x2, NULL },
    { "initAlgoWithInt:withInt:", "initAlgo", "V", 0x0, NULL },
    { "getMaxRasterWidthMeter", NULL, "D", 0x4, NULL },
    { "fillQuadtreeWithInt:", "fillQuadtree", "Lcom.graphhopper.coll.GHBitSet;", 0x2, NULL },
    { "fillEmptyIndicesWithGHBitSet:", "fillEmptyIndices", "I", 0x2, NULL },
    { "getNormedDistWithInt:withInt:", "getNormedDist", "D", 0x0, NULL },
    { "findIDWithDouble:withDouble:", "findID", "I", 0x1, NULL },
    { "findClosestWithDouble:withDouble:withEdgeFilter:", "findClosest", "Lcom.graphhopper.storage.index.QueryResult;", 0x1, NULL },
    { "goFurtherHookWithInt:", "goFurtherHook", "V", 0x1, NULL },
    { "flush", NULL, "V", 0x1, NULL },
    { "close", NULL, "V", 0x1, NULL },
    { "isClosed", NULL, "Z", 0x1, NULL },
    { "setSegmentSizeWithInt:", "setSegmentSize", "V", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "MAGIC_INT_", NULL, 0x1a, "I", NULL, .constantValue.asInt = Location2IDQuadtree_MAGIC_INT },
    { "logger_", NULL, 0x12, "Lorg.slf4j.Logger;", NULL,  },
    { "index_", NULL, 0x12, "Lcom.graphhopper.storage.DataAccess;", NULL,  },
    { "graph_", NULL, 0x12, "Lcom.graphhopper.storage.Graph;", NULL,  },
    { "nodeAccess_", NULL, 0x12, "Lcom.graphhopper.storage.NodeAccess;", NULL,  },
    { "distCalc_", NULL, 0x4, "Lcom.graphhopper.util.DistanceCalc;", NULL,  },
    { "keyAlgo_", NULL, 0x2, "Lcom.graphhopper.geohash.KeyAlgo;", NULL,  },
    { "maxRasterWidth2InMeterNormed_", NULL, 0x2, "D", NULL,  },
    { "lonSize_", NULL, 0x2, "I", NULL,  },
    { "latSize_", NULL, 0x2, "I", NULL,  },
  };
  static const J2ObjcClassInfo _Location2IDQuadtree = { 1, "Location2IDQuadtree", "com.graphhopper.storage.index", NULL, 0x0, 21, methods, 10, fields, 0, NULL};
  return &_Location2IDQuadtree;
}

@end

void Location2IDQuadtree_initLatLonSizeWithInt_(Location2IDQuadtree *self, jint size) {
  self->latSize_ = self->lonSize_ = J2ObjCFpToInt(JavaLangMath_sqrtWithDouble_(size));
  if (self->latSize_ * self->lonSize_ < size) self->lonSize_++;
}

void Location2IDQuadtree_initBuffer(Location2IDQuadtree *self) {
  [((id<DataAccess>) nil_chk(self->index_)) setSegmentSizeWithInt:self->latSize_ * self->lonSize_ * 4];
  [self->index_ createWithLong:self->latSize_ * self->lonSize_ * 4];
}

id<GHBitSet> Location2IDQuadtree_fillQuadtreeWithInt_(Location2IDQuadtree *self, jint size) {
  jint locs = [((id<Graph>) nil_chk(self->graph_)) getNodes];
  if (locs <= 0) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"check your graph - it is empty!"] autorelease];
  }
  id<GHBitSet> filledIndices = [[[GHBitSetImpl alloc] initWithInt:size] autorelease];
  GHPoint *coord = [[[GHPoint alloc] init] autorelease];
  for (jint nodeId = 0; nodeId < locs; nodeId++) {
    jdouble lat = [((id<NodeAccess>) nil_chk(self->nodeAccess_)) getLatitudeWithInt:nodeId];
    jdouble lon = [self->nodeAccess_ getLongitudeWithInt:nodeId];
    jint key = (jint) [((id<KeyAlgo>) nil_chk(self->keyAlgo_)) encodeWithDouble:lat withDouble:lon];
    jlong bytePos = (jlong) key * 4;
    if ([filledIndices containsWithInt:key]) {
      jint oldNodeId = [((id<DataAccess>) nil_chk(self->index_)) getIntWithLong:bytePos];
      [self->keyAlgo_ decodeWithLong:key withGHPoint:coord];
      jdouble distNew = [((id<DistanceCalc>) nil_chk(self->distCalc_)) calcNormalizedDistWithDouble:coord->lat_ withDouble:coord->lon_ withDouble:lat withDouble:lon];
      jdouble oldLat = [self->nodeAccess_ getLatitudeWithInt:oldNodeId];
      jdouble oldLon = [self->nodeAccess_ getLongitudeWithInt:oldNodeId];
      jdouble distOld = [self->distCalc_ calcNormalizedDistWithDouble:coord->lat_ withDouble:coord->lon_ withDouble:oldLat withDouble:oldLon];
      if (distNew < distOld) {
        [self->index_ setIntWithLong:bytePos withInt:nodeId];
      }
    }
    else {
      [((id<DataAccess>) nil_chk(self->index_)) setIntWithLong:bytePos withInt:nodeId];
      [filledIndices addWithInt:key];
    }
  }
  return filledIndices;
}

jint Location2IDQuadtree_fillEmptyIndicesWithGHBitSet_(Location2IDQuadtree *self, id<GHBitSet> filledIndices) {
  jint len = self->latSize_ * self->lonSize_;
  id<DataAccess> indexCopy = [((RAMDirectory *) [[[RAMDirectory alloc] init] autorelease]) findWithNSString:@"temp_index_copy"];
  [((id<DataAccess>) nil_chk([((id<DataAccess>) nil_chk(indexCopy)) setSegmentSizeWithInt:[((id<DataAccess>) nil_chk(self->index_)) getSegmentSize]])) createWithLong:[self->index_ getCapacity]];
  id<GHBitSet> indicesCopy = [[[GHBitSetImpl alloc] initWithInt:len] autorelease];
  jint initializedCounter = [((id<GHBitSet>) nil_chk(filledIndices)) getCardinality];
  IOSIntArray *takenFrom = [IOSIntArray arrayWithLength:len];
  JavaUtilArrays_fillWithIntArray_withInt_(takenFrom, -1);
  for (jint i = [filledIndices nextWithInt:0]; i >= 0; i = [filledIndices nextWithInt:i + 1]) {
    *IOSIntArray_GetRef(takenFrom, i) = i;
  }
  if (initializedCounter == 0) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"at least one entry has to be != null, which should have happened in initIndex"] autorelease];
  }
  jint tmp = initializedCounter;
  while (initializedCounter < len) {
    [self->index_ copyToWithDataAccess:indexCopy];
    [filledIndices copyToWithGHBitSet:indicesCopy];
    initializedCounter = [filledIndices getCardinality];
    for (jint i = 0; i < len; i++) {
      jint to = -1, from = -1;
      if ([indicesCopy containsWithInt:i]) {
        if ((i + 1) % self->lonSize_ != 0 && ![indicesCopy containsWithInt:i + 1]) {
          from = i;
          to = i + 1;
        }
        else if (i + self->lonSize_ < len && ![indicesCopy containsWithInt:i + self->lonSize_]) {
          from = i;
          to = i + self->lonSize_;
        }
      }
      else if ((i + 1) % self->lonSize_ != 0 && [indicesCopy containsWithInt:i + 1]) {
        from = i + 1;
        to = i;
      }
      else if (i + self->lonSize_ < len && [indicesCopy containsWithInt:i + self->lonSize_]) {
        from = i + self->lonSize_;
        to = i;
      }
      if (to >= 0) {
        if (IOSIntArray_Get(takenFrom, to) >= 0) {
          if (IOSIntArray_Get(takenFrom, to) == to || [self getNormedDistWithInt:from withInt:to] >= [self getNormedDistWithInt:IOSIntArray_Get(takenFrom, to) withInt:to]) {
            continue;
          }
        }
        [self->index_ setIntWithLong:to * 4 withInt:[indexCopy getIntWithLong:from * 4]];
        *IOSIntArray_GetRef(takenFrom, to) = IOSIntArray_Get(takenFrom, from);
        [filledIndices addWithInt:to];
        initializedCounter++;
      }
    }
  }
  return initializedCounter - tmp;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(Location2IDQuadtree)

@implementation Location2IDQuadtree_$1

- (id<GHBitSet>)createBitSet {
  return [[[GHTBitSet alloc] initWithInt:10] autorelease];
}

- (jboolean)goFurtherWithInt:(jint)baseNode {
  if (baseNode == val$id_) return YES;
  [this$0_ goFurtherHookWithInt:baseNode];
  jdouble currLat = [((id<NodeAccess>) nil_chk(this$0_->nodeAccess_)) getLatitudeWithInt:baseNode];
  jdouble currLon = [this$0_->nodeAccess_ getLongitudeWithInt:baseNode];
  jdouble currNormedDist = [((id<DistanceCalc>) nil_chk(this$0_->distCalc_)) calcNormalizedDistWithDouble:val$queryLat_ withDouble:val$queryLon_ withDouble:currLat withDouble:currLon];
  if (currNormedDist < [((QueryResult *) nil_chk(val$res_)) getQueryDistance]) {
    [val$res_ setQueryDistanceWithDouble:currNormedDist];
    [val$res_ setClosestNodeWithInt:baseNode];
    return YES;
  }
  return currNormedDist < this$0_->maxRasterWidth2InMeterNormed_;
}

- (instancetype)initWithLocation2IDQuadtree:(Location2IDQuadtree *)outer$
                                    withInt:(jint)capture$0
                                 withDouble:(jdouble)capture$1
                                 withDouble:(jdouble)capture$2
                            withQueryResult:(QueryResult *)capture$3 {
  Location2IDQuadtree_$1_set_this$0_(self, outer$);
  val$id_ = capture$0;
  val$queryLat_ = capture$1;
  val$queryLon_ = capture$2;
  Location2IDQuadtree_$1_set_val$res_(self, capture$3);
  return [super init];
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(val$res_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(Location2IDQuadtree_$1 *)other {
  [super copyAllFieldsTo:other];
  Location2IDQuadtree_$1_set_this$0_(other, this$0_);
  other->val$id_ = val$id_;
  other->val$queryLat_ = val$queryLat_;
  other->val$queryLon_ = val$queryLon_;
  Location2IDQuadtree_$1_set_val$res_(other, val$res_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "createBitSet", NULL, "Lcom.graphhopper.coll.GHBitSet;", 0x4, NULL },
    { "goFurtherWithInt:", "goFurther", "Z", 0x4, NULL },
    { "initWithLocation2IDQuadtree:withInt:withDouble:withDouble:withQueryResult:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lcom.graphhopper.storage.index.Location2IDQuadtree;", NULL,  },
    { "val$id_", NULL, 0x1012, "I", NULL,  },
    { "val$queryLat_", NULL, 0x1012, "D", NULL,  },
    { "val$queryLon_", NULL, 0x1012, "D", NULL,  },
    { "val$res_", NULL, 0x1012, "Lcom.graphhopper.storage.index.QueryResult;", NULL,  },
  };
  static const J2ObjcClassInfo _Location2IDQuadtree_$1 = { 1, "$1", "com.graphhopper.storage.index", "Location2IDQuadtree", 0x8000, 3, methods, 5, fields, 0, NULL};
  return &_Location2IDQuadtree_$1;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(Location2IDQuadtree_$1)
