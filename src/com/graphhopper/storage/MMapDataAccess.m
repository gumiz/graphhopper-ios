//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/storage/AbstractDataAccess.h"
#include "com/graphhopper/storage/DAType.h"
#include "com/graphhopper/storage/DataAccess.h"
#include "com/graphhopper/storage/MMapDataAccess.h"
#include "com/graphhopper/util/Constants.h"
#include "com/graphhopper/util/Helper.h"
#include "java/io/File.h"
#include "java/io/FileDescriptor.h"
#include "java/io/IOException.h"
#include "java/io/RandomAccessFile.h"
#include "java/lang/AssertionError.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/IllegalThreadStateException.h"
#include "java/lang/InterruptedException.h"
#include "java/lang/Math.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/Thread.h"
#include "java/nio/Buffer.h"
#include "java/nio/ByteBuffer.h"
#include "java/nio/ByteOrder.h"
#include "java/nio/MappedByteBuffer.h"
#include "java/nio/channels/FileChannel.h"
#include "java/util/ArrayList.h"
#include "java/util/List.h"

__attribute__((unused)) static void MMapDataAccess_initRandomAccessFile(MMapDataAccess *self);
__attribute__((unused)) static JavaNioByteBuffer *MMapDataAccess_newByteBufferWithLong_withLong_(MMapDataAccess *self, jlong offset, jlong byteCount);
__attribute__((unused)) static void MMapDataAccess_cleanWithInt_withInt_(MMapDataAccess *self, jint from, jint to);

@interface MMapDataAccess () {
 @public
  jboolean allowWrites_;
  JavaIoRandomAccessFile *raFile_;
  id<JavaUtilList> segments_;
  jboolean cleanAndRemap__;
}

- (void)initRandomAccessFile OBJC_METHOD_FAMILY_NONE;

- (JavaNioByteBuffer *)newByteBufferWithLong:(jlong)offset
                                    withLong:(jlong)byteCount OBJC_METHOD_FAMILY_NONE;

/**
 @brief Cleans up MappedByteBuffers.
 Be sure you bring the segments list in a consistent state afterwards. <p>
 @param from inclusive
 @param to exclusive
 */
- (void)cleanWithInt:(jint)from
             withInt:(jint)to;
@end

J2OBJC_FIELD_SETTER(MMapDataAccess, raFile_, JavaIoRandomAccessFile *)
J2OBJC_FIELD_SETTER(MMapDataAccess, segments_, id<JavaUtilList>)

@implementation MMapDataAccess

- (instancetype)initWithNSString:(NSString *)name
                    withNSString:(NSString *)location
            withJavaNioByteOrder:(JavaNioByteOrder *)order
                     withBoolean:(jboolean)allowWrites {
  if (self = [super initWithNSString:name withNSString:location withJavaNioByteOrder:order]) {
    MMapDataAccess_setAndConsume_segments_(self, [[JavaUtilArrayList alloc] init]);
    cleanAndRemap__ = NO;
    self->allowWrites_ = allowWrites;
  }
  return self;
}

- (MMapDataAccess *)cleanAndRemapWithBoolean:(jboolean)cleanAndRemap {
  self->cleanAndRemap__ = cleanAndRemap;
  return self;
}

- (void)initRandomAccessFile {
  MMapDataAccess_initRandomAccessFile(self);
}

- (MMapDataAccess *)createWithLong:(jlong)bytes {
  if (![((id<JavaUtilList>) nil_chk(segments_)) isEmpty]) {
    @throw [[[JavaLangIllegalThreadStateException alloc] initWithNSString:@"already created"] autorelease];
  }
  MMapDataAccess_initRandomAccessFile(self);
  bytes = JavaLangMath_maxWithLong_withLong_(10 * 4, bytes);
  [self setSegmentSizeWithInt:segmentSizeInBytes_];
  [self ensureCapacityWithLong:bytes];
  return self;
}

- (id<DataAccess>)copyToWithDataAccess:(id<DataAccess>)da {
  return [super copyToWithDataAccess:da];
}

- (jboolean)ensureCapacityWithLong:(jlong)bytes {
  return [self mapItWithLong:AbstractDataAccess_HEADER_OFFSET withLong:bytes withBoolean:YES];
}

- (jboolean)mapItWithLong:(jlong)offset
                 withLong:(jlong)byteCount
              withBoolean:(jboolean)clearNew {
  if (byteCount < 0) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"new capacity has to be strictly positive"] autorelease];
  if (byteCount <= [self getCapacity]) return NO;
  jlong longSegmentSize = segmentSizeInBytes_;
  jint segmentsToMap = (jint) (byteCount / longSegmentSize);
  if (segmentsToMap < 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Too many segments needs to be allocated. Increase segmentSize."] autorelease];
  if (byteCount % longSegmentSize != 0) segmentsToMap++;
  if (segmentsToMap == 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"0 segments are not allowed."] autorelease];
  jlong bufferStart = offset;
  jint newSegments;
  jint i = 0;
  jlong newFileLength = offset + segmentsToMap * longSegmentSize;
  @try {
    if (cleanAndRemap__) {
      newSegments = segmentsToMap;
      MMapDataAccess_cleanWithInt_withInt_(self, 0, [((id<JavaUtilList>) nil_chk(segments_)) size]);
      Helper_cleanHack();
      [segments_ clear];
    }
    else {
      bufferStart += [((id<JavaUtilList>) nil_chk(segments_)) size] * longSegmentSize;
      newSegments = segmentsToMap - [segments_ size];
    }
    for (; i < newSegments; i++) {
      [((id<JavaUtilList>) nil_chk(segments_)) addWithId:MMapDataAccess_newByteBufferWithLong_withLong_(self, bufferStart, longSegmentSize)];
      bufferStart += longSegmentSize;
    }
    return YES;
  }
  @catch (JavaIoIOException *ex) {
    @throw [[[JavaLangRuntimeException alloc] initWithNSString:JreStrcat("$I$I$$$J$J$J$J", @"Couldn't map buffer ", i, @" of ", segmentsToMap, @" for ", name_, @" at position ", bufferStart, @" for ", byteCount, @" bytes with offset ", offset, @", new fileLength:", newFileLength) withJavaLangThrowable:ex] autorelease];
  }
}

- (JavaNioByteBuffer *)newByteBufferWithLong:(jlong)offset
                                    withLong:(jlong)byteCount {
  return MMapDataAccess_newByteBufferWithLong_withLong_(self, offset, byteCount);
}

- (jboolean)loadExisting {
  if ([((id<JavaUtilList>) nil_chk(segments_)) size] > 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"already initialized"] autorelease];
  if ([self isClosed]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"already closed"] autorelease];
  JavaIoFile *file = [[[JavaIoFile alloc] initWithNSString:[self getFullName]] autorelease];
  if (![file exists] || [file length] == 0) return NO;
  MMapDataAccess_initRandomAccessFile(self);
  @try {
    jlong byteCount = [self readHeaderWithJavaIoRandomAccessFile:raFile_];
    if (byteCount < 0) return NO;
    [self mapItWithLong:AbstractDataAccess_HEADER_OFFSET withLong:byteCount - AbstractDataAccess_HEADER_OFFSET withBoolean:NO];
    return YES;
  }
  @catch (JavaIoIOException *ex) {
    @throw [[[JavaLangRuntimeException alloc] initWithNSString:JreStrcat("$$", @"Problem while loading ", [self getFullName]) withJavaLangThrowable:ex] autorelease];
  }
}

- (void)flush {
  if ([self isClosed]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"already closed"] autorelease];
  @try {
    if (![((id<JavaUtilList>) nil_chk(segments_)) isEmpty] && [[segments_ getWithInt:0] isKindOfClass:[JavaNioMappedByteBuffer class]]) {
      for (JavaNioByteBuffer * __strong bb in segments_) {
        [((JavaNioMappedByteBuffer *) nil_chk(((JavaNioMappedByteBuffer *) check_class_cast(bb, [JavaNioMappedByteBuffer class])))) force];
      }
    }
    [self writeHeaderWithJavaIoRandomAccessFile:raFile_ withLong:[((JavaIoRandomAccessFile *) nil_chk(raFile_)) length] withInt:segmentSizeInBytes_];
    [((JavaIoFileDescriptor *) nil_chk([raFile_ getFD])) sync];
  }
  @catch (JavaLangException *ex) {
    @throw [[[JavaLangRuntimeException alloc] initWithJavaLangThrowable:ex] autorelease];
  }
}

- (void)close {
  [super close];
  [self closeWithBoolean:YES];
}

- (void)closeWithBoolean:(jboolean)forceClean {
  MMapDataAccess_cleanWithInt_withInt_(self, 0, [((id<JavaUtilList>) nil_chk(segments_)) size]);
  [segments_ clear];
  Helper_closeWithJavaIoCloseable_(raFile_);
  if (forceClean) Helper_cleanHack();
}

- (void)setIntWithLong:(jlong)bytePos
               withInt:(jint)value {
  jint bufferIndex = (jint) (RShift64(bytePos, segmentSizePower_));
  jint index = (jint) (bytePos & indexDivisor_);
  [((JavaNioByteBuffer *) nil_chk([((id<JavaUtilList>) nil_chk(segments_)) getWithInt:bufferIndex])) putIntWithInt:index withInt:value];
}

- (jint)getIntWithLong:(jlong)bytePos {
  jint bufferIndex = (jint) (RShift64(bytePos, segmentSizePower_));
  jint index = (jint) (bytePos & indexDivisor_);
  return [((JavaNioByteBuffer *) nil_chk([((id<JavaUtilList>) nil_chk(segments_)) getWithInt:bufferIndex])) getIntWithInt:index];
}

- (void)setShortWithLong:(jlong)bytePos
               withShort:(jshort)value {
  jint bufferIndex = (jint) (URShift64(bytePos, segmentSizePower_));
  jint index = (jint) (bytePos & indexDivisor_);
  [((JavaNioByteBuffer *) nil_chk([((id<JavaUtilList>) nil_chk(segments_)) getWithInt:bufferIndex])) putShortWithInt:index withShort:value];
}

- (jshort)getShortWithLong:(jlong)bytePos {
  jint bufferIndex = (jint) (URShift64(bytePos, segmentSizePower_));
  jint index = (jint) (bytePos & indexDivisor_);
  return [((JavaNioByteBuffer *) nil_chk([((id<JavaUtilList>) nil_chk(segments_)) getWithInt:bufferIndex])) getShortWithInt:index];
}

- (void)setBytesWithLong:(jlong)bytePos
           withByteArray:(IOSByteArray *)values
                 withInt:(jint)length {
  NSAssert(length <= segmentSizeInBytes_, [JreStrcat("$I$I" J2OBJC_COMMA() @"the length has to be smaller or equal to the segment size: " J2OBJC_COMMA() length J2OBJC_COMMA() @" vs. " J2OBJC_COMMA() segmentSizeInBytes_) description]);
  jint bufferIndex = (jint) (URShift64(bytePos, segmentSizePower_));
  jint index = (jint) (bytePos & indexDivisor_);
  JavaNioByteBuffer *bb = [((id<JavaUtilList>) nil_chk(segments_)) getWithInt:bufferIndex];
  [((JavaNioByteBuffer *) nil_chk(bb)) positionWithInt:index];
  jint delta = index + length - segmentSizeInBytes_;
  if (delta > 0) {
    length -= delta;
    [bb putWithByteArray:values withInt:0 withInt:length];
    bb = [segments_ getWithInt:bufferIndex + 1];
    [((JavaNioByteBuffer *) nil_chk(bb)) positionWithInt:0];
    [bb putWithByteArray:values withInt:length withInt:delta];
  }
  else {
    [bb putWithByteArray:values withInt:0 withInt:length];
  }
}

- (void)getBytesWithLong:(jlong)bytePos
           withByteArray:(IOSByteArray *)values
                 withInt:(jint)length {
  NSAssert(length <= segmentSizeInBytes_, [JreStrcat("$I$I" J2OBJC_COMMA() @"the length has to be smaller or equal to the segment size: " J2OBJC_COMMA() length J2OBJC_COMMA() @" vs. " J2OBJC_COMMA() segmentSizeInBytes_) description]);
  jint bufferIndex = (jint) (URShift64(bytePos, segmentSizePower_));
  jint index = (jint) (bytePos & indexDivisor_);
  JavaNioByteBuffer *bb = [((id<JavaUtilList>) nil_chk(segments_)) getWithInt:bufferIndex];
  [((JavaNioByteBuffer *) nil_chk(bb)) positionWithInt:index];
  jint delta = index + length - segmentSizeInBytes_;
  if (delta > 0) {
    length -= delta;
    [bb getWithByteArray:values withInt:0 withInt:length];
    bb = [segments_ getWithInt:bufferIndex + 1];
    [((JavaNioByteBuffer *) nil_chk(bb)) positionWithInt:0];
    [bb getWithByteArray:values withInt:length withInt:delta];
  }
  else {
    [bb getWithByteArray:values withInt:0 withInt:length];
  }
}

- (jlong)getCapacity {
  jlong cap = 0;
  for (JavaNioByteBuffer * __strong bb in nil_chk(segments_)) {
    cap += [((JavaNioByteBuffer *) nil_chk(bb)) capacity];
  }
  return cap;
}

- (jint)getSegments {
  return [((id<JavaUtilList>) nil_chk(segments_)) size];
}

- (void)cleanWithInt:(jint)from
             withInt:(jint)to {
  MMapDataAccess_cleanWithInt_withInt_(self, from, to);
}

- (void)trimToWithLong:(jlong)capacity {
  if (capacity < segmentSizeInBytes_) {
    capacity = segmentSizeInBytes_;
  }
  jint remainingSegNo = (jint) (capacity / segmentSizeInBytes_);
  if (capacity % segmentSizeInBytes_ != 0) {
    remainingSegNo++;
  }
  MMapDataAccess_cleanWithInt_withInt_(self, remainingSegNo, [((id<JavaUtilList>) nil_chk(segments_)) size]);
  Helper_cleanHack();
  MMapDataAccess_setAndConsume_segments_(self, [[JavaUtilArrayList alloc] initWithJavaUtilCollection:[segments_ subListWithInt:0 withInt:remainingSegNo]]);
  @try {
    if (!Constants_get_WINDOWS_()) {
      [((JavaIoRandomAccessFile *) nil_chk(raFile_)) setLengthWithLong:AbstractDataAccess_HEADER_OFFSET + remainingSegNo * segmentSizeInBytes_];
    }
  }
  @catch (JavaLangException *ex) {
    @throw [[[JavaLangRuntimeException alloc] initWithJavaLangThrowable:ex] autorelease];
  }
}

- (jboolean)releaseSegmentWithInt:(jint)segNumber {
  JavaNioByteBuffer *segment = [((id<JavaUtilList>) nil_chk(segments_)) getWithInt:segNumber];
  if ([segment isKindOfClass:[JavaNioMappedByteBuffer class]]) {
    [((JavaNioMappedByteBuffer *) nil_chk(((JavaNioMappedByteBuffer *) check_class_cast(segment, [JavaNioMappedByteBuffer class])))) force];
  }
  Helper_cleanMappedByteBufferWithJavaNioByteBuffer_(segment);
  [segments_ setWithInt:segNumber withId:nil];
  Helper_cleanHack();
  return YES;
}

- (void)renameWithNSString:(NSString *)newName {
  if (![self checkBeforeRenameWithNSString:newName]) {
    return;
  }
  [self close];
  [super renameWithNSString:newName];
  MMapDataAccess_set_raFile_(self, nil);
  closed_ = NO;
  [self loadExisting];
}

- (DAType *)getType {
  return DAType_get_MMAP_();
}

- (void)dealloc {
  RELEASE_(raFile_);
  RELEASE_(segments_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(MMapDataAccess *)other {
  [super copyAllFieldsTo:other];
  other->allowWrites_ = allowWrites_;
  MMapDataAccess_set_raFile_(other, raFile_);
  MMapDataAccess_set_segments_(other, segments_);
  other->cleanAndRemap__ = cleanAndRemap__;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithNSString:withNSString:withJavaNioByteOrder:withBoolean:", "MMapDataAccess", NULL, 0x0, NULL },
    { "cleanAndRemapWithBoolean:", "cleanAndRemap", "Lcom.graphhopper.storage.MMapDataAccess;", 0x0, NULL },
    { "initRandomAccessFile", NULL, "V", 0x2, NULL },
    { "createWithLong:", "create", "Lcom.graphhopper.storage.MMapDataAccess;", 0x1, NULL },
    { "copyToWithDataAccess:", "copyTo", "Lcom.graphhopper.storage.DataAccess;", 0x1, NULL },
    { "ensureCapacityWithLong:", "ensureCapacity", "Z", 0x1, NULL },
    { "mapItWithLong:withLong:withBoolean:", "mapIt", "Z", 0x4, NULL },
    { "newByteBufferWithLong:withLong:", "newByteBuffer", "Ljava.nio.ByteBuffer;", 0x2, "Ljava.io.IOException;" },
    { "loadExisting", NULL, "Z", 0x1, NULL },
    { "flush", NULL, "V", 0x1, NULL },
    { "close", NULL, "V", 0x1, NULL },
    { "closeWithBoolean:", "close", "V", 0x0, NULL },
    { "setIntWithLong:withInt:", "setInt", "V", 0x11, NULL },
    { "getIntWithLong:", "getInt", "I", 0x11, NULL },
    { "setShortWithLong:withShort:", "setShort", "V", 0x11, NULL },
    { "getShortWithLong:", "getShort", "S", 0x11, NULL },
    { "setBytesWithLong:withByteArray:withInt:", "setBytes", "V", 0x1, NULL },
    { "getBytesWithLong:withByteArray:withInt:", "getBytes", "V", 0x1, NULL },
    { "getCapacity", NULL, "J", 0x1, NULL },
    { "getSegments", NULL, "I", 0x1, NULL },
    { "cleanWithInt:withInt:", "clean", "V", 0x2, NULL },
    { "trimToWithLong:", "trimTo", "V", 0x1, NULL },
    { "releaseSegmentWithInt:", "releaseSegment", "Z", 0x0, NULL },
    { "renameWithNSString:", "rename", "V", 0x1, NULL },
    { "getType", NULL, "Lcom.graphhopper.storage.DAType;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "allowWrites_", NULL, 0x12, "Z", NULL,  },
    { "raFile_", NULL, 0x2, "Ljava.io.RandomAccessFile;", NULL,  },
    { "segments_", NULL, 0x2, "Ljava.util.List;", NULL,  },
    { "cleanAndRemap__", "cleanAndRemap", 0x2, "Z", NULL,  },
  };
  static const J2ObjcClassInfo _MMapDataAccess = { 1, "MMapDataAccess", "com.graphhopper.storage", NULL, 0x1, 25, methods, 4, fields, 0, NULL};
  return &_MMapDataAccess;
}

@end

void MMapDataAccess_initRandomAccessFile(MMapDataAccess *self) {
  if (self->raFile_ != nil) {
    return;
  }
  @try {
    MMapDataAccess_setAndConsume_raFile_(self, [[JavaIoRandomAccessFile alloc] initWithNSString:[self getFullName] withNSString:self->allowWrites_ ? @"rw" : @"r"]);
  }
  @catch (JavaIoIOException *ex) {
    @throw [[[JavaLangRuntimeException alloc] initWithJavaLangThrowable:ex] autorelease];
  }
}

JavaNioByteBuffer *MMapDataAccess_newByteBufferWithLong_withLong_(MMapDataAccess *self, jlong offset, jlong byteCount) {
  JavaNioByteBuffer *buf = nil;
  JavaIoIOException *ioex = nil;
  for (jint trial = 0; trial < 1; ) {
    @try {
      buf = [((JavaNioChannelsFileChannel *) nil_chk([((JavaIoRandomAccessFile *) nil_chk(self->raFile_)) getChannel])) mapWithJavaNioChannelsFileChannel_MapMode:self->allowWrites_ ? JavaNioChannelsFileChannel_MapMode_get_READ_WRITE_() : JavaNioChannelsFileChannel_MapMode_get_READ_ONLY_() withLong:offset withLong:byteCount];
      break;
    }
    @catch (JavaIoIOException *tmpex) {
      ioex = tmpex;
      trial++;
      Helper_cleanHack();
      @try {
        JavaLangThread_sleepWithLong_(5);
      }
      @catch (JavaLangInterruptedException *iex) {
        @throw [[[JavaIoIOException alloc] initWithJavaLangThrowable:iex] autorelease];
      }
    }
  }
  if (buf == nil) {
    if (ioex == nil) {
      @throw [[[JavaLangAssertionError alloc] initWithId:@"internal problem as the exception 'ioex' shouldn't be null"] autorelease];
    }
    @throw ioex;
  }
  [((JavaNioByteBuffer *) nil_chk(buf)) orderWithJavaNioByteOrder:self->byteOrder_];
  jboolean tmp = NO;
  if (tmp) {
    jint count = (jint) (byteCount / ((IOSByteArray *) nil_chk(AbstractDataAccess_get_EMPTY_()))->size_);
    for (jint i = 0; i < count; i++) {
      [buf putWithByteArray:AbstractDataAccess_get_EMPTY_()];
    }
    jint len = (jint) (byteCount % AbstractDataAccess_get_EMPTY_()->size_);
    if (len > 0) {
      [buf putWithByteArray:AbstractDataAccess_get_EMPTY_() withInt:count * AbstractDataAccess_get_EMPTY_()->size_ withInt:len];
    }
  }
  return buf;
}

void MMapDataAccess_cleanWithInt_withInt_(MMapDataAccess *self, jint from, jint to) {
  for (jint i = from; i < to; i++) {
    JavaNioByteBuffer *bb = [((id<JavaUtilList>) nil_chk(self->segments_)) getWithInt:i];
    Helper_cleanMappedByteBufferWithJavaNioByteBuffer_(bb);
    [self->segments_ setWithInt:i withId:nil];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(MMapDataAccess)
