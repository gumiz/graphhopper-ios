//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/storage/DataAccess.java
//

#ifndef _DataAccess_H_
#define _DataAccess_H_

@class DAType;
@class IOSByteArray;

#include "J2ObjC_header.h"
#include "com/graphhopper/storage/Storable.h"

/**
 @brief Abstraction of the underlying datastructure with a unique id and location.
 To ensure that the id is unique use a Directory.attach or findAttach, if you don't need uniqueness call Directory.create. Current implementations are RAM and memory mapped access. <p> Life cycle: (1) object creation, (2) configuration (e.g. segment size), (3) create or loadExisting, (4) usage and calling ensureCapacity if necessary, (5) close <p>
 @author Peter Karich
 */
@protocol DataAccess < Storable, NSObject, JavaObject >
/**
 @brief The logical identification of this object.
 */
- (NSString *)getName;

/**
 @brief Renames the underlying DataAccess object.
 (Flushing shouldn't be necessary before or afterwards) <p>
 @throws IllegalStateException if a rename is not possible
 */
- (void)renameWithNSString:(NSString *)newName;

/**
 @brief Set 4 bytes at position 'bytePos' to the specified value
 */
- (void)setIntWithLong:(jlong)bytePos
               withInt:(jint)value;

/**
 @brief Get 4 bytes from position 'bytePos'
 */
- (jint)getIntWithLong:(jlong)bytePos;

/**
 @brief Set 2 bytes at position 'index' to the specified value
 */
- (void)setShortWithLong:(jlong)bytePos
               withShort:(jshort)value;

/**
 @brief Get 2 bytes from position 'index'
 */
- (jshort)getShortWithLong:(jlong)bytePos;

/**
 @brief Set bytes from position 'index' to the specified values
 */
- (void)setBytesWithLong:(jlong)bytePos
           withByteArray:(IOSByteArray *)values
                 withInt:(jint)length;

/**
 @brief Get bytes from position 'index' <p>
 @param values acts as output
 */
- (void)getBytesWithLong:(jlong)bytePos
           withByteArray:(IOSByteArray *)values
                 withInt:(jint)length;

/**
 @brief Set 4 bytes at the header space index to the specified value
 */
- (void)setHeaderWithInt:(jint)bytePos
                 withInt:(jint)value;

/**
 @brief Get 4 bytes from the header at 'index'
 */
- (jint)getHeaderWithInt:(jint)bytePos;

/**
 @brief The first time you use a DataAccess object after configuring it you need to call this.
 After that first call you have to use ensureCapacity to ensure that enough space is reserved.
 */
- (id<DataAccess>)createWithLong:(jlong)bytes;

/**
 @brief Ensures that the capacity of this object is at least the specified bytes.
 The first time you have to call 'create' instead. <p>
 @return true if size was increased
 */
- (jboolean)ensureCapacityWithLong:(jlong)bytes;

/**
 @brief Reduces the allocate space to the specified bytes.
 Warning: it'll free the space even if it is in use!
 */
- (void)trimToWithLong:(jlong)bytes;

/**
 @brief Copies the content from this object into the specified one.
 */
- (id<DataAccess>)copyToWithDataAccess:(id<DataAccess>)da OBJC_METHOD_FAMILY_NONE;

/**
 @return the size of one segment in bytes
 */
- (jint)getSegmentSize;

/**
 @brief In order to increase allocated space one needs to layout the underlying storage in segments.
 This is how you can customize the size.
 */
- (id<DataAccess>)setSegmentSizeWithInt:(jint)bytes;

/**
 @return the number of segments.
 */
- (jint)getSegments;

/**
 @return the data access type of this object.
 */
- (DAType *)getType;

@end

J2OBJC_EMPTY_STATIC_INIT(DataAccess)

#define ComGraphhopperStorageDataAccess DataAccess

J2OBJC_TYPE_LITERAL_HEADER(DataAccess)

#endif // _DataAccess_H_
