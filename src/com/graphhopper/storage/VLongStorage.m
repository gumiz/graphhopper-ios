//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/storage/VLongStorage.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/storage/VLongStorage.h"
#include "java/lang/Math.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/System.h"
#include "java/util/Arrays.h"

@interface VLongStorage () {
 @public
  IOSByteArray *bytes_;
  jint pointer_;
}
@end

J2OBJC_FIELD_SETTER(VLongStorage, bytes_, IOSByteArray *)

@implementation VLongStorage

- (instancetype)init {
  return [self initVLongStorageWithInt:10];
}

- (instancetype)initVLongStorageWithInt:(jint)cap {
  return [self initVLongStorageWithByteArray:[IOSByteArray arrayWithLength:cap]];
}

- (instancetype)initWithInt:(jint)cap {
  return [self initVLongStorageWithInt:cap];
}

- (instancetype)initVLongStorageWithByteArray:(IOSByteArray *)bytes {
  if (self = [super init]) {
    pointer_ = 0;
    VLongStorage_set_bytes_(self, bytes);
  }
  return self;
}

- (instancetype)initWithByteArray:(IOSByteArray *)bytes {
  return [self initVLongStorageWithByteArray:bytes];
}

- (void)seekWithLong:(jlong)pos {
  pointer_ = (jint) pos;
}

- (jlong)getPosition {
  return pointer_;
}

- (jlong)getLength {
  return ((IOSByteArray *) nil_chk(bytes_))->size_;
}

- (jbyte)readByte {
  jbyte b = IOSByteArray_Get(nil_chk(bytes_), pointer_);
  pointer_++;
  return b;
}

- (void)writeByteWithByte:(jbyte)b {
  if (pointer_ >= ((IOSByteArray *) nil_chk(bytes_))->size_) {
    jint cap = JavaLangMath_maxWithInt_withInt_(10, J2ObjCFpToInt((pointer_ * 1.5f)));
    VLongStorage_set_bytes_(self, JavaUtilArrays_copyOfWithByteArray_withInt_(bytes_, cap));
  }
  *IOSByteArray_GetRef(nil_chk(bytes_), pointer_) = b;
  pointer_++;
}

- (void)writeVLongWithLong:(jlong)i {
  NSAssert(i >= 0LL, @"com/graphhopper/storage/VLongStorage.java:75 condition failed: assert i >= 0L;");
  while ((i & ~(jlong) 0x7FLL) != 0LL) {
    [self writeByteWithByte:(jbyte) ((i & (jlong) 0x7FLL) | (jlong) 0x80LL)];
    URShiftAssignLong(&i, 7);
  }
  [self writeByteWithByte:(jbyte) i];
}

- (jlong)readVLong {
  jbyte b = [self readByte];
  if (b >= 0) {
    return b;
  }
  jlong i = b & (jlong) 0x7FLL;
  b = [self readByte];
  i |= LShift64((b & (jlong) 0x7FLL), 7);
  if (b >= 0) {
    return i;
  }
  b = [self readByte];
  i |= LShift64((b & (jlong) 0x7FLL), 14);
  if (b >= 0) {
    return i;
  }
  b = [self readByte];
  i |= LShift64((b & (jlong) 0x7FLL), 21);
  if (b >= 0) {
    return i;
  }
  b = [self readByte];
  i |= LShift64((b & (jlong) 0x7FLL), 28);
  if (b >= 0) {
    return i;
  }
  b = [self readByte];
  i |= LShift64((b & (jlong) 0x7FLL), 35);
  if (b >= 0) {
    return i;
  }
  b = [self readByte];
  i |= LShift64((b & (jlong) 0x7FLL), 42);
  if (b >= 0) {
    return i;
  }
  b = [self readByte];
  i |= LShift64((b & (jlong) 0x7FLL), 49);
  if (b >= 0) {
    return i;
  }
  b = [self readByte];
  i |= LShift64((b & (jlong) 0x7FLL), 56);
  if (b >= 0) {
    return i;
  }
  @throw [[[JavaLangRuntimeException alloc] initWithNSString:@"Invalid vLong detected (negative values disallowed)"] autorelease];
}

- (void)trimToSize {
  if (((IOSByteArray *) nil_chk(bytes_))->size_ > pointer_) {
    IOSByteArray *tmp = [IOSByteArray arrayWithLength:pointer_];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(bytes_, 0, tmp, 0, pointer_);
    VLongStorage_set_bytes_(self, tmp);
  }
}

- (IOSByteArray *)getBytes {
  return bytes_;
}

- (void)dealloc {
  RELEASE_(bytes_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(VLongStorage *)other {
  [super copyAllFieldsTo:other];
  VLongStorage_set_bytes_(other, bytes_);
  other->pointer_ = pointer_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "VLongStorage", NULL, 0x1, NULL },
    { "initWithInt:", "VLongStorage", NULL, 0x1, NULL },
    { "initWithByteArray:", "VLongStorage", NULL, 0x1, NULL },
    { "seekWithLong:", "seek", "V", 0x1, NULL },
    { "getPosition", NULL, "J", 0x1, NULL },
    { "getLength", NULL, "J", 0x1, NULL },
    { "readByte", NULL, "B", 0x0, NULL },
    { "writeByteWithByte:", "writeByte", "V", 0x0, NULL },
    { "writeVLongWithLong:", "writeVLong", "V", 0x11, NULL },
    { "readVLong", NULL, "J", 0x1, NULL },
    { "trimToSize", NULL, "V", 0x1, NULL },
    { "getBytes", NULL, "[B", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "bytes_", NULL, 0x2, "[B", NULL,  },
    { "pointer_", NULL, 0x2, "I", NULL,  },
  };
  static const J2ObjcClassInfo _VLongStorage = { 1, "VLongStorage", "com.graphhopper.storage", NULL, 0x1, 12, methods, 2, fields, 0, NULL};
  return &_VLongStorage;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(VLongStorage)
