//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/storage/BaseGraph.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/coll/GHBitSet.h"
#include "com/graphhopper/coll/GHBitSetImpl.h"
#include "com/graphhopper/coll/SparseIntIntArray.h"
#include "com/graphhopper/routing/util/AllEdgesIterator.h"
#include "com/graphhopper/routing/util/EdgeFilter.h"
#include "com/graphhopper/routing/util/EncodingManager.h"
#include "com/graphhopper/routing/util/FlagEncoder.h"
#include "com/graphhopper/search/NameIndex.h"
#include "com/graphhopper/storage/BaseGraph.h"
#include "com/graphhopper/storage/DataAccess.h"
#include "com/graphhopper/storage/Directory.h"
#include "com/graphhopper/storage/EdgeAccess.h"
#include "com/graphhopper/storage/GHNodeAccess.h"
#include "com/graphhopper/storage/Graph.h"
#include "com/graphhopper/storage/GraphExtension.h"
#include "com/graphhopper/storage/InternalGraphEventListener.h"
#include "com/graphhopper/storage/NodeAccess.h"
#include "com/graphhopper/util/BitUtil.h"
#include "com/graphhopper/util/EdgeExplorer.h"
#include "com/graphhopper/util/EdgeIterator.h"
#include "com/graphhopper/util/EdgeIteratorState.h"
#include "com/graphhopper/util/GHUtility.h"
#include "com/graphhopper/util/Helper.h"
#include "com/graphhopper/util/PointList.h"
#include "com/graphhopper/util/shapes/BBox.h"
#include "java/lang/AssertionError.h"
#include "java/lang/Boolean.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/lang/RuntimeException.h"
#include "java/nio/ByteOrder.h"
#include "org/slf4j/Logger.h"
#include "org/slf4j/LoggerFactory.h"

#pragma clang diagnostic ignored "-Wprotocol"

__attribute__((unused)) static jboolean BaseGraph_isTestingEnabled();
__attribute__((unused)) static jint BaseGraph_nextEdgeEntryIndexWithInt_(BaseGraph *self, jint sizeInBytes);
__attribute__((unused)) static jint BaseGraph_nextNodeEntryIndexWithInt_(BaseGraph *self, jint sizeInBytes);
__attribute__((unused)) static void BaseGraph_initNodeAndEdgeEntrySize(BaseGraph *self);
__attribute__((unused)) static void BaseGraph_ensureNodeIndexWithInt_(BaseGraph *self, jint nodeIndex);
__attribute__((unused)) static void BaseGraph_checkAdjNodeBoundsWithInt_(BaseGraph *self, jint adjNode);
__attribute__((unused)) static void BaseGraph_setWayGeometry_WithPointList_withLong_withBoolean_(BaseGraph *self, PointList *pillarNodes, jlong edgePointer, jboolean reverse);
__attribute__((unused)) static void BaseGraph_setWayGeometryAtGeoRefWithPointList_withLong_withBoolean_withLong_(BaseGraph *self, PointList *pillarNodes, jlong edgePointer, jboolean reverse, jlong geoRef);
__attribute__((unused)) static IOSByteArray *BaseGraph_createWayGeometryBytesWithPointList_withBoolean_(BaseGraph *self, PointList *pillarNodes, jboolean reverse);
__attribute__((unused)) static PointList *BaseGraph_fetchWayGeometry_WithLong_withBoolean_withInt_withInt_withInt_(BaseGraph *self, jlong edgePointer, jboolean reverse, jint mode, jint baseNode, jint adjNode);
__attribute__((unused)) static void BaseGraph_setNameWithLong_withNSString_(BaseGraph *self, jlong edgePointer, NSString *name);
__attribute__((unused)) static void BaseGraph_ensureGeometryWithLong_withInt_(BaseGraph *self, jlong bytePos, jint byteLength);
__attribute__((unused)) static jlong BaseGraph_nextGeoRefWithInt_(BaseGraph *self, jint arrayLength);
__attribute__((unused)) static jint BaseGraph_CommonEdgeIterator_getBaseNode(BaseGraph_CommonEdgeIterator *self);
__attribute__((unused)) static jint BaseGraph_CommonEdgeIterator_getAdjNode(BaseGraph_CommonEdgeIterator *self);
__attribute__((unused)) static jdouble BaseGraph_CommonEdgeIterator_getDistance(BaseGraph_CommonEdgeIterator *self);
__attribute__((unused)) static jlong BaseGraph_CommonEdgeIterator_getDirectFlags(BaseGraph_CommonEdgeIterator *self);
__attribute__((unused)) static jint BaseGraph_CommonEdgeIterator_getAdditionalField(BaseGraph_CommonEdgeIterator *self);
__attribute__((unused)) static id<EdgeIteratorState> BaseGraph_CommonEdgeIterator_setAdditionalFieldWithInt_(BaseGraph_CommonEdgeIterator *self, jint value);
__attribute__((unused)) static void BaseGraph_EdgeIterable_setEdgeIdWithInt_(BaseGraph_EdgeIterable *self, jint edgeId);
__attribute__((unused)) static jboolean BaseGraph_EdgeIterable_init__WithInt_withInt_(BaseGraph_EdgeIterable *self, jint tmpEdgeId, jint expectedAdjNode);
__attribute__((unused)) static void BaseGraph_EdgeIterable__setBaseNodeWithInt_(BaseGraph_EdgeIterable *self, jint baseNode);
__attribute__((unused)) static jboolean BaseGraph_EdgeIterable_next(BaseGraph_EdgeIterable *self);
__attribute__((unused)) static jboolean BaseGraph_$1_isInBoundsWithInt_(BaseGraph_$1 *self, jint edgeId);

@interface BaseGraph () {
 @public
  id<DataAccess> wayGeometry_;
  id<Directory> dir_;
  id<InternalGraphEventListener> listener_;
  jboolean initialized_;
  /**
   @brief interval [0,n)
   */
  jint nodeCount_;
  id<GHBitSet> removedNodes_;
  jint edgeEntryIndex_, nodeEntryIndex_;
  jlong maxGeoRef_;
  jboolean frozen_;
}

+ (jboolean)isTestingEnabled;

- (void)setWayGeometry_WithPointList:(PointList *)pillarNodes
                            withLong:(jlong)edgePointer
                         withBoolean:(jboolean)reverse;

- (void)setWayGeometryAtGeoRefWithPointList:(PointList *)pillarNodes
                                   withLong:(jlong)edgePointer
                                withBoolean:(jboolean)reverse
                                   withLong:(jlong)geoRef;

- (IOSByteArray *)createWayGeometryBytesWithPointList:(PointList *)pillarNodes
                                          withBoolean:(jboolean)reverse;

- (PointList *)fetchWayGeometry_WithLong:(jlong)edgePointer
                             withBoolean:(jboolean)reverse
                                 withInt:(jint)mode
                                 withInt:(jint)baseNode
                                 withInt:(jint)adjNode;

- (void)setNameWithLong:(jlong)edgePointer
           withNSString:(NSString *)name;

- (void)ensureGeometryWithLong:(jlong)bytePos
                       withInt:(jint)byteLength;

- (jlong)nextGeoRefWithInt:(jint)arrayLength;
@end

J2OBJC_FIELD_SETTER(BaseGraph, wayGeometry_, id<DataAccess>)
J2OBJC_FIELD_SETTER(BaseGraph, dir_, id<Directory>)
J2OBJC_FIELD_SETTER(BaseGraph, listener_, id<InternalGraphEventListener>)
J2OBJC_FIELD_SETTER(BaseGraph, removedNodes_, id<GHBitSet>)

@interface BaseGraph_CommonEdgeIterator () {
 @public
  jlong cachedFlags_;
}
@end

@interface BaseGraph_AllEdgeIterator ()
- (instancetype)initWithBaseGraph:(BaseGraph *)baseGraph
                   withEdgeAccess:(EdgeAccess *)edgeAccess;
@end

@interface BaseGraph_$1 () {
 @public
  BaseGraph *this$0_;
  EncodingManager *val$encodingManager_;
}
@end

J2OBJC_FIELD_SETTER(BaseGraph_$1, this$0_, BaseGraph *)
J2OBJC_FIELD_SETTER(BaseGraph_$1, val$encodingManager_, EncodingManager *)

@implementation BaseGraph

- (instancetype)initWithDirectory:(id<Directory>)dir
              withEncodingManager:(EncodingManager *)encodingManager
                      withBoolean:(jboolean)withElevation
   withInternalGraphEventListener:(id<InternalGraphEventListener>)listener
               withGraphExtension:(id<GraphExtension>)extendedStorage {
  if (self = [super init]) {
    initialized_ = NO;
    frozen_ = NO;
    BaseGraph_set_dir_(self, dir);
    BaseGraph_set_encodingManager_(self, encodingManager);
    BaseGraph_set_bitUtil_(self, BitUtil_getWithJavaNioByteOrder_([((id<Directory>) nil_chk(dir)) getByteOrder]));
    BaseGraph_set_wayGeometry_(self, [dir findWithNSString:@"geometry"]);
    BaseGraph_setAndConsume_nameIndex_(self, [[NameIndex alloc] initWithDirectory:dir]);
    BaseGraph_set_nodes_(self, [dir findWithNSString:@"nodes"]);
    BaseGraph_set_edges_(self, [dir findWithNSString:@"edges"]);
    BaseGraph_set_listener_(self, listener);
    BaseGraph_setAndConsume_edgeAccess_(self, [[BaseGraph_$1 alloc] initWithBaseGraph:self withDataAccess:edges_ withBitUtil:bitUtil_ withEncodingManager:encodingManager]);
    BaseGraph_set_bounds_(self, BBox_createInverseWithBoolean_(withElevation));
    BaseGraph_setAndConsume_nodeAccess_(self, [[GHNodeAccess alloc] initWithBaseGraph:self withBoolean:withElevation]);
    BaseGraph_set_extStorage_(self, extendedStorage);
    [((id<GraphExtension>) nil_chk(self->extStorage_)) init__WithGraph:self withDirectory:dir];
  }
  return self;
}

+ (jboolean)isTestingEnabled {
  return BaseGraph_isTestingEnabled();
}

- (id<Graph>)getBaseGraph {
  return self;
}

- (void)checkInit {
  if (initialized_) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"You cannot configure this GraphStorage after calling create or loadExisting. Calling one of the methods twice is also not allowed."] autorelease];
}

- (jint)loadNodesHeader {
  nodeEntryBytes_ = [((id<DataAccess>) nil_chk(nodes_)) getHeaderWithInt:1 * 4];
  nodeCount_ = [nodes_ getHeaderWithInt:2 * 4];
  ((BBox *) nil_chk(bounds_))->minLon_ = Helper_intToDegreeWithInt_([nodes_ getHeaderWithInt:3 * 4]);
  bounds_->maxLon_ = Helper_intToDegreeWithInt_([nodes_ getHeaderWithInt:4 * 4]);
  bounds_->minLat_ = Helper_intToDegreeWithInt_([nodes_ getHeaderWithInt:5 * 4]);
  bounds_->maxLat_ = Helper_intToDegreeWithInt_([nodes_ getHeaderWithInt:6 * 4]);
  if ([bounds_ hasElevation]) {
    bounds_->minEle_ = Helper_intToEleWithInt_([nodes_ getHeaderWithInt:7 * 4]);
    bounds_->maxEle_ = Helper_intToEleWithInt_([nodes_ getHeaderWithInt:8 * 4]);
  }
  frozen_ = ([nodes_ getHeaderWithInt:9 * 4] == 1);
  return 10;
}

- (jint)setNodesHeader {
  [((id<DataAccess>) nil_chk(nodes_)) setHeaderWithInt:1 * 4 withInt:nodeEntryBytes_];
  [nodes_ setHeaderWithInt:2 * 4 withInt:nodeCount_];
  [nodes_ setHeaderWithInt:3 * 4 withInt:Helper_degreeToIntWithDouble_(((BBox *) nil_chk(bounds_))->minLon_)];
  [nodes_ setHeaderWithInt:4 * 4 withInt:Helper_degreeToIntWithDouble_(bounds_->maxLon_)];
  [nodes_ setHeaderWithInt:5 * 4 withInt:Helper_degreeToIntWithDouble_(bounds_->minLat_)];
  [nodes_ setHeaderWithInt:6 * 4 withInt:Helper_degreeToIntWithDouble_(bounds_->maxLat_)];
  if ([bounds_ hasElevation]) {
    [nodes_ setHeaderWithInt:7 * 4 withInt:Helper_eleToIntWithDouble_(bounds_->minEle_)];
    [nodes_ setHeaderWithInt:8 * 4 withInt:Helper_eleToIntWithDouble_(bounds_->maxEle_)];
  }
  [nodes_ setHeaderWithInt:9 * 4 withInt:[self isFrozen] ? 1 : 0];
  return 10;
}

- (jint)loadEdgesHeader {
  edgeEntryBytes_ = [((id<DataAccess>) nil_chk(edges_)) getHeaderWithInt:0 * 4];
  edgeCount_ = [edges_ getHeaderWithInt:1 * 4];
  return 5;
}

- (jint)setEdgesHeader {
  [((id<DataAccess>) nil_chk(edges_)) setHeaderWithInt:0 withInt:edgeEntryBytes_];
  [edges_ setHeaderWithInt:1 * 4 withInt:edgeCount_];
  [edges_ setHeaderWithInt:2 * 4 withInt:((jint) [((EncodingManager *) nil_chk(encodingManager_)) hash])];
  [edges_ setHeaderWithInt:3 * 4 withInt:((jint) [((id<GraphExtension>) nil_chk(extStorage_)) hash])];
  return 5;
}

- (jint)loadWayGeometryHeader {
  maxGeoRef_ = [((BitUtil *) nil_chk(bitUtil_)) combineIntsToLongWithInt:[((id<DataAccess>) nil_chk(wayGeometry_)) getHeaderWithInt:0] withInt:[wayGeometry_ getHeaderWithInt:4]];
  return 1;
}

- (jint)setWayGeometryHeader {
  [((id<DataAccess>) nil_chk(wayGeometry_)) setHeaderWithInt:0 withInt:[((BitUtil *) nil_chk(bitUtil_)) getIntLowWithLong:maxGeoRef_]];
  [wayGeometry_ setHeaderWithInt:4 withInt:[bitUtil_ getIntHighWithLong:maxGeoRef_]];
  return 1;
}

- (void)initStorage {
  edgeEntryIndex_ = 0;
  nodeEntryIndex_ = 0;
  jboolean flagsSizeIsLong = [((EncodingManager *) nil_chk(encodingManager_)) getBytesForFlags] == 8;
  [((EdgeAccess *) nil_chk(edgeAccess_)) init__WithInt:BaseGraph_nextEdgeEntryIndexWithInt_(self, 4) withInt:BaseGraph_nextEdgeEntryIndexWithInt_(self, 4) withInt:BaseGraph_nextEdgeEntryIndexWithInt_(self, 4) withInt:BaseGraph_nextEdgeEntryIndexWithInt_(self, 4) withInt:BaseGraph_nextEdgeEntryIndexWithInt_(self, 4) withInt:BaseGraph_nextEdgeEntryIndexWithInt_(self, [encodingManager_ getBytesForFlags]) withBoolean:flagsSizeIsLong];
  E_GEO_ = BaseGraph_nextEdgeEntryIndexWithInt_(self, 4);
  E_NAME_ = BaseGraph_nextEdgeEntryIndexWithInt_(self, 4);
  if ([((id<GraphExtension>) nil_chk(extStorage_)) isRequireEdgeField]) E_ADDITIONAL_ = BaseGraph_nextEdgeEntryIndexWithInt_(self, 4);
  else E_ADDITIONAL_ = -1;
  N_EDGE_REF_ = BaseGraph_nextNodeEntryIndexWithInt_(self, 4);
  N_LAT_ = BaseGraph_nextNodeEntryIndexWithInt_(self, 4);
  N_LON_ = BaseGraph_nextNodeEntryIndexWithInt_(self, 4);
  if ([((id<NodeAccess>) nil_chk(nodeAccess_)) is3D]) N_ELE_ = BaseGraph_nextNodeEntryIndexWithInt_(self, 4);
  else N_ELE_ = -1;
  if ([extStorage_ isRequireNodeField]) N_ADDITIONAL_ = BaseGraph_nextNodeEntryIndexWithInt_(self, 4);
  else N_ADDITIONAL_ = -1;
  BaseGraph_initNodeAndEdgeEntrySize(self);
  [((id<InternalGraphEventListener>) nil_chk(listener_)) initStorage];
  initialized_ = YES;
}

- (void)initNodeRefsWithLong:(jlong)oldCapacity
                    withLong:(jlong)newCapacity {
  for (jlong pointer = oldCapacity + N_EDGE_REF_; pointer < newCapacity; pointer += nodeEntryBytes_) {
    [((id<DataAccess>) nil_chk(nodes_)) setIntWithLong:pointer withInt:EdgeIterator_NO_EDGE];
  }
  if ([((id<GraphExtension>) nil_chk(extStorage_)) isRequireNodeField]) {
    for (jlong pointer = oldCapacity + N_ADDITIONAL_; pointer < newCapacity; pointer += nodeEntryBytes_) {
      [((id<DataAccess>) nil_chk(nodes_)) setIntWithLong:pointer withInt:[extStorage_ getDefaultNodeFieldValue]];
    }
  }
}

- (jint)nextEdgeEntryIndexWithInt:(jint)sizeInBytes {
  return BaseGraph_nextEdgeEntryIndexWithInt_(self, sizeInBytes);
}

- (jint)nextNodeEntryIndexWithInt:(jint)sizeInBytes {
  return BaseGraph_nextNodeEntryIndexWithInt_(self, sizeInBytes);
}

- (void)initNodeAndEdgeEntrySize {
  BaseGraph_initNodeAndEdgeEntrySize(self);
}

- (void)ensureNodeIndexWithInt:(jint)nodeIndex {
  BaseGraph_ensureNodeIndexWithInt_(self, nodeIndex);
}

- (jint)getNodes {
  return nodeCount_;
}

- (id<NodeAccess>)getNodeAccess {
  return nodeAccess_;
}

- (BBox *)getBounds {
  return bounds_;
}

- (id<EdgeIteratorState>)edgeWithInt:(jint)a
                             withInt:(jint)b
                          withDouble:(jdouble)distance
                         withBoolean:(jboolean)bothDirection {
  return [((id<EdgeIteratorState>) nil_chk([((id<EdgeIteratorState>) nil_chk([self edgeWithInt:a withInt:b])) setDistanceWithDouble:distance])) setFlagsWithLong:[((EncodingManager *) nil_chk(encodingManager_)) flagsDefaultWithBoolean:YES withBoolean:bothDirection]];
}

- (void)setSegmentSizeWithInt:(jint)bytes {
  [self checkInit];
  [((id<DataAccess>) nil_chk(nodes_)) setSegmentSizeWithInt:bytes];
  [((id<DataAccess>) nil_chk(edges_)) setSegmentSizeWithInt:bytes];
  [((id<DataAccess>) nil_chk(wayGeometry_)) setSegmentSizeWithInt:bytes];
  [((NameIndex *) nil_chk(nameIndex_)) setSegmentSizeWithInt:bytes];
  [((id<GraphExtension>) nil_chk(extStorage_)) setSegmentSizeWithInt:bytes];
}

- (void)freeze {
  @synchronized(self) {
    if ([self isFrozen]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"base graph already frozen"] autorelease];
    frozen_ = YES;
    [((id<InternalGraphEventListener>) nil_chk(listener_)) freeze];
  }
}

- (jboolean)isFrozen {
  @synchronized(self) {
    return frozen_;
  }
}

- (void)checkFreeze {
  if ([self isFrozen]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Cannot add edge or node after baseGraph.freeze was called"] autorelease];
}

- (void)createWithLong:(jlong)initSize {
  [((id<DataAccess>) nil_chk(nodes_)) createWithLong:initSize];
  [((id<DataAccess>) nil_chk(edges_)) createWithLong:initSize];
  [((id<DataAccess>) nil_chk(wayGeometry_)) createWithLong:initSize];
  [((NameIndex *) nil_chk(nameIndex_)) createWithLong:1000];
  [((id<GraphExtension>) nil_chk(extStorage_)) createWithLong:initSize];
  [self initStorage];
  maxGeoRef_ = 4;
  [self initNodeRefsWithLong:0 withLong:[nodes_ getCapacity]];
}

- (NSString *)toDetailsString {
  return JreStrcat("$@", JreStrcat("$$", JreStrcat("$$", JreStrcat("$J", JreStrcat("$C", JreStrcat("$$", JreStrcat("$$", JreStrcat("$$", JreStrcat("$J", JreStrcat("$$", JreStrcat("$$", JreStrcat("$J", JreStrcat("$C", JreStrcat("$$", JreStrcat("$$", JreStrcat("$$", JreStrcat("$$CJ", @"edges:", Helper_nfWithLong_(edgeCount_), '(', [((id<DataAccess>) nil_chk(edges_)) getCapacity] / Helper_MB), @"MB), "), @"nodes:"), Helper_nfWithLong_([self getNodes])), '('), [((id<DataAccess>) nil_chk(nodes_)) getCapacity] / Helper_MB), @"MB), "), @"name:("), [((NameIndex *) nil_chk(nameIndex_)) getCapacity] / Helper_MB), @"MB), "), @"geo:"), Helper_nfWithLong_(maxGeoRef_)), '('), [((id<DataAccess>) nil_chk(wayGeometry_)) getCapacity] / Helper_MB), @"MB), "), @"bounds:"), bounds_);
}

- (void)flush {
  [self setNodesHeader];
  [self setEdgesHeader];
  [self setWayGeometryHeader];
  [((id<DataAccess>) nil_chk(wayGeometry_)) flush];
  [((NameIndex *) nil_chk(nameIndex_)) flush];
  [((id<DataAccess>) nil_chk(edges_)) flush];
  [((id<DataAccess>) nil_chk(nodes_)) flush];
  [((id<GraphExtension>) nil_chk(extStorage_)) flush];
}

- (void)close {
  [((id<DataAccess>) nil_chk(wayGeometry_)) close];
  [((NameIndex *) nil_chk(nameIndex_)) close];
  [((id<DataAccess>) nil_chk(edges_)) close];
  [((id<DataAccess>) nil_chk(nodes_)) close];
  [((id<GraphExtension>) nil_chk(extStorage_)) close];
}

- (jlong)getCapacity {
  return [((id<DataAccess>) nil_chk(edges_)) getCapacity] + [((id<DataAccess>) nil_chk(nodes_)) getCapacity] + [((NameIndex *) nil_chk(nameIndex_)) getCapacity] + [((id<DataAccess>) nil_chk(wayGeometry_)) getCapacity] + [((id<GraphExtension>) nil_chk(extStorage_)) getCapacity];
}

- (jlong)getMaxGeoRef {
  return maxGeoRef_;
}

- (void)loadExistingWithNSString:(NSString *)dim {
  if (![((id<DataAccess>) nil_chk(nodes_)) loadExisting]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$@", @"Cannot load nodes. corrupt file or directory? ", dir_)] autorelease];
  if (![((NSString *) nil_chk(dim)) equalsIgnoreCase:JreStrcat("I", [((id<NodeAccess>) nil_chk(nodeAccess_)) getDimension])]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$$C", @"Configured dimension (", [nodeAccess_ getDimension], @") is not equal to dimension of loaded graph (", dim, ')')] autorelease];
  if (![((id<DataAccess>) nil_chk(edges_)) loadExisting]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$@", @"Cannot load edges. corrupt file or directory? ", dir_)] autorelease];
  if (![((id<DataAccess>) nil_chk(wayGeometry_)) loadExisting]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$@", @"Cannot load geometry. corrupt file or directory? ", dir_)] autorelease];
  if (![((NameIndex *) nil_chk(nameIndex_)) loadExisting]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$@", @"Cannot load name index. corrupt file or directory? ", dir_)] autorelease];
  if (![((id<GraphExtension>) nil_chk(extStorage_)) loadExisting]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$@", @"Cannot load extended storage. corrupt file or directory? ", dir_)] autorelease];
  [self initStorage];
  [self loadNodesHeader];
  [self loadEdgesHeader];
  [self loadWayGeometryHeader];
}

- (id<EdgeIteratorState>)copyPropertiesWithBaseGraph_CommonEdgeIterator:(BaseGraph_CommonEdgeIterator *)from
                                                  withEdgeIteratorState:(id<EdgeIteratorState>)to {
  [((id<EdgeIteratorState>) nil_chk([((id<EdgeIteratorState>) nil_chk([((id<EdgeIteratorState>) nil_chk([((id<EdgeIteratorState>) nil_chk(to)) setDistanceWithDouble:BaseGraph_CommonEdgeIterator_getDistance(nil_chk(from))])) setNameWithNSString:[from getName]])) setFlagsWithLong:BaseGraph_CommonEdgeIterator_getDirectFlags(from)])) setWayGeometryWithPointList:[from fetchWayGeometryWithInt:0]];
  if (E_ADDITIONAL_ >= 0) [to setAdditionalFieldWithInt:BaseGraph_CommonEdgeIterator_getAdditionalField(from)];
  return to;
}

- (id<EdgeIteratorState>)edgeWithInt:(jint)nodeA
                             withInt:(jint)nodeB {
  if ([self isFrozen]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Cannot create edge if graph is already frozen"] autorelease];
  BaseGraph_ensureNodeIndexWithInt_(self, JavaLangMath_maxWithInt_withInt_(nodeA, nodeB));
  jint edgeId = [((EdgeAccess *) nil_chk(edgeAccess_)) internalEdgeAddWithInt:[self nextEdgeId] withInt:nodeA withInt:nodeB];
  BaseGraph_EdgeIterable *iter = [[[BaseGraph_EdgeIterable alloc] initWithBaseGraph:self withEdgeAccess:edgeAccess_ withEdgeFilter:EdgeFilter_get_ALL_EDGES_()] autorelease];
  jboolean ret = BaseGraph_EdgeIterable_init__WithInt_withInt_(iter, edgeId, nodeB);
  NSAssert(ret, @"com/graphhopper/storage/BaseGraph.java:463 condition failed: assert ret;");
  if ([((id<GraphExtension>) nil_chk(extStorage_)) isRequireEdgeField]) BaseGraph_CommonEdgeIterator_setAdditionalFieldWithInt_(iter, [extStorage_ getDefaultEdgeFieldValue]);
  return iter;
}

- (void)setEdgeCountWithInt:(jint)cnt {
  edgeCount_ = cnt;
}

- (jint)nextEdgeId {
  jint nextEdge = edgeCount_;
  edgeCount_++;
  if (edgeCount_ < 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$$", @"too many edges. new edge id would be negative. ", [self description])] autorelease];
  [((id<DataAccess>) nil_chk(edges_)) ensureCapacityWithLong:((jlong) edgeCount_ + 1) * edgeEntryBytes_];
  return nextEdge;
}

- (id<EdgeIteratorState>)getEdgeIteratorStateWithInt:(jint)edgeId
                                             withInt:(jint)adjNode {
  if (![((EdgeAccess *) nil_chk(edgeAccess_)) isInBoundsWithInt:edgeId]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$", @"edgeId ", edgeId, @" out of bounds")] autorelease];
  BaseGraph_checkAdjNodeBoundsWithInt_(self, adjNode);
  return [edgeAccess_ getEdgePropsWithInt:edgeId withInt:adjNode];
}

- (void)checkAdjNodeBoundsWithInt:(jint)adjNode {
  BaseGraph_checkAdjNodeBoundsWithInt_(self, adjNode);
}

- (id<EdgeExplorer>)createEdgeExplorerWithEdgeFilter:(id<EdgeFilter>)filter {
  return [[[BaseGraph_EdgeIterable alloc] initWithBaseGraph:self withEdgeAccess:edgeAccess_ withEdgeFilter:filter] autorelease];
}

- (id<EdgeExplorer>)createEdgeExplorer {
  return [self createEdgeExplorerWithEdgeFilter:EdgeFilter_get_ALL_EDGES_()];
}

- (id<AllEdgesIterator>)getAllEdges {
  return [[[BaseGraph_AllEdgeIterator alloc] initWithBaseGraph:self withEdgeAccess:edgeAccess_] autorelease];
}

- (id<Graph>)copyToWithGraph:(id<Graph>)g {
  initialized_ = YES;
  if ([[((id<Graph>) nil_chk(g)) getClass] isEqual:[self getClass]]) {
    [self _copyToWithBaseGraph:(BaseGraph *) check_class_cast(g, [BaseGraph class])];
    return g;
  }
  else {
    return GHUtility_copyToWithGraph_withGraph_(self, g);
  }
}

- (void)_copyToWithBaseGraph:(BaseGraph *)clonedG {
  if (((BaseGraph *) nil_chk(clonedG))->edgeEntryBytes_ != edgeEntryBytes_) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$I", @"edgeEntryBytes cannot be different for cloned graph. Cloned: ", clonedG->edgeEntryBytes_, @" vs ", edgeEntryBytes_)] autorelease];
  if (clonedG->nodeEntryBytes_ != nodeEntryBytes_) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$I", @"nodeEntryBytes cannot be different for cloned graph. Cloned: ", clonedG->nodeEntryBytes_, @" vs ", nodeEntryBytes_)] autorelease];
  if ([((id<NodeAccess>) nil_chk(clonedG->nodeAccess_)) getDimension] != [nodeAccess_ getDimension]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$I", @"dimension cannot be different for cloned graph. Cloned: ", [clonedG->nodeAccess_ getDimension], @" vs ", [nodeAccess_ getDimension])] autorelease];
  [self setNodesHeader];
  [((id<DataAccess>) nil_chk(nodes_)) copyToWithDataAccess:clonedG->nodes_];
  [clonedG loadNodesHeader];
  [self setEdgesHeader];
  [((id<DataAccess>) nil_chk(edges_)) copyToWithDataAccess:clonedG->edges_];
  [clonedG loadEdgesHeader];
  [((NameIndex *) nil_chk(nameIndex_)) copyToWithNameIndex:clonedG->nameIndex_];
  [self setWayGeometryHeader];
  [((id<DataAccess>) nil_chk(wayGeometry_)) copyToWithDataAccess:clonedG->wayGeometry_];
  [clonedG loadWayGeometryHeader];
  [((id<GraphExtension>) nil_chk(extStorage_)) copyToWithGraphExtension:clonedG->extStorage_];
  if (removedNodes_ == nil) BaseGraph_set_removedNodes_(clonedG, nil);
  else BaseGraph_set_removedNodes_(clonedG, [removedNodes_ copyToWithGHBitSet:[[[GHBitSetImpl alloc] init] autorelease]]);
}

- (void)trimToSize {
  jlong nodeCap = (jlong) nodeCount_ * nodeEntryBytes_;
  [((id<DataAccess>) nil_chk(nodes_)) trimToWithLong:nodeCap];
}

- (void)inPlaceNodeRemoveWithInt:(jint)removeNodeCount {
  jint toMoveNodes = [self getNodes];
  jint itemsToMove = 0;
  SparseIntIntArray *oldToNewMap = [[[SparseIntIntArray alloc] initWithInt:removeNodeCount] autorelease];
  id<GHBitSet> toRemoveSet = [[[GHBitSetImpl alloc] initWithInt:removeNodeCount] autorelease];
  [((id<GHBitSet>) nil_chk(removedNodes_)) copyToWithGHBitSet:toRemoveSet];
  id<OrgSlf4jLogger> logger = OrgSlf4jLoggerFactory_getLoggerWithIOSClass_([self getClass]);
  if (removeNodeCount > [self getNodes] / 2.0) [((id<OrgSlf4jLogger>) nil_chk(logger)) warnWithNSString:JreStrcat("$I$I", @"More than a half of the network should be removed!? Nodes:", [self getNodes], @", remove:", removeNodeCount)];
  id<EdgeExplorer> delExplorer = [self createEdgeExplorer];
  for (jint removeNode = [removedNodes_ nextWithInt:0]; removeNode >= 0; removeNode = [removedNodes_ nextWithInt:removeNode + 1]) {
    id<EdgeIterator> delEdgesIter = [((id<EdgeExplorer>) nil_chk(delExplorer)) setBaseNodeWithInt:removeNode];
    while ([((id<EdgeIterator>) nil_chk(delEdgesIter)) next]) {
      [toRemoveSet addWithInt:[delEdgesIter getAdjNode]];
    }
    toMoveNodes--;
    for (; toMoveNodes >= 0; toMoveNodes--) {
      if (![removedNodes_ containsWithInt:toMoveNodes]) break;
    }
    if (toMoveNodes >= removeNode) [oldToNewMap putWithInt:toMoveNodes withInt:removeNode];
    itemsToMove++;
  }
  BaseGraph_EdgeIterable *adjNodesToDelIter = (BaseGraph_EdgeIterable *) check_class_cast([self createEdgeExplorer], [BaseGraph_EdgeIterable class]);
  for (jint removeNode = [toRemoveSet nextWithInt:0]; removeNode >= 0; removeNode = [toRemoveSet nextWithInt:removeNode + 1]) {
    [((BaseGraph_EdgeIterable *) nil_chk(adjNodesToDelIter)) setBaseNodeWithInt:removeNode];
    jlong prev = EdgeIterator_NO_EDGE;
    while (BaseGraph_EdgeIterable_next(adjNodesToDelIter)) {
      jint nodeId = BaseGraph_CommonEdgeIterator_getAdjNode(adjNodesToDelIter);
      if (nodeId != EdgeAccess_NO_NODE && [removedNodes_ containsWithInt:nodeId]) {
        jint edgeToRemove = [adjNodesToDelIter getEdge];
        jlong edgeToRemovePointer = [((EdgeAccess *) nil_chk(edgeAccess_)) toPointerWithInt:edgeToRemove];
        [edgeAccess_ internalEdgeDisconnectWithInt:edgeToRemove withLong:prev withInt:removeNode withInt:nodeId];
        [edgeAccess_ invalidateEdgeWithLong:edgeToRemovePointer];
      }
      else {
        prev = adjNodesToDelIter->edgePointer_;
      }
    }
  }
  id<GHBitSet> toMoveSet = [[[GHBitSetImpl alloc] initWithInt:removeNodeCount * 3] autorelease];
  id<EdgeExplorer> movedEdgeExplorer = [self createEdgeExplorer];
  for (jint i = 0; i < itemsToMove; i++) {
    jint oldI = [oldToNewMap keyAtWithInt:i];
    id<EdgeIterator> movedEdgeIter = [((id<EdgeExplorer>) nil_chk(movedEdgeExplorer)) setBaseNodeWithInt:oldI];
    while ([((id<EdgeIterator>) nil_chk(movedEdgeIter)) next]) {
      jint nodeId = [movedEdgeIter getAdjNode];
      if (nodeId == EdgeAccess_NO_NODE) continue;
      if ([removedNodes_ containsWithInt:nodeId]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$I", @"shouldn't happen the edge to the node ", nodeId, @" should be already deleted. ", oldI)] autorelease];
      [toMoveSet addWithInt:nodeId];
    }
  }
  for (jint i = 0; i < itemsToMove; i++) {
    jint oldI = [oldToNewMap keyAtWithInt:i];
    jint newI = [oldToNewMap valueAtWithInt:i];
    jlong newOffset = (jlong) newI * nodeEntryBytes_;
    jlong oldOffset = (jlong) oldI * nodeEntryBytes_;
    for (jlong j = 0; j < nodeEntryBytes_; j += 4) {
      [nodes_ setIntWithLong:newOffset + j withInt:[((id<DataAccess>) nil_chk(nodes_)) getIntWithLong:oldOffset + j]];
    }
  }
  id<EdgeIterator> iter = [self getAllEdges];
  while ([((id<EdgeIterator>) nil_chk(iter)) next]) {
    jint nodeA = [iter getBaseNode];
    jint nodeB = [iter getAdjNode];
    if (![toMoveSet containsWithInt:nodeA] && ![toMoveSet containsWithInt:nodeB]) continue;
    jint updatedA = [oldToNewMap getWithInt:nodeA];
    if (updatedA < 0) updatedA = nodeA;
    jint updatedB = [oldToNewMap getWithInt:nodeB];
    if (updatedB < 0) updatedB = nodeB;
    jint edgeId = [iter getEdge];
    jlong edgePointer = [((EdgeAccess *) nil_chk(edgeAccess_)) toPointerWithInt:edgeId];
    jint linkA = [edgeAccess_ getEdgeRefWithInt:nodeA withInt:nodeB withLong:edgePointer];
    jint linkB = [edgeAccess_ getEdgeRefWithInt:nodeB withInt:nodeA withLong:edgePointer];
    jlong flags = [edgeAccess_ getFlags_WithLong:edgePointer withBoolean:NO];
    [edgeAccess_ writeEdgeWithInt:edgeId withInt:updatedA withInt:updatedB withInt:linkA withInt:linkB];
    [edgeAccess_ setFlags_WithLong:edgePointer withBoolean:updatedA > updatedB withLong:flags];
    if (updatedA < updatedB != nodeA < nodeB) BaseGraph_setWayGeometry_WithPointList_withLong_withBoolean_(self, BaseGraph_fetchWayGeometry_WithLong_withBoolean_withInt_withInt_withInt_(self, edgePointer, YES, 0, -1, -1), edgePointer, NO);
  }
  if (removeNodeCount >= nodeCount_) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I", @"graph is empty after in-place removal but was ", removeNodeCount)] autorelease];
  nodeCount_ -= removeNodeCount;
  if (BaseGraph_isTestingEnabled()) {
    id<EdgeExplorer> explorer = [self createEdgeExplorer];
    iter = [self getAllEdges];
    while ([((id<EdgeIterator>) nil_chk(iter)) next]) {
      jint base = [iter getBaseNode];
      jint adj = [iter getAdjNode];
      NSString *str = JreStrcat("I$I$Z$I$Z$I$Z$I$Z$I$I$I", [iter getEdge], @", r.contains(", base, @"):", [removedNodes_ containsWithInt:base], @", r.contains(", adj, @"):", [removedNodes_ containsWithInt:adj], @", tr.contains(", base, @"):", [toRemoveSet containsWithInt:base], @", tr.contains(", adj, @"):", [toRemoveSet containsWithInt:adj], @", base:", base, @", adj:", adj, @", nodeCount:", nodeCount_);
      if (adj >= nodeCount_) @throw [[[JavaLangRuntimeException alloc] initWithNSString:JreStrcat("$$", @"Adj.node problem with edge ", str)] autorelease];
      if (base >= nodeCount_) @throw [[[JavaLangRuntimeException alloc] initWithNSString:JreStrcat("$$", @"Base node problem with edge ", str)] autorelease];
      @try {
        [((id<EdgeIterator>) nil_chk([((id<EdgeExplorer>) nil_chk(explorer)) setBaseNodeWithInt:adj])) description];
      }
      @catch (JavaLangException *ex) {
        [((id<OrgSlf4jLogger>) nil_chk(OrgSlf4jLoggerFactory_getLoggerWithIOSClass_([self getClass]))) errorWithNSString:JreStrcat("$I", @"adj:", adj)];
      }
      @try {
        [((id<EdgeIterator>) nil_chk([((id<EdgeExplorer>) nil_chk(explorer)) setBaseNodeWithInt:base])) description];
      }
      @catch (JavaLangException *ex) {
        [((id<OrgSlf4jLogger>) nil_chk(OrgSlf4jLoggerFactory_getLoggerWithIOSClass_([self getClass]))) errorWithNSString:JreStrcat("$I", @"base:", base)];
      }
    }
    [((id<EdgeIterator>) nil_chk([((id<EdgeExplorer>) nil_chk(explorer)) setBaseNodeWithInt:nodeCount_ - 1])) description];
  }
  BaseGraph_set_removedNodes_(self, nil);
}

- (id<GraphExtension>)getExtension {
  return extStorage_;
}

- (void)setAdditionalEdgeFieldWithLong:(jlong)edgePointer
                               withInt:(jint)value {
  if ([((id<GraphExtension>) nil_chk(extStorage_)) isRequireEdgeField] && E_ADDITIONAL_ >= 0) [((id<DataAccess>) nil_chk(edges_)) setIntWithLong:edgePointer + E_ADDITIONAL_ withInt:value];
  else @throw [[[JavaLangAssertionError alloc] initWithId:@"This graph does not support an additional edge field."] autorelease];
}

- (void)setWayGeometry_WithPointList:(PointList *)pillarNodes
                            withLong:(jlong)edgePointer
                         withBoolean:(jboolean)reverse {
  BaseGraph_setWayGeometry_WithPointList_withLong_withBoolean_(self, pillarNodes, edgePointer, reverse);
}

- (void)setWayGeometryAtGeoRefWithPointList:(PointList *)pillarNodes
                                   withLong:(jlong)edgePointer
                                withBoolean:(jboolean)reverse
                                   withLong:(jlong)geoRef {
  BaseGraph_setWayGeometryAtGeoRefWithPointList_withLong_withBoolean_withLong_(self, pillarNodes, edgePointer, reverse, geoRef);
}

- (IOSByteArray *)createWayGeometryBytesWithPointList:(PointList *)pillarNodes
                                          withBoolean:(jboolean)reverse {
  return BaseGraph_createWayGeometryBytesWithPointList_withBoolean_(self, pillarNodes, reverse);
}

- (PointList *)fetchWayGeometry_WithLong:(jlong)edgePointer
                             withBoolean:(jboolean)reverse
                                 withInt:(jint)mode
                                 withInt:(jint)baseNode
                                 withInt:(jint)adjNode {
  return BaseGraph_fetchWayGeometry_WithLong_withBoolean_withInt_withInt_withInt_(self, edgePointer, reverse, mode, baseNode, adjNode);
}

- (void)setNameWithLong:(jlong)edgePointer
           withNSString:(NSString *)name {
  BaseGraph_setNameWithLong_withNSString_(self, edgePointer, name);
}

- (id<GHBitSet>)getRemovedNodes {
  if (removedNodes_ == nil) BaseGraph_setAndConsume_removedNodes_(self, [[GHBitSetImpl alloc] initWithInt:[self getNodes]]);
  return removedNodes_;
}

- (void)ensureGeometryWithLong:(jlong)bytePos
                       withInt:(jint)byteLength {
  BaseGraph_ensureGeometryWithLong_withInt_(self, bytePos, byteLength);
}

- (jlong)nextGeoRefWithInt:(jint)arrayLength {
  return BaseGraph_nextGeoRefWithInt_(self, arrayLength);
}

- (void)dealloc {
  RELEASE_(edges_);
  RELEASE_(nodes_);
  RELEASE_(bounds_);
  RELEASE_(nodeAccess_);
  RELEASE_(extStorage_);
  RELEASE_(nameIndex_);
  RELEASE_(bitUtil_);
  RELEASE_(encodingManager_);
  RELEASE_(edgeAccess_);
  RELEASE_(wayGeometry_);
  RELEASE_(dir_);
  RELEASE_(listener_);
  RELEASE_(removedNodes_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(BaseGraph *)other {
  [super copyAllFieldsTo:other];
  BaseGraph_set_edges_(other, edges_);
  BaseGraph_set_nodes_(other, nodes_);
  BaseGraph_set_bounds_(other, bounds_);
  BaseGraph_set_nodeAccess_(other, nodeAccess_);
  BaseGraph_set_extStorage_(other, extStorage_);
  BaseGraph_set_nameIndex_(other, nameIndex_);
  BaseGraph_set_bitUtil_(other, bitUtil_);
  BaseGraph_set_encodingManager_(other, encodingManager_);
  BaseGraph_set_edgeAccess_(other, edgeAccess_);
  BaseGraph_set_wayGeometry_(other, wayGeometry_);
  BaseGraph_set_dir_(other, dir_);
  BaseGraph_set_listener_(other, listener_);
  other->edgeCount_ = edgeCount_;
  other->N_EDGE_REF_ = N_EDGE_REF_;
  other->N_LAT_ = N_LAT_;
  other->N_LON_ = N_LON_;
  other->N_ELE_ = N_ELE_;
  other->N_ADDITIONAL_ = N_ADDITIONAL_;
  other->E_GEO_ = E_GEO_;
  other->E_NAME_ = E_NAME_;
  other->E_ADDITIONAL_ = E_ADDITIONAL_;
  other->edgeEntryBytes_ = edgeEntryBytes_;
  other->nodeEntryBytes_ = nodeEntryBytes_;
  other->initialized_ = initialized_;
  other->nodeCount_ = nodeCount_;
  BaseGraph_set_removedNodes_(other, removedNodes_);
  other->edgeEntryIndex_ = edgeEntryIndex_;
  other->nodeEntryIndex_ = nodeEntryIndex_;
  other->maxGeoRef_ = maxGeoRef_;
  other->frozen_ = frozen_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithDirectory:withEncodingManager:withBoolean:withInternalGraphEventListener:withGraphExtension:", "BaseGraph", NULL, 0x1, NULL },
    { "isTestingEnabled", NULL, "Z", 0xa, NULL },
    { "getBaseGraph", NULL, "Lcom.graphhopper.storage.Graph;", 0x1, NULL },
    { "checkInit", NULL, "V", 0x0, NULL },
    { "loadNodesHeader", NULL, "I", 0x4, NULL },
    { "setNodesHeader", NULL, "I", 0x4, NULL },
    { "loadEdgesHeader", NULL, "I", 0x4, NULL },
    { "setEdgesHeader", NULL, "I", 0x4, NULL },
    { "loadWayGeometryHeader", NULL, "I", 0x4, NULL },
    { "setWayGeometryHeader", NULL, "I", 0x4, NULL },
    { "initStorage", NULL, "V", 0x0, NULL },
    { "initNodeRefsWithLong:withLong:", "initNodeRefs", "V", 0x0, NULL },
    { "nextEdgeEntryIndexWithInt:", "nextEdgeEntryIndex", "I", 0x14, NULL },
    { "nextNodeEntryIndexWithInt:", "nextNodeEntryIndex", "I", 0x14, NULL },
    { "initNodeAndEdgeEntrySize", NULL, "V", 0x14, NULL },
    { "ensureNodeIndexWithInt:", "ensureNodeIndex", "V", 0x10, NULL },
    { "getNodes", NULL, "I", 0x1, NULL },
    { "getNodeAccess", NULL, "Lcom.graphhopper.storage.NodeAccess;", 0x1, NULL },
    { "getBounds", NULL, "Lcom.graphhopper.util.shapes.BBox;", 0x1, NULL },
    { "edgeWithInt:withInt:withDouble:withBoolean:", "edge", "Lcom.graphhopper.util.EdgeIteratorState;", 0x1, NULL },
    { "setSegmentSizeWithInt:", "setSegmentSize", "V", 0x0, NULL },
    { "freeze", NULL, "V", 0x20, NULL },
    { "isFrozen", NULL, "Z", 0x20, NULL },
    { "checkFreeze", NULL, "V", 0x1, NULL },
    { "createWithLong:", "create", "V", 0x0, NULL },
    { "toDetailsString", NULL, "Ljava.lang.String;", 0x0, NULL },
    { "flush", NULL, "V", 0x0, NULL },
    { "close", NULL, "V", 0x0, NULL },
    { "getCapacity", NULL, "J", 0x0, NULL },
    { "getMaxGeoRef", NULL, "J", 0x0, NULL },
    { "loadExistingWithNSString:", "loadExisting", "V", 0x0, NULL },
    { "copyPropertiesWithBaseGraph_CommonEdgeIterator:withEdgeIteratorState:", "copyProperties", "Lcom.graphhopper.util.EdgeIteratorState;", 0x0, NULL },
    { "edgeWithInt:withInt:", "edge", "Lcom.graphhopper.util.EdgeIteratorState;", 0x1, NULL },
    { "setEdgeCountWithInt:", "setEdgeCount", "V", 0x0, NULL },
    { "nextEdgeId", NULL, "I", 0x4, NULL },
    { "getEdgeIteratorStateWithInt:withInt:", "getEdgeIteratorState", "Lcom.graphhopper.util.EdgeIteratorState;", 0x1, NULL },
    { "checkAdjNodeBoundsWithInt:", "checkAdjNodeBounds", "V", 0x10, NULL },
    { "createEdgeExplorerWithEdgeFilter:", "createEdgeExplorer", "Lcom.graphhopper.util.EdgeExplorer;", 0x1, NULL },
    { "createEdgeExplorer", NULL, "Lcom.graphhopper.util.EdgeExplorer;", 0x1, NULL },
    { "getAllEdges", NULL, "Lcom.graphhopper.routing.util.AllEdgesIterator;", 0x1, NULL },
    { "copyToWithGraph:", "copyTo", "Lcom.graphhopper.storage.Graph;", 0x1, NULL },
    { "_copyToWithBaseGraph:", "_copyTo", "V", 0x0, NULL },
    { "trimToSize", NULL, "V", 0x4, NULL },
    { "inPlaceNodeRemoveWithInt:", "inPlaceNodeRemove", "V", 0x0, NULL },
    { "getExtension", NULL, "Lcom.graphhopper.storage.GraphExtension;", 0x1, NULL },
    { "setAdditionalEdgeFieldWithLong:withInt:", "setAdditionalEdgeField", "V", 0x1, NULL },
    { "setWayGeometry_WithPointList:withLong:withBoolean:", "setWayGeometry_", "V", 0x2, NULL },
    { "setWayGeometryAtGeoRefWithPointList:withLong:withBoolean:withLong:", "setWayGeometryAtGeoRef", "V", 0x2, NULL },
    { "createWayGeometryBytesWithPointList:withBoolean:", "createWayGeometryBytes", "[B", 0x2, NULL },
    { "fetchWayGeometry_WithLong:withBoolean:withInt:withInt:withInt:", "fetchWayGeometry_", "Lcom.graphhopper.util.PointList;", 0x2, NULL },
    { "setNameWithLong:withNSString:", "setName", "V", 0x2, NULL },
    { "getRemovedNodes", NULL, "Lcom.graphhopper.coll.GHBitSet;", 0x0, NULL },
    { "ensureGeometryWithLong:withInt:", "ensureGeometry", "V", 0x2, NULL },
    { "nextGeoRefWithInt:", "nextGeoRef", "J", 0x2, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "edges_", NULL, 0x10, "Lcom.graphhopper.storage.DataAccess;", NULL,  },
    { "nodes_", NULL, 0x10, "Lcom.graphhopper.storage.DataAccess;", NULL,  },
    { "bounds_", NULL, 0x10, "Lcom.graphhopper.util.shapes.BBox;", NULL,  },
    { "nodeAccess_", NULL, 0x10, "Lcom.graphhopper.storage.NodeAccess;", NULL,  },
    { "extStorage_", NULL, 0x10, "Lcom.graphhopper.storage.GraphExtension;", NULL,  },
    { "nameIndex_", NULL, 0x10, "Lcom.graphhopper.search.NameIndex;", NULL,  },
    { "bitUtil_", NULL, 0x10, "Lcom.graphhopper.util.BitUtil;", NULL,  },
    { "encodingManager_", NULL, 0x10, "Lcom.graphhopper.routing.util.EncodingManager;", NULL,  },
    { "edgeAccess_", NULL, 0x10, "Lcom.graphhopper.storage.EdgeAccess;", NULL,  },
    { "wayGeometry_", NULL, 0x12, "Lcom.graphhopper.storage.DataAccess;", NULL,  },
    { "dir_", NULL, 0x12, "Lcom.graphhopper.storage.Directory;", NULL,  },
    { "listener_", NULL, 0x12, "Lcom.graphhopper.storage.InternalGraphEventListener;", NULL,  },
    { "edgeCount_", NULL, 0x4, "I", NULL,  },
    { "N_EDGE_REF_", NULL, 0x4, "I", NULL,  },
    { "N_LAT_", NULL, 0x4, "I", NULL,  },
    { "N_LON_", NULL, 0x4, "I", NULL,  },
    { "N_ELE_", NULL, 0x4, "I", NULL,  },
    { "N_ADDITIONAL_", NULL, 0x4, "I", NULL,  },
    { "E_GEO_", NULL, 0x0, "I", NULL,  },
    { "E_NAME_", NULL, 0x0, "I", NULL,  },
    { "E_ADDITIONAL_", NULL, 0x0, "I", NULL,  },
    { "edgeEntryBytes_", NULL, 0x0, "I", NULL,  },
    { "nodeEntryBytes_", NULL, 0x0, "I", NULL,  },
    { "initialized_", NULL, 0x2, "Z", NULL,  },
    { "nodeCount_", NULL, 0x2, "I", NULL,  },
    { "removedNodes_", NULL, 0x2, "Lcom.graphhopper.coll.GHBitSet;", NULL,  },
    { "edgeEntryIndex_", NULL, 0x2, "I", NULL,  },
    { "nodeEntryIndex_", NULL, 0x2, "I", NULL,  },
    { "maxGeoRef_", NULL, 0x2, "J", NULL,  },
    { "frozen_", NULL, 0x2, "Z", NULL,  },
  };
  static const J2ObjcClassInfo _BaseGraph = { 1, "BaseGraph", "com.graphhopper.storage", NULL, 0x0, 54, methods, 30, fields, 0, NULL};
  return &_BaseGraph;
}

@end

jboolean BaseGraph_isTestingEnabled() {
  BaseGraph_init();
  jboolean enableIfAssert = NO;
  NSCAssert((enableIfAssert = YES), [JavaLangBoolean_valueOfWithBoolean_(YES) description]);
  return enableIfAssert;
}

jint BaseGraph_nextEdgeEntryIndexWithInt_(BaseGraph *self, jint sizeInBytes) {
  jint tmp = self->edgeEntryIndex_;
  self->edgeEntryIndex_ += sizeInBytes;
  return tmp;
}

jint BaseGraph_nextNodeEntryIndexWithInt_(BaseGraph *self, jint sizeInBytes) {
  jint tmp = self->nodeEntryIndex_;
  self->nodeEntryIndex_ += sizeInBytes;
  return tmp;
}

void BaseGraph_initNodeAndEdgeEntrySize(BaseGraph *self) {
  self->nodeEntryBytes_ = self->nodeEntryIndex_;
  self->edgeEntryBytes_ = self->edgeEntryIndex_;
}

void BaseGraph_ensureNodeIndexWithInt_(BaseGraph *self, jint nodeIndex) {
  if (!self->initialized_) @throw [[[JavaLangAssertionError alloc] initWithId:@"The graph has not yet been initialized."] autorelease];
  if (nodeIndex < self->nodeCount_) return;
  jlong oldNodes = self->nodeCount_;
  self->nodeCount_ = nodeIndex + 1;
  jboolean capacityIncreased = [((id<DataAccess>) nil_chk(self->nodes_)) ensureCapacityWithLong:(jlong) self->nodeCount_ * self->nodeEntryBytes_];
  if (capacityIncreased) {
    jlong newBytesCapacity = [self->nodes_ getCapacity];
    [self initNodeRefsWithLong:oldNodes * self->nodeEntryBytes_ withLong:newBytesCapacity];
  }
}

void BaseGraph_checkAdjNodeBoundsWithInt_(BaseGraph *self, jint adjNode) {
  if ((adjNode < 0 && adjNode != JavaLangInteger_MIN_VALUE) || adjNode >= self->nodeCount_) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$$C", @"adjNode ", adjNode, @" out of bounds [0,", Helper_nfWithLong_(self->nodeCount_), ')')] autorelease];
}

void BaseGraph_setWayGeometry_WithPointList_withLong_withBoolean_(BaseGraph *self, PointList *pillarNodes, jlong edgePointer, jboolean reverse) {
  if (pillarNodes != nil && ![pillarNodes isEmpty]) {
    if ([pillarNodes getDimension] != [((id<NodeAccess>) nil_chk(self->nodeAccess_)) getDimension]) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$I$IC", @"Cannot use pointlist which is ", [pillarNodes getDimension], @"D for graph which is ", [self->nodeAccess_ getDimension], 'D')] autorelease];
    jlong existingGeoRef = Helper_toUnsignedLongWithInt_([((id<DataAccess>) nil_chk(self->edges_)) getIntWithLong:edgePointer + self->E_GEO_]);
    jint len = [pillarNodes getSize];
    jint dim = [self->nodeAccess_ getDimension];
    if (existingGeoRef > 0) {
      jint count = [((id<DataAccess>) nil_chk(self->wayGeometry_)) getIntWithLong:existingGeoRef * 4LL];
      if (len <= count) {
        BaseGraph_setWayGeometryAtGeoRefWithPointList_withLong_withBoolean_withLong_(self, pillarNodes, edgePointer, reverse, existingGeoRef);
        return;
      }
    }
    jlong nextGeoRef = BaseGraph_nextGeoRefWithInt_(self, len * dim);
    BaseGraph_setWayGeometryAtGeoRefWithPointList_withLong_withBoolean_withLong_(self, pillarNodes, edgePointer, reverse, nextGeoRef);
  }
  else {
    [((id<DataAccess>) nil_chk(self->edges_)) setIntWithLong:edgePointer + self->E_GEO_ withInt:0];
  }
}

void BaseGraph_setWayGeometryAtGeoRefWithPointList_withLong_withBoolean_withLong_(BaseGraph *self, PointList *pillarNodes, jlong edgePointer, jboolean reverse, jlong geoRef) {
  jint len = [((PointList *) nil_chk(pillarNodes)) getSize];
  jint dim = [((id<NodeAccess>) nil_chk(self->nodeAccess_)) getDimension];
  jlong geoRefPosition = (jlong) geoRef * 4;
  jint totalLen = len * dim * 4 + 4;
  BaseGraph_ensureGeometryWithLong_withInt_(self, geoRefPosition, totalLen);
  IOSByteArray *wayGeometryBytes = BaseGraph_createWayGeometryBytesWithPointList_withBoolean_(self, pillarNodes, reverse);
  [((id<DataAccess>) nil_chk(self->wayGeometry_)) setBytesWithLong:geoRefPosition withByteArray:wayGeometryBytes withInt:((IOSByteArray *) nil_chk(wayGeometryBytes))->size_];
  [((id<DataAccess>) nil_chk(self->edges_)) setIntWithLong:edgePointer + self->E_GEO_ withInt:Helper_toSignedIntWithLong_(geoRef)];
}

IOSByteArray *BaseGraph_createWayGeometryBytesWithPointList_withBoolean_(BaseGraph *self, PointList *pillarNodes, jboolean reverse) {
  jint len = [((PointList *) nil_chk(pillarNodes)) getSize];
  jint dim = [((id<NodeAccess>) nil_chk(self->nodeAccess_)) getDimension];
  jint totalLen = len * dim * 4 + 4;
  IOSByteArray *bytes = [IOSByteArray arrayWithLength:totalLen];
  [((BitUtil *) nil_chk(self->bitUtil_)) fromIntWithByteArray:bytes withInt:len withInt:0];
  if (reverse) [pillarNodes reverse];
  jint tmpOffset = 4;
  jboolean is3D = [self->nodeAccess_ is3D];
  for (jint i = 0; i < len; i++) {
    jdouble lat = [pillarNodes getLatitudeWithInt:i];
    [self->bitUtil_ fromIntWithByteArray:bytes withInt:Helper_degreeToIntWithDouble_(lat) withInt:tmpOffset];
    tmpOffset += 4;
    [self->bitUtil_ fromIntWithByteArray:bytes withInt:Helper_degreeToIntWithDouble_([pillarNodes getLongitudeWithInt:i]) withInt:tmpOffset];
    tmpOffset += 4;
    if (is3D) {
      [self->bitUtil_ fromIntWithByteArray:bytes withInt:Helper_eleToIntWithDouble_([pillarNodes getElevationWithInt:i]) withInt:tmpOffset];
      tmpOffset += 4;
    }
  }
  return bytes;
}

PointList *BaseGraph_fetchWayGeometry_WithLong_withBoolean_withInt_withInt_withInt_(BaseGraph *self, jlong edgePointer, jboolean reverse, jint mode, jint baseNode, jint adjNode) {
  jlong geoRef = Helper_toUnsignedLongWithInt_([((id<DataAccess>) nil_chk(self->edges_)) getIntWithLong:edgePointer + self->E_GEO_]);
  jint count = 0;
  IOSByteArray *bytes = nil;
  if (geoRef > 0) {
    geoRef *= 4LL;
    count = [((id<DataAccess>) nil_chk(self->wayGeometry_)) getIntWithLong:geoRef];
    geoRef += 4LL;
    bytes = [IOSByteArray arrayWithLength:count * [((id<NodeAccess>) nil_chk(self->nodeAccess_)) getDimension] * 4];
    [self->wayGeometry_ getBytesWithLong:geoRef withByteArray:bytes withInt:bytes->size_];
  }
  else if (mode == 0) return PointList_get_EMPTY_();
  PointList *pillarNodes = [[[PointList alloc] initWithInt:count + mode withBoolean:[((id<NodeAccess>) nil_chk(self->nodeAccess_)) is3D]] autorelease];
  if (reverse) {
    if ((mode & 2) != 0) [pillarNodes addWithPointAccess:self->nodeAccess_ withInt:adjNode];
  }
  else if ((mode & 1) != 0) [pillarNodes addWithPointAccess:self->nodeAccess_ withInt:baseNode];
  jint index = 0;
  for (jint i = 0; i < count; i++) {
    jdouble lat = Helper_intToDegreeWithInt_([((BitUtil *) nil_chk(self->bitUtil_)) toIntWithByteArray:bytes withInt:index]);
    index += 4;
    jdouble lon = Helper_intToDegreeWithInt_([self->bitUtil_ toIntWithByteArray:bytes withInt:index]);
    index += 4;
    if ([self->nodeAccess_ is3D]) {
      [pillarNodes addWithDouble:lat withDouble:lon withDouble:Helper_intToEleWithInt_([self->bitUtil_ toIntWithByteArray:bytes withInt:index])];
      index += 4;
    }
    else {
      [pillarNodes addWithDouble:lat withDouble:lon];
    }
  }
  if (reverse) {
    if ((mode & 1) != 0) [pillarNodes addWithPointAccess:self->nodeAccess_ withInt:baseNode];
    [pillarNodes reverse];
  }
  else if ((mode & 2) != 0) [pillarNodes addWithPointAccess:self->nodeAccess_ withInt:adjNode];
  return pillarNodes;
}

void BaseGraph_setNameWithLong_withNSString_(BaseGraph *self, jlong edgePointer, NSString *name) {
  jint nameIndexRef = (jint) [((NameIndex *) nil_chk(self->nameIndex_)) putWithNSString:name];
  if (nameIndexRef < 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Too many names are stored, currently limited to int pointer"] autorelease];
  [((id<DataAccess>) nil_chk(self->edges_)) setIntWithLong:edgePointer + self->E_NAME_ withInt:nameIndexRef];
}

void BaseGraph_ensureGeometryWithLong_withInt_(BaseGraph *self, jlong bytePos, jint byteLength) {
  [((id<DataAccess>) nil_chk(self->wayGeometry_)) ensureCapacityWithLong:bytePos + byteLength];
}

jlong BaseGraph_nextGeoRefWithInt_(BaseGraph *self, jint arrayLength) {
  jlong tmp = self->maxGeoRef_;
  self->maxGeoRef_ += arrayLength + 1LL;
  if (self->maxGeoRef_ >= (jlong) 0xFFFFffffLL) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$J", @"Geometry too large, does not fit in 32 bits ", self->maxGeoRef_)] autorelease];
  return tmp;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(BaseGraph)

@implementation BaseGraph_CommonEdgeIterator

- (instancetype)initWithLong:(jlong)edgePointer
              withEdgeAccess:(EdgeAccess *)edgeAccess
               withBaseGraph:(BaseGraph *)baseGraph {
  if (self = [super init]) {
    reverse_ = NO;
    edgeId_ = -1;
    self->edgePointer_ = edgePointer;
    BaseGraph_CommonEdgeIterator_set_edgeAccess_(self, edgeAccess);
    BaseGraph_CommonEdgeIterator_set_baseGraph_(self, baseGraph);
  }
  return self;
}

- (jint)getBaseNode {
  return BaseGraph_CommonEdgeIterator_getBaseNode(self);
}

- (jint)getAdjNode {
  return BaseGraph_CommonEdgeIterator_getAdjNode(self);
}

- (jdouble)getDistance {
  return BaseGraph_CommonEdgeIterator_getDistance(self);
}

- (id<EdgeIteratorState>)setDistanceWithDouble:(jdouble)dist {
  [((EdgeAccess *) nil_chk(edgeAccess_)) setDistWithLong:edgePointer_ withDouble:dist];
  return self;
}

- (jlong)getDirectFlags {
  return BaseGraph_CommonEdgeIterator_getDirectFlags(self);
}

- (jlong)getFlags {
  return BaseGraph_CommonEdgeIterator_getDirectFlags(self);
}

- (id<EdgeIteratorState>)setFlagsWithLong:(jlong)fl {
  [((EdgeAccess *) nil_chk(edgeAccess_)) setFlags_WithLong:edgePointer_ withBoolean:reverse_ withLong:fl];
  cachedFlags_ = fl;
  freshFlags_ = YES;
  return self;
}

- (jint)getAdditionalField {
  return BaseGraph_CommonEdgeIterator_getAdditionalField(self);
}

- (id<EdgeIteratorState>)setAdditionalFieldWithInt:(jint)value {
  return BaseGraph_CommonEdgeIterator_setAdditionalFieldWithInt_(self, value);
}

- (id<EdgeIteratorState>)copyPropertiesToWithEdgeIteratorState:(id<EdgeIteratorState>)edge {
  return [((BaseGraph *) nil_chk(baseGraph_)) copyPropertiesWithBaseGraph_CommonEdgeIterator:self withEdgeIteratorState:edge];
}

- (jboolean)isForwardWithFlagEncoder:(id<FlagEncoder>)encoder {
  return [((id<FlagEncoder>) nil_chk(encoder)) isForwardWithLong:BaseGraph_CommonEdgeIterator_getDirectFlags(self)];
}

- (jboolean)isBackwardWithFlagEncoder:(id<FlagEncoder>)encoder {
  return [((id<FlagEncoder>) nil_chk(encoder)) isBackwardWithLong:BaseGraph_CommonEdgeIterator_getDirectFlags(self)];
}

- (id<EdgeIteratorState>)setWayGeometryWithPointList:(PointList *)pillarNodes {
  BaseGraph_setWayGeometry_WithPointList_withLong_withBoolean_(nil_chk(baseGraph_), pillarNodes, edgePointer_, reverse_);
  return self;
}

- (PointList *)fetchWayGeometryWithInt:(jint)mode {
  return BaseGraph_fetchWayGeometry_WithLong_withBoolean_withInt_withInt_withInt_(nil_chk(baseGraph_), edgePointer_, reverse_, mode, BaseGraph_CommonEdgeIterator_getBaseNode(self), BaseGraph_CommonEdgeIterator_getAdjNode(self));
}

- (jint)getEdge {
  return edgeId_;
}

- (NSString *)getName {
  jint nameIndexRef = [((id<DataAccess>) nil_chk(((BaseGraph *) nil_chk(baseGraph_))->edges_)) getIntWithLong:edgePointer_ + baseGraph_->E_NAME_];
  return [((NameIndex *) nil_chk(baseGraph_->nameIndex_)) getWithLong:nameIndexRef];
}

- (id<EdgeIteratorState>)setNameWithNSString:(NSString *)name {
  BaseGraph_setNameWithLong_withNSString_(nil_chk(baseGraph_), edgePointer_, name);
  return self;
}

- (jboolean)getBoolWithInt:(jint)key
               withBoolean:(jboolean)_default {
  return _default;
}

- (NSString *)description {
  return JreStrcat("ICICI", [self getEdge], ' ', BaseGraph_CommonEdgeIterator_getBaseNode(self), '-', BaseGraph_CommonEdgeIterator_getAdjNode(self));
}

- (void)dealloc {
  RELEASE_(baseGraph_);
  RELEASE_(edgeAccess_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(BaseGraph_CommonEdgeIterator *)other {
  [super copyAllFieldsTo:other];
  BaseGraph_CommonEdgeIterator_set_baseGraph_(other, baseGraph_);
  other->edgePointer_ = edgePointer_;
  other->baseNode_ = baseNode_;
  other->adjNode_ = adjNode_;
  BaseGraph_CommonEdgeIterator_set_edgeAccess_(other, edgeAccess_);
  other->reverse_ = reverse_;
  other->freshFlags_ = freshFlags_;
  other->edgeId_ = edgeId_;
  other->cachedFlags_ = cachedFlags_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithLong:withEdgeAccess:withBaseGraph:", "CommonEdgeIterator", NULL, 0x1, NULL },
    { "getBaseNode", NULL, "I", 0x11, NULL },
    { "getAdjNode", NULL, "I", 0x11, NULL },
    { "getDistance", NULL, "D", 0x11, NULL },
    { "setDistanceWithDouble:", "setDistance", "Lcom.graphhopper.util.EdgeIteratorState;", 0x11, NULL },
    { "getDirectFlags", NULL, "J", 0x10, NULL },
    { "getFlags", NULL, "J", 0x1, NULL },
    { "setFlagsWithLong:", "setFlags", "Lcom.graphhopper.util.EdgeIteratorState;", 0x11, NULL },
    { "getAdditionalField", NULL, "I", 0x11, NULL },
    { "setAdditionalFieldWithInt:", "setAdditionalField", "Lcom.graphhopper.util.EdgeIteratorState;", 0x11, NULL },
    { "copyPropertiesToWithEdgeIteratorState:", "copyPropertiesTo", "Lcom.graphhopper.util.EdgeIteratorState;", 0x11, NULL },
    { "isForwardWithFlagEncoder:", "isForward", "Z", 0x1, NULL },
    { "isBackwardWithFlagEncoder:", "isBackward", "Z", 0x1, NULL },
    { "setWayGeometryWithPointList:", "setWayGeometry", "Lcom.graphhopper.util.EdgeIteratorState;", 0x1, NULL },
    { "fetchWayGeometryWithInt:", "fetchWayGeometry", "Lcom.graphhopper.util.PointList;", 0x1, NULL },
    { "getEdge", NULL, "I", 0x1, NULL },
    { "getName", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "setNameWithNSString:", "setName", "Lcom.graphhopper.util.EdgeIteratorState;", 0x1, NULL },
    { "getBoolWithInt:withBoolean:", "getBool", "Z", 0x11, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x11, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "baseGraph_", NULL, 0x10, "Lcom.graphhopper.storage.BaseGraph;", NULL,  },
    { "edgePointer_", NULL, 0x4, "J", NULL,  },
    { "baseNode_", NULL, 0x4, "I", NULL,  },
    { "adjNode_", NULL, 0x4, "I", NULL,  },
    { "edgeAccess_", NULL, 0x4, "Lcom.graphhopper.storage.EdgeAccess;", NULL,  },
    { "reverse_", NULL, 0x0, "Z", NULL,  },
    { "freshFlags_", NULL, 0x0, "Z", NULL,  },
    { "edgeId_", NULL, 0x0, "I", NULL,  },
    { "cachedFlags_", NULL, 0x2, "J", NULL,  },
  };
  static const J2ObjcClassInfo _BaseGraph_CommonEdgeIterator = { 1, "CommonEdgeIterator", "com.graphhopper.storage", "BaseGraph", 0x408, 20, methods, 9, fields, 0, NULL};
  return &_BaseGraph_CommonEdgeIterator;
}

@end

jint BaseGraph_CommonEdgeIterator_getBaseNode(BaseGraph_CommonEdgeIterator *self) {
  return self->baseNode_;
}

jint BaseGraph_CommonEdgeIterator_getAdjNode(BaseGraph_CommonEdgeIterator *self) {
  return self->adjNode_;
}

jdouble BaseGraph_CommonEdgeIterator_getDistance(BaseGraph_CommonEdgeIterator *self) {
  return [((EdgeAccess *) nil_chk(self->edgeAccess_)) getDistWithLong:self->edgePointer_];
}

jlong BaseGraph_CommonEdgeIterator_getDirectFlags(BaseGraph_CommonEdgeIterator *self) {
  if (!self->freshFlags_) {
    self->cachedFlags_ = [((EdgeAccess *) nil_chk(self->edgeAccess_)) getFlags_WithLong:self->edgePointer_ withBoolean:self->reverse_];
    self->freshFlags_ = YES;
  }
  return self->cachedFlags_;
}

jint BaseGraph_CommonEdgeIterator_getAdditionalField(BaseGraph_CommonEdgeIterator *self) {
  return [((id<DataAccess>) nil_chk(((BaseGraph *) nil_chk(self->baseGraph_))->edges_)) getIntWithLong:self->edgePointer_ + self->baseGraph_->E_ADDITIONAL_];
}

id<EdgeIteratorState> BaseGraph_CommonEdgeIterator_setAdditionalFieldWithInt_(BaseGraph_CommonEdgeIterator *self, jint value) {
  [((BaseGraph *) nil_chk(self->baseGraph_)) setAdditionalEdgeFieldWithLong:self->edgePointer_ withInt:value];
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(BaseGraph_CommonEdgeIterator)

@implementation BaseGraph_EdgeIterable

- (instancetype)initWithBaseGraph:(BaseGraph *)baseGraph
                   withEdgeAccess:(EdgeAccess *)edgeAccess
                   withEdgeFilter:(id<EdgeFilter>)filter {
  if (self = [super initWithLong:-1 withEdgeAccess:edgeAccess withBaseGraph:baseGraph]) {
    if (filter == nil) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Instead null filter use EdgeFilter.ALL_EDGES"] autorelease];
    BaseGraph_EdgeIterable_set_filter_(self, filter);
  }
  return self;
}

- (void)setEdgeIdWithInt:(jint)edgeId {
  BaseGraph_EdgeIterable_setEdgeIdWithInt_(self, edgeId);
}

- (jboolean)init__WithInt:(jint)tmpEdgeId
                  withInt:(jint)expectedAdjNode {
  return BaseGraph_EdgeIterable_init__WithInt_withInt_(self, tmpEdgeId, expectedAdjNode);
}

- (void)_setBaseNodeWithInt:(jint)baseNode {
  BaseGraph_EdgeIterable__setBaseNodeWithInt_(self, baseNode);
}

- (id<EdgeIterator>)setBaseNodeWithInt:(jint)baseNode {
  BaseGraph_EdgeIterable_setEdgeIdWithInt_(self, [((EdgeAccess *) nil_chk(((BaseGraph *) nil_chk(baseGraph_))->edgeAccess_)) getEdgeRefWithInt:baseNode]);
  BaseGraph_EdgeIterable__setBaseNodeWithInt_(self, baseNode);
  return self;
}

- (void)selectEdgeAccess {
}

- (jboolean)next {
  return BaseGraph_EdgeIterable_next(self);
}

- (id<EdgeIteratorState>)detachWithBoolean:(jboolean)reverseArg {
  if (edgeId_ == nextEdgeId_ || edgeId_ == EdgeIterator_NO_EDGE) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$IC", @"call next before detaching or setEdgeId (edgeId:", edgeId_, @" vs. next ", nextEdgeId_, ')')] autorelease];
  BaseGraph_EdgeIterable *iter = [((EdgeAccess *) nil_chk(edgeAccess_)) createSingleEdgeWithEdgeFilter:filter_];
  jboolean ret;
  if (reverseArg) {
    ret = BaseGraph_EdgeIterable_init__WithInt_withInt_(nil_chk(iter), edgeId_, baseNode_);
    iter->reverse_ = !reverse_;
  }
  else ret = BaseGraph_EdgeIterable_init__WithInt_withInt_(nil_chk(iter), edgeId_, adjNode_);
  NSAssert(ret, @"com/graphhopper/storage/BaseGraph.java:987 condition failed: assert ret;");
  return iter;
}

- (void)dealloc {
  RELEASE_(filter_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(BaseGraph_EdgeIterable *)other {
  [super copyAllFieldsTo:other];
  BaseGraph_EdgeIterable_set_filter_(other, filter_);
  other->nextEdgeId_ = nextEdgeId_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithBaseGraph:withEdgeAccess:withEdgeFilter:", "EdgeIterable", NULL, 0x1, NULL },
    { "setEdgeIdWithInt:", "setEdgeId", "V", 0x10, NULL },
    { "init__WithInt:withInt:", "init", "Z", 0x10, NULL },
    { "_setBaseNodeWithInt:", "_setBaseNode", "V", 0x10, NULL },
    { "setBaseNodeWithInt:", "setBaseNode", "Lcom.graphhopper.util.EdgeIterator;", 0x1, NULL },
    { "selectEdgeAccess", NULL, "V", 0x4, NULL },
    { "next", NULL, "Z", 0x11, NULL },
    { "detachWithBoolean:", "detach", "Lcom.graphhopper.util.EdgeIteratorState;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "filter_", NULL, 0x10, "Lcom.graphhopper.routing.util.EdgeFilter;", NULL,  },
    { "nextEdgeId_", NULL, 0x0, "I", NULL,  },
  };
  static const J2ObjcClassInfo _BaseGraph_EdgeIterable = { 1, "EdgeIterable", "com.graphhopper.storage", "BaseGraph", 0xc, 8, methods, 2, fields, 0, NULL};
  return &_BaseGraph_EdgeIterable;
}

@end

void BaseGraph_EdgeIterable_setEdgeIdWithInt_(BaseGraph_EdgeIterable *self, jint edgeId) {
  self->nextEdgeId_ = self->edgeId_ = edgeId;
}

jboolean BaseGraph_EdgeIterable_init__WithInt_withInt_(BaseGraph_EdgeIterable *self, jint tmpEdgeId, jint expectedAdjNode) {
  BaseGraph_EdgeIterable_setEdgeIdWithInt_(self, tmpEdgeId);
  if (tmpEdgeId != EdgeIterator_NO_EDGE) {
    [self selectEdgeAccess];
    self->edgePointer_ = [((EdgeAccess *) nil_chk(self->edgeAccess_)) toPointerWithInt:tmpEdgeId];
  }
  self->baseNode_ = [((id<DataAccess>) nil_chk(((EdgeAccess *) nil_chk(self->edgeAccess_))->edges_)) getIntWithLong:self->edgePointer_ + self->edgeAccess_->E_NODEA_];
  if (self->baseNode_ == EdgeAccess_NO_NODE) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$", @"content of edgeId ", self->edgeId_, @" is marked as invalid - ie. the edge is already removed!")] autorelease];
  self->adjNode_ = [self->edgeAccess_->edges_ getIntWithLong:self->edgePointer_ + self->edgeAccess_->E_NODEB_];
  self->nextEdgeId_ = EdgeIterator_NO_EDGE;
  if (expectedAdjNode == self->adjNode_ || expectedAdjNode == JavaLangInteger_MIN_VALUE) {
    self->reverse_ = NO;
    return YES;
  }
  else if (expectedAdjNode == self->baseNode_) {
    self->reverse_ = YES;
    self->baseNode_ = self->adjNode_;
    self->adjNode_ = expectedAdjNode;
    return YES;
  }
  return NO;
}

void BaseGraph_EdgeIterable__setBaseNodeWithInt_(BaseGraph_EdgeIterable *self, jint baseNode) {
  self->baseNode_ = baseNode;
}

jboolean BaseGraph_EdgeIterable_next(BaseGraph_EdgeIterable *self) {
  while (YES) {
    if (self->nextEdgeId_ == EdgeIterator_NO_EDGE) return NO;
    [self selectEdgeAccess];
    self->edgePointer_ = [((EdgeAccess *) nil_chk(self->edgeAccess_)) toPointerWithInt:self->nextEdgeId_];
    self->edgeId_ = self->nextEdgeId_;
    self->adjNode_ = [self->edgeAccess_ getOtherNodeWithInt:self->baseNode_ withLong:self->edgePointer_];
    self->reverse_ = (self->baseNode_ > self->adjNode_);
    self->freshFlags_ = NO;
    self->nextEdgeId_ = [self->edgeAccess_ getEdgeRefWithInt:self->baseNode_ withInt:self->adjNode_ withLong:self->edgePointer_];
    NSCAssert(self->nextEdgeId_ != self->edgeId_, [(JreStrcat("$I$I$J$I" J2OBJC_COMMA() @"endless loop detected for base node: " J2OBJC_COMMA() self->baseNode_ J2OBJC_COMMA() @" J2OBJC_COMMA() adj node: " J2OBJC_COMMA() self->adjNode_ J2OBJC_COMMA() @" J2OBJC_COMMA() edge pointer: " J2OBJC_COMMA() self->edgePointer_ J2OBJC_COMMA() @" J2OBJC_COMMA() edge: " J2OBJC_COMMA() self->edgeId_)) description]);
    if ([((id<EdgeFilter>) nil_chk(self->filter_)) acceptWithEdgeIteratorState:self]) return YES;
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(BaseGraph_EdgeIterable)

@implementation BaseGraph_AllEdgeIterator

- (instancetype)initWithBaseGraph:(BaseGraph *)baseGraph {
  return [self initBaseGraph_AllEdgeIteratorWithBaseGraph:baseGraph withEdgeAccess:((BaseGraph *) nil_chk(baseGraph))->edgeAccess_];
}

- (instancetype)initBaseGraph_AllEdgeIteratorWithBaseGraph:(BaseGraph *)baseGraph
                                            withEdgeAccess:(EdgeAccess *)edgeAccess {
  return [super initWithLong:-1 withEdgeAccess:edgeAccess withBaseGraph:baseGraph];
}

- (instancetype)initWithBaseGraph:(BaseGraph *)baseGraph
                   withEdgeAccess:(EdgeAccess *)edgeAccess {
  return [self initBaseGraph_AllEdgeIteratorWithBaseGraph:baseGraph withEdgeAccess:edgeAccess];
}

- (jint)getMaxId {
  return ((BaseGraph *) nil_chk(baseGraph_))->edgeCount_;
}

- (jboolean)next {
  while (YES) {
    edgeId_++;
    edgePointer_ = (jlong) edgeId_ * [((EdgeAccess *) nil_chk(edgeAccess_)) getEntryBytes];
    if (![self checkRange]) return NO;
    baseNode_ = [((id<DataAccess>) nil_chk(edgeAccess_->edges_)) getIntWithLong:edgePointer_ + edgeAccess_->E_NODEA_];
    if (baseNode_ == EdgeAccess_NO_NODE) continue;
    freshFlags_ = NO;
    adjNode_ = [edgeAccess_->edges_ getIntWithLong:edgePointer_ + edgeAccess_->E_NODEB_];
    reverse_ = NO;
    return YES;
  }
}

- (jboolean)checkRange {
  return edgeId_ < ((BaseGraph *) nil_chk(baseGraph_))->edgeCount_;
}

- (id<EdgeIteratorState>)detachWithBoolean:(jboolean)reverseArg {
  if (edgePointer_ < 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"call next before detaching"] autorelease];
  BaseGraph_AllEdgeIterator *iter = [[[BaseGraph_AllEdgeIterator alloc] initWithBaseGraph:baseGraph_ withEdgeAccess:edgeAccess_] autorelease];
  iter->edgeId_ = edgeId_;
  iter->edgePointer_ = edgePointer_;
  if (reverseArg) {
    iter->reverse_ = !self->reverse_;
    iter->baseNode_ = adjNode_;
    iter->adjNode_ = baseNode_;
  }
  else {
    iter->reverse_ = self->reverse_;
    iter->baseNode_ = baseNode_;
    iter->adjNode_ = adjNode_;
  }
  return iter;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithBaseGraph:", "AllEdgeIterator", NULL, 0x1, NULL },
    { "initWithBaseGraph:withEdgeAccess:", "AllEdgeIterator", NULL, 0x2, NULL },
    { "getMaxId", NULL, "I", 0x1, NULL },
    { "next", NULL, "Z", 0x1, NULL },
    { "checkRange", NULL, "Z", 0x4, NULL },
    { "detachWithBoolean:", "detach", "Lcom.graphhopper.util.EdgeIteratorState;", 0x11, NULL },
  };
  static const J2ObjcClassInfo _BaseGraph_AllEdgeIterator = { 1, "AllEdgeIterator", "com.graphhopper.storage", "BaseGraph", 0xc, 6, methods, 0, NULL, 0, NULL};
  return &_BaseGraph_AllEdgeIterator;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(BaseGraph_AllEdgeIterator)

@implementation BaseGraph_$1

- (BaseGraph_EdgeIterable *)createSingleEdgeWithEdgeFilter:(id<EdgeFilter>)filter {
  return [[[BaseGraph_EdgeIterable alloc] initWithBaseGraph:this$0_ withEdgeAccess:self withEdgeFilter:filter] autorelease];
}

- (jint)getEdgeRefWithInt:(jint)nodeId {
  return [((id<DataAccess>) nil_chk(this$0_->nodes_)) getIntWithLong:(jlong) nodeId * this$0_->nodeEntryBytes_ + this$0_->N_EDGE_REF_];
}

- (void)setEdgeRefWithInt:(jint)nodeId
                  withInt:(jint)edgeId {
  [((id<DataAccess>) nil_chk(this$0_->nodes_)) setIntWithLong:(jlong) nodeId * this$0_->nodeEntryBytes_ + this$0_->N_EDGE_REF_ withInt:edgeId];
}

- (jint)getEntryBytes {
  return this$0_->edgeEntryBytes_;
}

- (jlong)toPointerWithInt:(jint)edgeId {
  NSAssert(BaseGraph_$1_isInBoundsWithInt_(self, edgeId), [JreStrcat("$I$IC" J2OBJC_COMMA() @"edgeId " J2OBJC_COMMA() edgeId J2OBJC_COMMA() @" not in bounds [0 J2OBJC_COMMA()" J2OBJC_COMMA() this$0_->edgeCount_ J2OBJC_COMMA() ')') description]);
  return (jlong) edgeId * this$0_->edgeEntryBytes_;
}

- (jboolean)isInBoundsWithInt:(jint)edgeId {
  return BaseGraph_$1_isInBoundsWithInt_(self, edgeId);
}

- (jlong)reverseFlagsWithLong:(jlong)edgePointer
                     withLong:(jlong)flags {
  return [((EncodingManager *) nil_chk(val$encodingManager_)) reverseFlagsWithLong:flags];
}

- (NSString *)description {
  return @"base edge access";
}

- (instancetype)initWithBaseGraph:(BaseGraph *)outer$
                   withDataAccess:(id<DataAccess>)arg$0
                      withBitUtil:(BitUtil *)arg$1
              withEncodingManager:(EncodingManager *)capture$0 {
  BaseGraph_$1_set_this$0_(self, outer$);
  BaseGraph_$1_set_val$encodingManager_(self, capture$0);
  return [super initWithDataAccess:arg$0 withBitUtil:arg$1];
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(val$encodingManager_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(BaseGraph_$1 *)other {
  [super copyAllFieldsTo:other];
  BaseGraph_$1_set_this$0_(other, this$0_);
  BaseGraph_$1_set_val$encodingManager_(other, val$encodingManager_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "createSingleEdgeWithEdgeFilter:", "createSingleEdge", "Lcom.graphhopper.storage.BaseGraph$EdgeIterable;", 0x10, NULL },
    { "getEdgeRefWithInt:", "getEdgeRef", "I", 0x10, NULL },
    { "setEdgeRefWithInt:withInt:", "setEdgeRef", "V", 0x10, NULL },
    { "getEntryBytes", NULL, "I", 0x10, NULL },
    { "toPointerWithInt:", "toPointer", "J", 0x10, NULL },
    { "isInBoundsWithInt:", "isInBounds", "Z", 0x10, NULL },
    { "reverseFlagsWithLong:withLong:", "reverseFlags", "J", 0x10, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "initWithBaseGraph:withDataAccess:withBitUtil:withEncodingManager:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lcom.graphhopper.storage.BaseGraph;", NULL,  },
    { "val$encodingManager_", NULL, 0x1012, "Lcom.graphhopper.routing.util.EncodingManager;", NULL,  },
  };
  static const J2ObjcClassInfo _BaseGraph_$1 = { 1, "$1", "com.graphhopper.storage", "BaseGraph", 0x8000, 9, methods, 2, fields, 0, NULL};
  return &_BaseGraph_$1;
}

@end

jboolean BaseGraph_$1_isInBoundsWithInt_(BaseGraph_$1 *self, jint edgeId) {
  return edgeId < self->this$0_->edgeCount_ && edgeId >= 0;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(BaseGraph_$1)
