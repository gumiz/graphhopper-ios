//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/storage/AbstractDataAccess.h"
#include "com/graphhopper/storage/DAType.h"
#include "com/graphhopper/storage/DataAccess.h"
#include "com/graphhopper/storage/RAMDataAccess.h"
#include "com/graphhopper/util/BitUtil.h"
#include "java/io/File.h"
#include "java/io/IOException.h"
#include "java/io/RandomAccessFile.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/IllegalThreadStateException.h"
#include "java/lang/Math.h"
#include "java/lang/OutOfMemoryError.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/System.h"
#include "java/nio/ByteOrder.h"
#include "java/util/Arrays.h"
#include "org/slf4j/Logger.h"
#include "org/slf4j/LoggerFactory.h"

@interface RAMDataAccess () {
 @public
  IOSObjectArray *segments_;
  jboolean store__;
}
@end

J2OBJC_FIELD_SETTER(RAMDataAccess, segments_, IOSObjectArray *)

@implementation RAMDataAccess

- (instancetype)initWithNSString:(NSString *)name
                    withNSString:(NSString *)location
                     withBoolean:(jboolean)store
            withJavaNioByteOrder:(JavaNioByteOrder *)order {
  if (self = [super initWithNSString:name withNSString:location withJavaNioByteOrder:order]) {
    RAMDataAccess_setAndConsume_segments_(self, [IOSObjectArray newArrayWithLength:0 type:IOSClass_byteArray(1)]);
    self->store__ = store;
  }
  return self;
}

- (RAMDataAccess *)storeWithBoolean:(jboolean)store {
  self->store__ = store;
  return self;
}

- (jboolean)isStoring {
  return store__;
}

- (id<DataAccess>)copyToWithDataAccess:(id<DataAccess>)da {
  if ([da isKindOfClass:[RAMDataAccess class]]) {
    [self copyHeaderWithDataAccess:da];
    RAMDataAccess *rda = (RAMDataAccess *) check_class_cast(da, [RAMDataAccess class]);
    RAMDataAccess_setAndConsume_segments_(nil_chk(rda), [IOSObjectArray newArrayWithLength:((IOSObjectArray *) nil_chk(segments_))->size_ type:IOSClass_byteArray(1)]);
    for (jint i = 0; i < segments_->size_; i++) {
      IOSByteArray *area = IOSObjectArray_Get(segments_, i);
      IOSObjectArray_Set(rda->segments_, i, JavaUtilArrays_copyOfWithByteArray_withInt_(area, ((IOSByteArray *) nil_chk(area))->size_));
    }
    [rda setSegmentSizeWithInt:segmentSizeInBytes_];
    return da;
  }
  else {
    return [super copyToWithDataAccess:da];
  }
}

- (RAMDataAccess *)createWithLong:(jlong)bytes {
  if (((IOSObjectArray *) nil_chk(segments_))->size_ > 0) @throw [[[JavaLangIllegalThreadStateException alloc] initWithNSString:@"already created"] autorelease];
  [self setSegmentSizeWithInt:segmentSizeInBytes_];
  [self ensureCapacityWithLong:JavaLangMath_maxWithLong_withLong_(10 * 4, bytes)];
  return self;
}

- (jboolean)ensureCapacityWithLong:(jlong)bytes {
  if (bytes < 0) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"new capacity has to be strictly positive"] autorelease];
  jlong cap = [self getCapacity];
  jlong newBytes = bytes - cap;
  if (newBytes <= 0) return NO;
  jint segmentsToCreate = (jint) (newBytes / segmentSizeInBytes_);
  if (newBytes % segmentSizeInBytes_ != 0) segmentsToCreate++;
  @try {
    IOSObjectArray *newSegs = JavaUtilArrays_copyOfWithNSObjectArray_withInt_(segments_, ((IOSObjectArray *) nil_chk(segments_))->size_ + segmentsToCreate);
    for (jint i = segments_->size_; i < ((IOSObjectArray *) nil_chk(newSegs))->size_; i++) {
      IOSObjectArray_SetAndConsume(newSegs, i, [IOSByteArray newArrayWithLength:LShift32(1, segmentSizePower_)]);
    }
    RAMDataAccess_set_segments_(self, newSegs);
  }
  @catch (JavaLangOutOfMemoryError *err) {
    @throw [[[JavaLangOutOfMemoryError alloc] initWithNSString:JreStrcat("$$J$J$I$I$I", [((JavaLangOutOfMemoryError *) nil_chk(err)) getMessage], @" - problem when allocating new memory. Old capacity: ", cap, @", new bytes:", newBytes, @", segmentSizeIntsPower:", segmentSizePower_, @", new segments:", segmentsToCreate, @", existing:", ((IOSObjectArray *) nil_chk(segments_))->size_)] autorelease];
  }
  return YES;
}

- (jboolean)loadExisting {
  if (((IOSObjectArray *) nil_chk(segments_))->size_ > 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"already initialized"] autorelease];
  if ([self isClosed]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"already closed"] autorelease];
  if (!store__) return NO;
  JavaIoFile *file = [[[JavaIoFile alloc] initWithNSString:[self getFullName]] autorelease];
  if (![file exists] || [file length] == 0) return NO;
  @try {
    JavaIoRandomAccessFile *raFile = [[[JavaIoRandomAccessFile alloc] initWithNSString:[self getFullName] withNSString:@"r"] autorelease];
    @try {
      jlong byteCount = [self readHeaderWithJavaIoRandomAccessFile:raFile] - AbstractDataAccess_HEADER_OFFSET;
      if (byteCount < 0) return NO;
      [raFile seekWithLong:AbstractDataAccess_HEADER_OFFSET];
      jint segmentCount = (jint) (byteCount / segmentSizeInBytes_);
      if (byteCount % segmentSizeInBytes_ != 0) segmentCount++;
      RAMDataAccess_setAndConsume_segments_(self, [IOSObjectArray newArrayWithLength:segmentCount type:IOSClass_byteArray(1)]);
      for (jint s = 0; s < segmentCount; s++) {
        IOSByteArray *bytes = [IOSByteArray arrayWithLength:segmentSizeInBytes_];
        jint read = [raFile readWithByteArray:bytes];
        if (read <= 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$I$$", @"segment ", s, @" is empty? ", [self description])] autorelease];
        IOSObjectArray_Set(segments_, s, bytes);
      }
      return YES;
    }
    @finally {
      [raFile close];
    }
  }
  @catch (JavaIoIOException *ex) {
    @throw [[[JavaLangRuntimeException alloc] initWithNSString:JreStrcat("$$", @"Problem while loading ", [self getFullName]) withJavaLangThrowable:ex] autorelease];
  }
}

- (void)flush {
  if (closed_) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"already closed"] autorelease];
  if (!store__) return;
  @try {
    JavaIoRandomAccessFile *raFile = [[[JavaIoRandomAccessFile alloc] initWithNSString:[self getFullName] withNSString:@"rw"] autorelease];
    @try {
      jlong len = [self getCapacity];
      [self writeHeaderWithJavaIoRandomAccessFile:raFile withLong:len withInt:segmentSizeInBytes_];
      [raFile seekWithLong:AbstractDataAccess_HEADER_OFFSET];
      for (jint s = 0; s < ((IOSObjectArray *) nil_chk(segments_))->size_; s++) {
        IOSByteArray *area = IOSObjectArray_Get(segments_, s);
        [raFile writeWithByteArray:area];
      }
    }
    @finally {
      [raFile close];
    }
  }
  @catch (JavaLangException *ex) {
    @throw [[[JavaLangRuntimeException alloc] initWithNSString:JreStrcat("$$", @"Couldn't store bytes to ", [self description]) withJavaLangThrowable:ex] autorelease];
  }
}

- (void)setIntWithLong:(jlong)bytePos
               withInt:(jint)value {
  NSAssert(segmentSizePower_ > 0, @"call create or loadExisting before usage!");
  jint bufferIndex = (jint) (URShift64(bytePos, segmentSizePower_));
  jint index = (jint) (bytePos & indexDivisor_);
  NSAssert(index + 4 <= segmentSizeInBytes_, @"integer cannot be distributed over two segments");
  [((BitUtil *) nil_chk(bitUtil_)) fromIntWithByteArray:IOSObjectArray_Get(nil_chk(segments_), bufferIndex) withInt:value withInt:index];
}

- (jint)getIntWithLong:(jlong)bytePos {
  NSAssert(segmentSizePower_ > 0, @"call create or loadExisting before usage!");
  jint bufferIndex = (jint) (URShift64(bytePos, segmentSizePower_));
  jint index = (jint) (bytePos & indexDivisor_);
  NSAssert(index + 4 <= segmentSizeInBytes_, @"integer cannot be distributed over two segments");
  if (bufferIndex > ((IOSObjectArray *) nil_chk(segments_))->size_) {
    [((id<OrgSlf4jLogger>) nil_chk(OrgSlf4jLoggerFactory_getLoggerWithIOSClass_([self getClass]))) errorWithNSString:JreStrcat("$$I$I$J$I", [self getName], @", segments:", segments_->size_, @", bufIndex:", bufferIndex, @", bytePos:", bytePos, @", segPower:", segmentSizePower_)];
  }
  return [((BitUtil *) nil_chk(bitUtil_)) toIntWithByteArray:IOSObjectArray_Get(segments_, bufferIndex) withInt:index];
}

- (void)setShortWithLong:(jlong)bytePos
               withShort:(jshort)value {
  NSAssert(segmentSizePower_ > 0, @"call create or loadExisting before usage!");
  jint bufferIndex = (jint) (URShift64(bytePos, segmentSizePower_));
  jint index = (jint) (bytePos & indexDivisor_);
  NSAssert(index + 2 <= segmentSizeInBytes_, @"integer cannot be distributed over two segments");
  [((BitUtil *) nil_chk(bitUtil_)) fromShortWithByteArray:IOSObjectArray_Get(nil_chk(segments_), bufferIndex) withShort:value withInt:index];
}

- (jshort)getShortWithLong:(jlong)bytePos {
  NSAssert(segmentSizePower_ > 0, @"call create or loadExisting before usage!");
  jint bufferIndex = (jint) (URShift64(bytePos, segmentSizePower_));
  jint index = (jint) (bytePos & indexDivisor_);
  NSAssert(index + 2 <= segmentSizeInBytes_, @"integer cannot be distributed over two segments");
  return [((BitUtil *) nil_chk(bitUtil_)) toShortWithByteArray:IOSObjectArray_Get(nil_chk(segments_), bufferIndex) withInt:index];
}

- (void)setBytesWithLong:(jlong)bytePos
           withByteArray:(IOSByteArray *)values
                 withInt:(jint)length {
  NSAssert(length <= segmentSizeInBytes_, [JreStrcat("$I$I" J2OBJC_COMMA() @"the length has to be smaller or equal to the segment size: " J2OBJC_COMMA() length J2OBJC_COMMA() @" vs. " J2OBJC_COMMA() segmentSizeInBytes_) description]);
  NSAssert(segmentSizePower_ > 0, @"call create or loadExisting before usage!");
  jint bufferIndex = (jint) (URShift64(bytePos, segmentSizePower_));
  jint index = (jint) (bytePos & indexDivisor_);
  IOSByteArray *seg = IOSObjectArray_Get(nil_chk(segments_), bufferIndex);
  jint delta = index + length - segmentSizeInBytes_;
  if (delta > 0) {
    length -= delta;
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(values, 0, seg, index, length);
    seg = IOSObjectArray_Get(segments_, bufferIndex + 1);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(values, length, seg, 0, delta);
  }
  else {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(values, 0, seg, index, length);
  }
}

- (void)getBytesWithLong:(jlong)bytePos
           withByteArray:(IOSByteArray *)values
                 withInt:(jint)length {
  NSAssert(length <= segmentSizeInBytes_, [JreStrcat("$I$I" J2OBJC_COMMA() @"the length has to be smaller or equal to the segment size: " J2OBJC_COMMA() length J2OBJC_COMMA() @" vs. " J2OBJC_COMMA() segmentSizeInBytes_) description]);
  NSAssert(segmentSizePower_ > 0, @"call create or loadExisting before usage!");
  jint bufferIndex = (jint) (URShift64(bytePos, segmentSizePower_));
  jint index = (jint) (bytePos & indexDivisor_);
  IOSByteArray *seg = IOSObjectArray_Get(nil_chk(segments_), bufferIndex);
  jint delta = index + length - segmentSizeInBytes_;
  if (delta > 0) {
    length -= delta;
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(seg, index, values, 0, length);
    seg = IOSObjectArray_Get(segments_, bufferIndex + 1);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(seg, 0, values, length, delta);
  }
  else {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(seg, index, values, 0, length);
  }
}

- (void)close {
  [super close];
  RAMDataAccess_setAndConsume_segments_(self, [IOSObjectArray newArrayWithLength:0 type:IOSClass_byteArray(1)]);
  closed_ = YES;
}

- (jlong)getCapacity {
  return (jlong) [self getSegments] * segmentSizeInBytes_;
}

- (jint)getSegments {
  return ((IOSObjectArray *) nil_chk(segments_))->size_;
}

- (void)trimToWithLong:(jlong)capacity {
  if (capacity > [self getCapacity]) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$J$J$", @"Cannot increase capacity (", [self getCapacity], @") to ", capacity, @" via trimTo. Use ensureCapacity instead. ")] autorelease];
  }
  if (capacity < segmentSizeInBytes_) capacity = segmentSizeInBytes_;
  jint remainingSegments = (jint) (capacity / segmentSizeInBytes_);
  if (capacity % segmentSizeInBytes_ != 0) {
    remainingSegments++;
  }
  RAMDataAccess_set_segments_(self, JavaUtilArrays_copyOfWithNSObjectArray_withInt_(segments_, remainingSegments));
}

- (void)renameWithNSString:(NSString *)newName {
  if (![self checkBeforeRenameWithNSString:newName]) {
    return;
  }
  if (store__) {
    [super renameWithNSString:newName];
  }
  AbstractDataAccess_set_name_(self, newName);
}

- (DAType *)getType {
  if ([self isStoring]) return DAType_get_RAM_STORE_();
  return DAType_get_RAM_();
}

- (void)dealloc {
  RELEASE_(segments_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(RAMDataAccess *)other {
  [super copyAllFieldsTo:other];
  RAMDataAccess_set_segments_(other, segments_);
  other->store__ = store__;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithNSString:withNSString:withBoolean:withJavaNioByteOrder:", "RAMDataAccess", NULL, 0x0, NULL },
    { "storeWithBoolean:", "store", "Lcom.graphhopper.storage.RAMDataAccess;", 0x1, NULL },
    { "isStoring", NULL, "Z", 0x1, NULL },
    { "copyToWithDataAccess:", "copyTo", "Lcom.graphhopper.storage.DataAccess;", 0x1, NULL },
    { "createWithLong:", "create", "Lcom.graphhopper.storage.RAMDataAccess;", 0x1, NULL },
    { "ensureCapacityWithLong:", "ensureCapacity", "Z", 0x1, NULL },
    { "loadExisting", NULL, "Z", 0x1, NULL },
    { "flush", NULL, "V", 0x1, NULL },
    { "setIntWithLong:withInt:", "setInt", "V", 0x11, NULL },
    { "getIntWithLong:", "getInt", "I", 0x11, NULL },
    { "setShortWithLong:withShort:", "setShort", "V", 0x11, NULL },
    { "getShortWithLong:", "getShort", "S", 0x11, NULL },
    { "setBytesWithLong:withByteArray:withInt:", "setBytes", "V", 0x1, NULL },
    { "getBytesWithLong:withByteArray:withInt:", "getBytes", "V", 0x1, NULL },
    { "close", NULL, "V", 0x1, NULL },
    { "getCapacity", NULL, "J", 0x1, NULL },
    { "getSegments", NULL, "I", 0x1, NULL },
    { "trimToWithLong:", "trimTo", "V", 0x1, NULL },
    { "renameWithNSString:", "rename", "V", 0x1, NULL },
    { "getType", NULL, "Lcom.graphhopper.storage.DAType;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "segments_", NULL, 0x2, "[[B", NULL,  },
    { "store__", "store", 0x2, "Z", NULL,  },
  };
  static const J2ObjcClassInfo _RAMDataAccess = { 1, "RAMDataAccess", "com.graphhopper.storage", NULL, 0x1, 20, methods, 2, fields, 0, NULL};
  return &_RAMDataAccess;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RAMDataAccess)
