//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/storage/StorableProperties.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/storage/DataAccess.h"
#include "com/graphhopper/storage/Directory.h"
#include "com/graphhopper/storage/StorableProperties.h"
#include "com/graphhopper/util/Constants.h"
#include "com/graphhopper/util/Helper.h"
#include "java/io/IOException.h"
#include "java/io/StringReader.h"
#include "java/io/StringWriter.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/RuntimeException.h"
#include "java/nio/charset/Charset.h"
#include "java/util/LinkedHashMap.h"
#include "java/util/Map.h"

@interface StorableProperties () {
 @public
  id<JavaUtilMap> map_;
  id<DataAccess> da_;
}
@end

J2OBJC_FIELD_SETTER(StorableProperties, map_, id<JavaUtilMap>)
J2OBJC_FIELD_SETTER(StorableProperties, da_, id<DataAccess>)

@implementation StorableProperties

- (instancetype)initWithDirectory:(id<Directory>)dir {
  if (self = [super init]) {
    StorableProperties_setAndConsume_map_(self, [[JavaUtilLinkedHashMap alloc] init]);
    StorableProperties_set_da_(self, [((id<Directory>) nil_chk(dir)) findWithNSString:@"properties"]);
    [((id<DataAccess>) nil_chk(da_)) setSegmentSizeWithInt:LShift32(1, 15)];
  }
  return self;
}

- (jboolean)loadExisting {
  @synchronized(self) {
    if (![((id<DataAccess>) nil_chk(da_)) loadExisting]) return NO;
    jint len = (jint) [da_ getCapacity];
    IOSByteArray *bytes = [IOSByteArray arrayWithLength:len];
    [da_ getBytesWithLong:0 withByteArray:bytes withInt:len];
    @try {
      Helper_loadPropertiesWithJavaUtilMap_withJavaIoReader_(map_, [[[JavaIoStringReader alloc] initWithNSString:[NSString stringWithBytes:bytes charset:Helper_get_UTF_CS_()]] autorelease]);
      return YES;
    }
    @catch (JavaIoIOException *ex) {
      @throw [[[JavaLangIllegalStateException alloc] initWithJavaLangThrowable:ex] autorelease];
    }
  }
}

- (void)flush {
  @synchronized(self) {
    @try {
      JavaIoStringWriter *sw = [[[JavaIoStringWriter alloc] init] autorelease];
      Helper_savePropertiesWithJavaUtilMap_withJavaIoWriter_(map_, sw);
      IOSByteArray *bytes = [((NSString *) nil_chk([sw description])) getBytesWithCharset:Helper_get_UTF_CS_()];
      [((id<DataAccess>) nil_chk(da_)) setBytesWithLong:0 withByteArray:bytes withInt:((IOSByteArray *) nil_chk(bytes))->size_];
      [da_ flush];
    }
    @catch (JavaIoIOException *ex) {
      @throw [[[JavaLangRuntimeException alloc] initWithJavaLangThrowable:ex] autorelease];
    }
  }
}

- (StorableProperties *)removeWithNSString:(NSString *)key {
  @synchronized(self) {
    [((id<JavaUtilMap>) nil_chk(map_)) removeWithId:key];
    return self;
  }
}

- (StorableProperties *)putAllWithJavaUtilMap:(id<JavaUtilMap>)externMap {
  @synchronized(self) {
    [((id<JavaUtilMap>) nil_chk(map_)) putAllWithJavaUtilMap:externMap];
    return self;
  }
}

- (StorableProperties *)putWithNSString:(NSString *)key
                           withNSString:(NSString *)val {
  @synchronized(self) {
    [((id<JavaUtilMap>) nil_chk(map_)) putWithId:key withId:val];
    return self;
  }
}

- (StorableProperties *)putWithNSString:(NSString *)key
                                 withId:(id)val {
  @synchronized(self) {
    if (![key isEqual:[((NSString *) nil_chk(key)) lowercaseString]]) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$$$", @"Do not use upper case keys (", key, @") for StorableProperties since 0.7")] autorelease];
    [((id<JavaUtilMap>) nil_chk(map_)) putWithId:key withId:[nil_chk(val) description]];
    return self;
  }
}

- (NSString *)getWithNSString:(NSString *)key {
  @synchronized(self) {
    if (![key isEqual:[((NSString *) nil_chk(key)) lowercaseString]]) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$$$", @"Do not use upper case keys (", key, @") for StorableProperties since 0.7")] autorelease];
    NSString *ret = [((id<JavaUtilMap>) nil_chk(map_)) getWithId:key];
    if (ret == nil) return @"";
    return ret;
  }
}

- (void)close {
  @synchronized(self) {
    [((id<DataAccess>) nil_chk(da_)) close];
  }
}

- (jboolean)isClosed {
  @synchronized(self) {
    return [((id<DataAccess>) nil_chk(da_)) isClosed];
  }
}

- (StorableProperties *)createWithLong:(jlong)size {
  @synchronized(self) {
    [((id<DataAccess>) nil_chk(da_)) createWithLong:size];
    return self;
  }
}

- (jlong)getCapacity {
  @synchronized(self) {
    return [((id<DataAccess>) nil_chk(da_)) getCapacity];
  }
}

- (void)putCurrentVersions {
  @synchronized(self) {
    [self putWithNSString:@"nodes.version" withId:JavaLangInteger_valueOfWithInt_(Constants_VERSION_NODE)];
    [self putWithNSString:@"edges.version" withId:JavaLangInteger_valueOfWithInt_(Constants_VERSION_EDGE)];
    [self putWithNSString:@"geometry.version" withId:JavaLangInteger_valueOfWithInt_(Constants_VERSION_GEOMETRY)];
    [self putWithNSString:@"location_index.version" withId:JavaLangInteger_valueOfWithInt_(Constants_VERSION_LOCATION_IDX)];
    [self putWithNSString:@"name_index.version" withId:JavaLangInteger_valueOfWithInt_(Constants_VERSION_NAME_IDX)];
    [self putWithNSString:@"shortcuts.version" withId:JavaLangInteger_valueOfWithInt_(Constants_VERSION_SHORTCUT)];
  }
}

- (NSString *)versionsToString {
  @synchronized(self) {
    return JreStrcat("$C$C$C$C$", [self getWithNSString:@"nodes.version"], ',', [self getWithNSString:@"edges.version"], ',', [self getWithNSString:@"geometry.version"], ',', [self getWithNSString:@"location_index.version"], ',', [self getWithNSString:@"name_index.version"]);
  }
}

- (jboolean)checkVersionsWithBoolean:(jboolean)silent {
  @synchronized(self) {
    if (![self checkWithNSString:@"nodes" withInt:Constants_VERSION_NODE withBoolean:silent]) return NO;
    if (![self checkWithNSString:@"edges" withInt:Constants_VERSION_EDGE withBoolean:silent]) return NO;
    if (![self checkWithNSString:@"geometry" withInt:Constants_VERSION_GEOMETRY withBoolean:silent]) return NO;
    if (![self checkWithNSString:@"location_index" withInt:Constants_VERSION_LOCATION_IDX withBoolean:silent]) return NO;
    if (![self checkWithNSString:@"name_index" withInt:Constants_VERSION_NAME_IDX withBoolean:silent]) return NO;
    if (![self checkWithNSString:@"shortcuts" withInt:Constants_VERSION_SHORTCUT withBoolean:silent]) return NO;
    return YES;
  }
}

- (jboolean)checkWithNSString:(NSString *)key
                      withInt:(jint)vers
                  withBoolean:(jboolean)silent {
  NSString *str = [self getWithNSString:JreStrcat("$$", key, @".version")];
  if (![((NSString *) nil_chk(str)) isEqual:JreStrcat("I", vers)]) {
    if (silent) return NO;
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$$$$$I$", @"Version of ", key, @" unsupported: ", str, @", expected:", vers, @". Make sure you are using the same GraphHopper version for reading the files that was used for creating them. See https://discuss.graphhopper.com/t/722")] autorelease];
  }
  return YES;
}

- (NSString *)description {
  @synchronized(self) {
    return [((id<DataAccess>) nil_chk(da_)) description];
  }
}

- (void)dealloc {
  RELEASE_(map_);
  RELEASE_(da_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(StorableProperties *)other {
  [super copyAllFieldsTo:other];
  StorableProperties_set_map_(other, map_);
  StorableProperties_set_da_(other, da_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithDirectory:", "StorableProperties", NULL, 0x1, NULL },
    { "loadExisting", NULL, "Z", 0x21, NULL },
    { "flush", NULL, "V", 0x21, NULL },
    { "removeWithNSString:", "remove", "Lcom.graphhopper.storage.StorableProperties;", 0x21, NULL },
    { "putAllWithJavaUtilMap:", "putAll", "Lcom.graphhopper.storage.StorableProperties;", 0x21, NULL },
    { "putWithNSString:withNSString:", "put", "Lcom.graphhopper.storage.StorableProperties;", 0x21, NULL },
    { "putWithNSString:withId:", "put", "Lcom.graphhopper.storage.StorableProperties;", 0x21, NULL },
    { "getWithNSString:", "get", "Ljava.lang.String;", 0x21, NULL },
    { "close", NULL, "V", 0x21, NULL },
    { "isClosed", NULL, "Z", 0x21, NULL },
    { "createWithLong:", "create", "Lcom.graphhopper.storage.StorableProperties;", 0x21, NULL },
    { "getCapacity", NULL, "J", 0x21, NULL },
    { "putCurrentVersions", NULL, "V", 0x21, NULL },
    { "versionsToString", NULL, "Ljava.lang.String;", 0x21, NULL },
    { "checkVersionsWithBoolean:", "checkVersions", "Z", 0x21, NULL },
    { "checkWithNSString:withInt:withBoolean:", "check", "Z", 0x0, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x21, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "map_", NULL, 0x12, "Ljava.util.Map;", NULL,  },
    { "da_", NULL, 0x12, "Lcom.graphhopper.storage.DataAccess;", NULL,  },
  };
  static const J2ObjcClassInfo _StorableProperties = { 1, "StorableProperties", "com.graphhopper.storage", NULL, 0x1, 17, methods, 2, fields, 0, NULL};
  return &_StorableProperties;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(StorableProperties)
