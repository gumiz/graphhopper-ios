//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/storage/AbstractDataAccess.h"
#include "com/graphhopper/storage/DAType.h"
#include "com/graphhopper/storage/DataAccess.h"
#include "com/graphhopper/storage/RAMIntDataAccess.h"
#include "com/graphhopper/util/BitUtil.h"
#include "java/io/File.h"
#include "java/io/IOException.h"
#include "java/io/RandomAccessFile.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalMonitorStateException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/IllegalThreadStateException.h"
#include "java/lang/Math.h"
#include "java/lang/OutOfMemoryError.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/nio/ByteOrder.h"
#include "java/util/Arrays.h"

@interface RAMIntDataAccess () {
 @public
  IOSObjectArray *segments_;
  jboolean closed_RAMIntDataAccess_;
  jboolean store_;
  jint segmentSizeIntsPower_;
}
@end

J2OBJC_FIELD_SETTER(RAMIntDataAccess, segments_, IOSObjectArray *)

@implementation RAMIntDataAccess

- (instancetype)initWithNSString:(NSString *)name
                    withNSString:(NSString *)location
                     withBoolean:(jboolean)store
            withJavaNioByteOrder:(JavaNioByteOrder *)order {
  if (self = [super initWithNSString:name withNSString:location withJavaNioByteOrder:order]) {
    RAMIntDataAccess_setAndConsume_segments_(self, [IOSObjectArray newArrayWithLength:0 type:IOSClass_intArray(1)]);
    closed_RAMIntDataAccess_ = NO;
    self->store_ = store;
  }
  return self;
}

- (RAMIntDataAccess *)setStoreWithBoolean:(jboolean)store {
  self->store_ = store;
  return self;
}

- (jboolean)isStoring {
  return store_;
}

- (id<DataAccess>)copyToWithDataAccess:(id<DataAccess>)da {
  if ([da isKindOfClass:[RAMIntDataAccess class]]) {
    [self copyHeaderWithDataAccess:da];
    RAMIntDataAccess *rda = (RAMIntDataAccess *) check_class_cast(da, [RAMIntDataAccess class]);
    RAMIntDataAccess_setAndConsume_segments_(nil_chk(rda), [IOSObjectArray newArrayWithLength:((IOSObjectArray *) nil_chk(segments_))->size_ type:IOSClass_intArray(1)]);
    for (jint i = 0; i < segments_->size_; i++) {
      IOSIntArray *area = IOSObjectArray_Get(segments_, i);
      IOSObjectArray_Set(rda->segments_, i, JavaUtilArrays_copyOfWithIntArray_withInt_(area, ((IOSIntArray *) nil_chk(area))->size_));
    }
    [rda setSegmentSizeWithInt:segmentSizeInBytes_];
    return da;
  }
  else {
    return [super copyToWithDataAccess:da];
  }
}

- (RAMIntDataAccess *)createWithLong:(jlong)bytes {
  if (((IOSObjectArray *) nil_chk(segments_))->size_ > 0) {
    @throw [[[JavaLangIllegalThreadStateException alloc] initWithNSString:@"already created"] autorelease];
  }
  [self setSegmentSizeWithInt:segmentSizeInBytes_];
  [self ensureCapacityWithLong:JavaLangMath_maxWithLong_withLong_(10 * 4, bytes)];
  return self;
}

- (jboolean)ensureCapacityWithLong:(jlong)bytes {
  if (bytes < 0) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"new capacity has to be strictly positive"] autorelease];
  jlong cap = [self getCapacity];
  jlong newBytes = bytes - cap;
  if (newBytes <= 0) return NO;
  jint segmentsToCreate = (jint) (newBytes / segmentSizeInBytes_);
  if (newBytes % segmentSizeInBytes_ != 0) segmentsToCreate++;
  @try {
    IOSObjectArray *newSegs = JavaUtilArrays_copyOfWithNSObjectArray_withInt_(segments_, ((IOSObjectArray *) nil_chk(segments_))->size_ + segmentsToCreate);
    for (jint i = segments_->size_; i < ((IOSObjectArray *) nil_chk(newSegs))->size_; i++) {
      IOSObjectArray_SetAndConsume(newSegs, i, [IOSIntArray newArrayWithLength:LShift32(1, segmentSizeIntsPower_)]);
    }
    RAMIntDataAccess_set_segments_(self, newSegs);
    return YES;
  }
  @catch (JavaLangOutOfMemoryError *err) {
    @throw [[[JavaLangOutOfMemoryError alloc] initWithNSString:JreStrcat("$$J$J$I$I$I", [((JavaLangOutOfMemoryError *) nil_chk(err)) getMessage], @" - problem when allocating new memory. Old capacity: ", cap, @", new bytes:", newBytes, @", segmentSizeIntsPower:", segmentSizeIntsPower_, @", new segments:", segmentsToCreate, @", existing:", ((IOSObjectArray *) nil_chk(segments_))->size_)] autorelease];
  }
}

- (jboolean)loadExisting {
  if (((IOSObjectArray *) nil_chk(segments_))->size_ > 0) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"already initialized"] autorelease];
  if ([self isClosed]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"already closed"] autorelease];
  if (!store_) return NO;
  JavaIoFile *file = [[[JavaIoFile alloc] initWithNSString:[self getFullName]] autorelease];
  if (![file exists] || [file length] == 0) {
    return NO;
  }
  @try {
    JavaIoRandomAccessFile *raFile = [[[JavaIoRandomAccessFile alloc] initWithNSString:[self getFullName] withNSString:@"r"] autorelease];
    @try {
      jlong byteCount = [self readHeaderWithJavaIoRandomAccessFile:raFile] - AbstractDataAccess_HEADER_OFFSET;
      if (byteCount < 0) {
        return NO;
      }
      IOSByteArray *bytes = [IOSByteArray arrayWithLength:segmentSizeInBytes_];
      [raFile seekWithLong:AbstractDataAccess_HEADER_OFFSET];
      jint segmentCount = (jint) (byteCount / segmentSizeInBytes_);
      if (byteCount % segmentSizeInBytes_ != 0) segmentCount++;
      RAMIntDataAccess_setAndConsume_segments_(self, [IOSObjectArray newArrayWithLength:segmentCount type:IOSClass_intArray(1)]);
      for (jint s = 0; s < segmentCount; s++) {
        jint read = [raFile readWithByteArray:bytes] / 4;
        IOSIntArray *area = [IOSIntArray arrayWithLength:read];
        for (jint j = 0; j < read; j++) {
          *IOSIntArray_GetRef(area, j) = [((BitUtil *) nil_chk(bitUtil_)) toIntWithByteArray:bytes withInt:j * 4];
        }
        IOSObjectArray_Set(segments_, s, area);
      }
      return YES;
    }
    @finally {
      [raFile close];
    }
  }
  @catch (JavaIoIOException *ex) {
    @throw [[[JavaLangRuntimeException alloc] initWithNSString:JreStrcat("$$", @"Problem while loading ", [self getFullName]) withJavaLangThrowable:ex] autorelease];
  }
}

- (void)flush {
  if (closed_RAMIntDataAccess_) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"already closed"] autorelease];
  }
  if (!store_) {
    return;
  }
  @try {
    JavaIoRandomAccessFile *raFile = [[[JavaIoRandomAccessFile alloc] initWithNSString:[self getFullName] withNSString:@"rw"] autorelease];
    @try {
      jlong len = [self getCapacity];
      [self writeHeaderWithJavaIoRandomAccessFile:raFile withLong:len withInt:segmentSizeInBytes_];
      [raFile seekWithLong:AbstractDataAccess_HEADER_OFFSET];
      for (jint s = 0; s < ((IOSObjectArray *) nil_chk(segments_))->size_; s++) {
        IOSIntArray *area = IOSObjectArray_Get(segments_, s);
        jint intLen = ((IOSIntArray *) nil_chk(area))->size_;
        IOSByteArray *byteArea = [IOSByteArray arrayWithLength:intLen * 4];
        for (jint i = 0; i < intLen; i++) {
          [((BitUtil *) nil_chk(bitUtil_)) fromIntWithByteArray:byteArea withInt:IOSIntArray_Get(area, i) withInt:i * 4];
        }
        [raFile writeWithByteArray:byteArea];
      }
    }
    @finally {
      [raFile close];
    }
  }
  @catch (JavaLangException *ex) {
    @throw [[[JavaLangRuntimeException alloc] initWithNSString:JreStrcat("$$", @"Couldn't store integers to ", [self description]) withJavaLangThrowable:ex] autorelease];
  }
}

- (void)setIntWithLong:(jlong)bytePos
               withInt:(jint)value {
  NSAssert(segmentSizeIntsPower_ > 0, @"call create or loadExisting before usage!");
  URShiftAssignLong(&bytePos, 2);
  jint bufferIndex = (jint) (URShift64(bytePos, segmentSizeIntsPower_));
  jint index = (jint) (bytePos & indexDivisor_);
  *IOSIntArray_GetRef(nil_chk(IOSObjectArray_Get(nil_chk(segments_), bufferIndex)), index) = value;
}

- (jint)getIntWithLong:(jlong)bytePos {
  NSAssert(segmentSizeIntsPower_ > 0, @"call create or loadExisting before usage!");
  URShiftAssignLong(&bytePos, 2);
  jint bufferIndex = (jint) (URShift64(bytePos, segmentSizeIntsPower_));
  jint index = (jint) (bytePos & indexDivisor_);
  return IOSIntArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(segments_), bufferIndex)), index);
}

- (void)setShortWithLong:(jlong)bytePos
               withShort:(jshort)value {
  NSAssert(segmentSizeIntsPower_ > 0, @"call create or loadExisting before usage!");
  if (bytePos % 4 != 0 && bytePos % 4 != 2) @throw [[[JavaLangIllegalMonitorStateException alloc] initWithNSString:JreStrcat("$J", @"bytePos of wrong multiple for RAMInt ", bytePos)] autorelease];
  jlong tmpIndex = URShift64(bytePos, 1);
  jint bufferIndex = (jint) (URShift64(tmpIndex, segmentSizeIntsPower_));
  jint index = (jint) (tmpIndex & indexDivisor_);
  if (tmpIndex * 2 == bytePos) *IOSIntArray_GetRef(nil_chk(IOSObjectArray_Get(nil_chk(segments_), bufferIndex)), index) = value;
  else *IOSIntArray_GetRef(nil_chk(IOSObjectArray_Get(nil_chk(segments_), bufferIndex)), index) = LShift32(value, 16);
}

- (jshort)getShortWithLong:(jlong)bytePos {
  NSAssert(segmentSizeIntsPower_ > 0, @"call create or loadExisting before usage!");
  if (bytePos % 4 != 0 && bytePos % 4 != 2) @throw [[[JavaLangIllegalMonitorStateException alloc] initWithNSString:JreStrcat("$J", @"bytePos of wrong multiple for RAMInt ", bytePos)] autorelease];
  jlong tmpIndex = RShift64(bytePos, 1);
  jint bufferIndex = (jint) (RShift64(tmpIndex, segmentSizeIntsPower_));
  jint index = (jint) (tmpIndex & indexDivisor_);
  if (tmpIndex * 2 == bytePos) return (jshort) IOSIntArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(segments_), bufferIndex)), index);
  else return (jshort) (RShift32(IOSIntArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(segments_), bufferIndex)), index), 16));
}

- (void)getBytesWithLong:(jlong)bytePos
           withByteArray:(IOSByteArray *)values
                 withInt:(jint)length {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:JreStrcat("$$", [self description], @" does not support byte based acccess. Use RAMDataAccess instead")] autorelease];
}

- (void)setBytesWithLong:(jlong)bytePos
           withByteArray:(IOSByteArray *)values
                 withInt:(jint)length {
  @throw [[[JavaLangUnsupportedOperationException alloc] initWithNSString:JreStrcat("$$", [self description], @" does not support byte based acccess. Use RAMDataAccess instead")] autorelease];
}

- (void)close {
  [super close];
  RAMIntDataAccess_setAndConsume_segments_(self, [IOSObjectArray newArrayWithLength:0 type:IOSClass_intArray(1)]);
  closed_RAMIntDataAccess_ = YES;
}

- (jlong)getCapacity {
  return (jlong) [self getSegments] * segmentSizeInBytes_;
}

- (jint)getSegments {
  return ((IOSObjectArray *) nil_chk(segments_))->size_;
}

- (id<DataAccess>)setSegmentSizeWithInt:(jint)bytes {
  [super setSegmentSizeWithInt:bytes];
  segmentSizeIntsPower_ = J2ObjCFpToInt((JavaLangMath_logWithDouble_(segmentSizeInBytes_ / 4) / JavaLangMath_logWithDouble_(2)));
  indexDivisor_ = segmentSizeInBytes_ / 4 - 1;
  return self;
}

- (void)trimToWithLong:(jlong)capacity {
  if (capacity < segmentSizeInBytes_) {
    capacity = segmentSizeInBytes_;
  }
  jint remainingSegments = (jint) (capacity / segmentSizeInBytes_);
  if (capacity % segmentSizeInBytes_ != 0) {
    remainingSegments++;
  }
  RAMIntDataAccess_set_segments_(self, JavaUtilArrays_copyOfWithNSObjectArray_withInt_(segments_, remainingSegments));
}

- (jboolean)releaseSegmentWithInt:(jint)segNumber {
  IOSObjectArray_Set(nil_chk(segments_), segNumber, nil);
  return YES;
}

- (void)renameWithNSString:(NSString *)newName {
  if (![self checkBeforeRenameWithNSString:newName]) {
    return;
  }
  if (store_) {
    [super renameWithNSString:newName];
  }
  AbstractDataAccess_set_name_(self, newName);
}

- (jboolean)isIntBased {
  return YES;
}

- (DAType *)getType {
  if ([self isStoring]) return DAType_get_RAM_INT_STORE_();
  return DAType_get_RAM_INT_();
}

- (void)dealloc {
  RELEASE_(segments_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(RAMIntDataAccess *)other {
  [super copyAllFieldsTo:other];
  RAMIntDataAccess_set_segments_(other, segments_);
  other->closed_RAMIntDataAccess_ = closed_RAMIntDataAccess_;
  other->store_ = store_;
  other->segmentSizeIntsPower_ = segmentSizeIntsPower_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithNSString:withNSString:withBoolean:withJavaNioByteOrder:", "RAMIntDataAccess", NULL, 0x0, NULL },
    { "setStoreWithBoolean:", "setStore", "Lcom.graphhopper.storage.RAMIntDataAccess;", 0x1, NULL },
    { "isStoring", NULL, "Z", 0x1, NULL },
    { "copyToWithDataAccess:", "copyTo", "Lcom.graphhopper.storage.DataAccess;", 0x1, NULL },
    { "createWithLong:", "create", "Lcom.graphhopper.storage.RAMIntDataAccess;", 0x1, NULL },
    { "ensureCapacityWithLong:", "ensureCapacity", "Z", 0x1, NULL },
    { "loadExisting", NULL, "Z", 0x1, NULL },
    { "flush", NULL, "V", 0x1, NULL },
    { "setIntWithLong:withInt:", "setInt", "V", 0x11, NULL },
    { "getIntWithLong:", "getInt", "I", 0x11, NULL },
    { "setShortWithLong:withShort:", "setShort", "V", 0x11, NULL },
    { "getShortWithLong:", "getShort", "S", 0x11, NULL },
    { "getBytesWithLong:withByteArray:withInt:", "getBytes", "V", 0x1, NULL },
    { "setBytesWithLong:withByteArray:withInt:", "setBytes", "V", 0x1, NULL },
    { "close", NULL, "V", 0x1, NULL },
    { "getCapacity", NULL, "J", 0x1, NULL },
    { "getSegments", NULL, "I", 0x1, NULL },
    { "setSegmentSizeWithInt:", "setSegmentSize", "Lcom.graphhopper.storage.DataAccess;", 0x1, NULL },
    { "trimToWithLong:", "trimTo", "V", 0x1, NULL },
    { "releaseSegmentWithInt:", "releaseSegment", "Z", 0x0, NULL },
    { "renameWithNSString:", "rename", "V", 0x1, NULL },
    { "isIntBased", NULL, "Z", 0x4, NULL },
    { "getType", NULL, "Lcom.graphhopper.storage.DAType;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "segments_", NULL, 0x2, "[[I", NULL,  },
    { "closed_RAMIntDataAccess_", "closed", 0x2, "Z", NULL,  },
    { "store_", NULL, 0x2, "Z", NULL,  },
    { "segmentSizeIntsPower_", NULL, 0x82, "I", NULL,  },
  };
  static const J2ObjcClassInfo _RAMIntDataAccess = { 1, "RAMIntDataAccess", "com.graphhopper.storage", NULL, 0x0, 23, methods, 4, fields, 0, NULL};
  return &_RAMIntDataAccess;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RAMIntDataAccess)
