//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/graphhopper/storage/AbstractDataAccess.h"
#include "com/graphhopper/storage/DAType.h"
#include "com/graphhopper/storage/DataAccess.h"
#include "com/graphhopper/storage/Storable.h"
#include "com/graphhopper/util/BitUtil.h"
#include "com/graphhopper/util/Helper.h"
#include "java/io/File.h"
#include "java/io/IOException.h"
#include "java/io/RandomAccessFile.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Math.h"
#include "java/nio/ByteOrder.h"

#pragma clang diagnostic ignored "-Wprotocol"

@interface AbstractDataAccess () {
 @public
  NSString *location_;
}
@end

J2OBJC_FIELD_SETTER(AbstractDataAccess, location_, NSString *)

BOOL AbstractDataAccess_initialized = NO;

@implementation AbstractDataAccess

IOSByteArray * AbstractDataAccess_EMPTY_;

- (instancetype)initWithNSString:(NSString *)name
                    withNSString:(NSString *)location
            withJavaNioByteOrder:(JavaNioByteOrder *)order {
  if (self = [super init]) {
    AbstractDataAccess_setAndConsume_header_(self, [IOSIntArray newArrayWithLength:(AbstractDataAccess_HEADER_OFFSET - 20) / 4]);
    segmentSizeInBytes_ = AbstractDataAccess_SEGMENT_SIZE_DEFAULT;
    closed_ = NO;
    AbstractDataAccess_set_byteOrder_(self, order);
    AbstractDataAccess_set_bitUtil_(self, BitUtil_getWithJavaNioByteOrder_(order));
    AbstractDataAccess_set_name_(self, name);
    if (!Helper_isEmptyWithNSString_(location) && ![((NSString *) nil_chk(location)) hasSuffix:@"/"]) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Create DataAccess object via its corresponding Directory!"] autorelease];
    AbstractDataAccess_set_location_(self, location);
  }
  return self;
}

- (NSString *)getName {
  return name_;
}

- (NSString *)getFullName {
  return JreStrcat("$$", location_, name_);
}

- (void)close {
  closed_ = YES;
}

- (jboolean)isClosed {
  return closed_;
}

- (void)setHeaderWithInt:(jint)bytePos
                 withInt:(jint)value {
  RShiftAssignInt(&bytePos, 2);
  *IOSIntArray_GetRef(nil_chk(header_), bytePos) = value;
}

- (jint)getHeaderWithInt:(jint)bytePos {
  RShiftAssignInt(&bytePos, 2);
  return IOSIntArray_Get(nil_chk(header_), bytePos);
}

- (void)writeHeaderWithJavaIoRandomAccessFile:(JavaIoRandomAccessFile *)file
                                     withLong:(jlong)length
                                      withInt:(jint)segmentSize {
  [((JavaIoRandomAccessFile *) nil_chk(file)) seekWithLong:0];
  [file writeUTFWithNSString:@"GH"];
  [file writeLongWithLong:length];
  [file writeIntWithInt:segmentSize];
  for (jint i = 0; i < ((IOSIntArray *) nil_chk(header_))->size_; i++) {
    [file writeIntWithInt:IOSIntArray_Get(header_, i)];
  }
}

- (jlong)readHeaderWithJavaIoRandomAccessFile:(JavaIoRandomAccessFile *)raFile {
  [((JavaIoRandomAccessFile *) nil_chk(raFile)) seekWithLong:0];
  if ([raFile length] == 0) return -1;
  NSString *versionHint = [raFile readUTF];
  if (![@"GH" isEqual:versionHint]) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$$", @"Not a GraphHopper file! Expected 'GH' as file marker but was ", versionHint)] autorelease];
  jlong bytes = [raFile readLong];
  [self setSegmentSizeWithInt:[raFile readInt]];
  for (jint i = 0; i < ((IOSIntArray *) nil_chk(header_))->size_; i++) {
    *IOSIntArray_GetRef(header_, i) = [raFile readInt];
  }
  return bytes;
}

- (void)copyHeaderWithDataAccess:(id<DataAccess>)da {
  for (jint h = 0; h < ((IOSIntArray *) nil_chk(header_))->size_ * 4; h += 4) {
    [((id<DataAccess>) nil_chk(da)) setHeaderWithInt:h withInt:[self getHeaderWithInt:h]];
  }
}

- (id<DataAccess>)copyToWithDataAccess:(id<DataAccess>)da {
  [self copyHeaderWithDataAccess:da];
  [((id<DataAccess>) nil_chk(da)) ensureCapacityWithLong:[self getCapacity]];
  jlong cap = [self getCapacity];
  jint segSize = JavaLangMath_minWithInt_withInt_([da getSegmentSize], [self getSegmentSize]);
  IOSByteArray *bytes = [IOSByteArray arrayWithLength:segSize];
  jboolean externalIntBased = [((AbstractDataAccess *) check_class_cast(da, [AbstractDataAccess class])) isIntBased];
  for (jlong bytePos = 0; bytePos < cap; bytePos += segSize) {
    if ([self isIntBased]) {
      for (jint offset = 0; offset < segSize; offset += 4) {
        [((BitUtil *) nil_chk(bitUtil_)) fromIntWithByteArray:bytes withInt:[self getIntWithLong:bytePos + offset] withInt:offset];
      }
    }
    else {
      [self getBytesWithLong:bytePos withByteArray:bytes withInt:segSize];
    }
    if (externalIntBased) {
      for (jint offset = 0; offset < segSize; offset += 4) {
        [da setIntWithLong:bytePos + offset withInt:[((BitUtil *) nil_chk(bitUtil_)) toIntWithByteArray:bytes withInt:offset]];
      }
    }
    else {
      [da setBytesWithLong:bytePos withByteArray:bytes withInt:segSize];
    }
  }
  return da;
}

- (id<DataAccess>)setSegmentSizeWithInt:(jint)bytes {
  if (bytes > 0) {
    jint tmp = J2ObjCFpToInt((JavaLangMath_logWithDouble_(bytes) / JavaLangMath_logWithDouble_(2)));
    segmentSizeInBytes_ = JavaLangMath_maxWithInt_withInt_(J2ObjCFpToInt(JavaLangMath_powWithDouble_withDouble_(2, tmp)), AbstractDataAccess_SEGMENT_SIZE_MIN);
  }
  segmentSizePower_ = J2ObjCFpToInt((JavaLangMath_logWithDouble_(segmentSizeInBytes_) / JavaLangMath_logWithDouble_(2)));
  indexDivisor_ = segmentSizeInBytes_ - 1;
  return self;
}

- (jint)getSegmentSize {
  return segmentSizeInBytes_;
}

- (NSString *)description {
  return [self getFullName];
}

- (void)renameWithNSString:(NSString *)newName {
  JavaIoFile *file = [[[JavaIoFile alloc] initWithNSString:JreStrcat("$$", location_, name_)] autorelease];
  if ([file exists]) {
    @try {
      if (![file renameToWithJavaIoFile:[[[JavaIoFile alloc] initWithNSString:JreStrcat("$$", location_, newName)] autorelease]]) {
        @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$@$$", @"Couldn't rename this ", [self getType], @" object to ", newName)] autorelease];
      }
      AbstractDataAccess_set_name_(self, newName);
    }
    @catch (JavaLangException *ex) {
      @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$@$", @"Couldn't rename this ", [self getType], @" object!") withJavaLangThrowable:ex] autorelease];
    }
  }
  else {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$$$", @"File does not exist!? ", [self getFullName], @" Make sure that you flushed before renaming. Otherwise it could make problems for memory mapped DataAccess objects")] autorelease];
  }
}

- (jboolean)checkBeforeRenameWithNSString:(NSString *)newName {
  if (Helper_isEmptyWithNSString_(newName)) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"newName mustn't be empty!"] autorelease];
  if ([((NSString *) nil_chk(newName)) isEqual:name_]) return NO;
  if ([self isStoring] && [((JavaIoFile *) [[[JavaIoFile alloc] initWithNSString:JreStrcat("$$", location_, newName)] autorelease]) exists]) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"file newName already exists!"] autorelease];
  return YES;
}

- (jboolean)isStoring {
  return YES;
}

- (jboolean)isIntBased {
  return NO;
}

- (void)dealloc {
  RELEASE_(byteOrder_);
  RELEASE_(bitUtil_);
  RELEASE_(location_);
  RELEASE_(header_);
  RELEASE_(name_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(AbstractDataAccess *)other {
  [super copyAllFieldsTo:other];
  AbstractDataAccess_set_byteOrder_(other, byteOrder_);
  AbstractDataAccess_set_bitUtil_(other, bitUtil_);
  AbstractDataAccess_set_location_(other, location_);
  AbstractDataAccess_set_header_(other, header_);
  AbstractDataAccess_set_name_(other, name_);
  other->segmentSizeInBytes_ = segmentSizeInBytes_;
  other->segmentSizePower_ = segmentSizePower_;
  other->indexDivisor_ = indexDivisor_;
  other->closed_ = closed_;
}

+ (void)initialize {
  if (self == [AbstractDataAccess class]) {
    JreStrongAssignAndConsume(&AbstractDataAccess_EMPTY_, nil, [IOSByteArray newArrayWithLength:1024]);
    J2OBJC_SET_INITIALIZED(AbstractDataAccess)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithNSString:withNSString:withJavaNioByteOrder:", "AbstractDataAccess", NULL, 0x1, NULL },
    { "getName", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "getFullName", NULL, "Ljava.lang.String;", 0x4, NULL },
    { "close", NULL, "V", 0x1, NULL },
    { "isClosed", NULL, "Z", 0x1, NULL },
    { "setHeaderWithInt:withInt:", "setHeader", "V", 0x1, NULL },
    { "getHeaderWithInt:", "getHeader", "I", 0x1, NULL },
    { "writeHeaderWithJavaIoRandomAccessFile:withLong:withInt:", "writeHeader", "V", 0x4, "Ljava.io.IOException;" },
    { "readHeaderWithJavaIoRandomAccessFile:", "readHeader", "J", 0x4, "Ljava.io.IOException;" },
    { "copyHeaderWithDataAccess:", "copyHeader", "V", 0x4, NULL },
    { "copyToWithDataAccess:", "copyTo", "Lcom.graphhopper.storage.DataAccess;", 0x1, NULL },
    { "setSegmentSizeWithInt:", "setSegmentSize", "Lcom.graphhopper.storage.DataAccess;", 0x1, NULL },
    { "getSegmentSize", NULL, "I", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "renameWithNSString:", "rename", "V", 0x1, NULL },
    { "checkBeforeRenameWithNSString:", "checkBeforeRename", "Z", 0x4, NULL },
    { "isStoring", NULL, "Z", 0x1, NULL },
    { "isIntBased", NULL, "Z", 0x4, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "SEGMENT_SIZE_MIN_", NULL, 0x1c, "I", NULL, .constantValue.asInt = AbstractDataAccess_SEGMENT_SIZE_MIN },
    { "HEADER_OFFSET_", NULL, 0x1c, "I", NULL, .constantValue.asInt = AbstractDataAccess_HEADER_OFFSET },
    { "EMPTY_", NULL, 0x1c, "[B", &AbstractDataAccess_EMPTY_,  },
    { "SEGMENT_SIZE_DEFAULT_", NULL, 0x1a, "I", NULL, .constantValue.asInt = AbstractDataAccess_SEGMENT_SIZE_DEFAULT },
    { "byteOrder_", NULL, 0x14, "Ljava.nio.ByteOrder;", NULL,  },
    { "bitUtil_", NULL, 0x14, "Lcom.graphhopper.util.BitUtil;", NULL,  },
    { "location_", NULL, 0x12, "Ljava.lang.String;", NULL,  },
    { "header_", NULL, 0x4, "[I", NULL,  },
    { "name_", NULL, 0x4, "Ljava.lang.String;", NULL,  },
    { "segmentSizeInBytes_", NULL, 0x4, "I", NULL,  },
    { "segmentSizePower_", NULL, 0x84, "I", NULL,  },
    { "indexDivisor_", NULL, 0x84, "I", NULL,  },
    { "closed_", NULL, 0x84, "Z", NULL,  },
  };
  static const J2ObjcClassInfo _AbstractDataAccess = { 1, "AbstractDataAccess", "com.graphhopper.storage", NULL, 0x401, 18, methods, 13, fields, 0, NULL};
  return &_AbstractDataAccess;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AbstractDataAccess)
