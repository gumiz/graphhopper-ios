//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: graphhopper/core/src/main/java/com/graphhopper/storage/GHDirectory.java
//

#include "J2ObjC_source.h"
#include "com/graphhopper/storage/DAType.h"
#include "com/graphhopper/storage/DataAccess.h"
#include "com/graphhopper/storage/Directory.h"
#include "com/graphhopper/storage/GHDirectory.h"
#include "com/graphhopper/storage/MMapDataAccess.h"
#include "com/graphhopper/storage/RAMDataAccess.h"
#include "com/graphhopper/storage/RAMIntDataAccess.h"
#include "com/graphhopper/storage/SynchedDAWrapper.h"
#include "com/graphhopper/storage/UnsafeDataAccess.h"
#include "com/graphhopper/util/Helper.h"
#include "java/io/File.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/RuntimeException.h"
#include "java/nio/ByteOrder.h"
#include "java/util/Collection.h"
#include "java/util/HashMap.h"
#include "java/util/Map.h"

@interface GHDirectory () {
 @public
  DAType *defaultType_;
  JavaNioByteOrder *byteOrder_;
}
@end

J2OBJC_FIELD_SETTER(GHDirectory, defaultType_, DAType *)
J2OBJC_FIELD_SETTER(GHDirectory, byteOrder_, JavaNioByteOrder *)

@implementation GHDirectory

- (instancetype)initWithNSString:(NSString *)_location
                      withDAType:(DAType *)defaultType {
  if (self = [super init]) {
    GHDirectory_set_byteOrder_(self, JavaNioByteOrder_get_LITTLE_ENDIAN__());
    GHDirectory_setAndConsume_map_(self, [[JavaUtilHashMap alloc] init]);
    GHDirectory_setAndConsume_types_(self, [[JavaUtilHashMap alloc] init]);
    GHDirectory_set_defaultType_(self, defaultType);
    if (Helper_isEmptyWithNSString_(_location)) _location = [((JavaIoFile *) [[[JavaIoFile alloc] initWithNSString:@""] autorelease]) getAbsolutePath];
    if (![((NSString *) nil_chk(_location)) hasSuffix:@"/"]) _location = JreStrcat("$C", _location, '/');
    GHDirectory_set_location_(self, _location);
    JavaIoFile *dir = [[[JavaIoFile alloc] initWithNSString:location_] autorelease];
    if ([dir exists] && ![dir isDirectory]) @throw [[[JavaLangRuntimeException alloc] initWithNSString:JreStrcat("$@$", @"file '", dir, @"' exists but is not a directory")] autorelease];
    if ([((DAType *) nil_chk(self->defaultType_)) isInMemory]) {
      if ([self isStoring]) {
        [self putWithNSString:@"location_index" withDAType:DAType_get_RAM_INT_STORE_()];
        [self putWithNSString:@"edges" withDAType:DAType_get_RAM_INT_STORE_()];
        [self putWithNSString:@"nodes" withDAType:DAType_get_RAM_INT_STORE_()];
      }
      else {
        [self putWithNSString:@"location_index" withDAType:DAType_get_RAM_INT_()];
        [self putWithNSString:@"edges" withDAType:DAType_get_RAM_INT_()];
        [self putWithNSString:@"nodes" withDAType:DAType_get_RAM_INT_()];
      }
    }
  }
  return self;
}

- (JavaNioByteOrder *)getByteOrder {
  return byteOrder_;
}

- (id<Directory>)putWithNSString:(NSString *)name
                      withDAType:(DAType *)type {
  if (![name isEqual:[((NSString *) nil_chk(name)) lowercaseString]]) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Since 0.7 DataAccess objects does no longer accept upper case names"] autorelease];
  [((id<JavaUtilMap>) nil_chk(types_)) putWithId:name withId:type];
  return self;
}

- (id<DataAccess>)findWithNSString:(NSString *)name {
  DAType *type = [((id<JavaUtilMap>) nil_chk(types_)) getWithId:name];
  if (type == nil) type = defaultType_;
  return [self findWithNSString:name withDAType:type];
}

- (id<DataAccess>)findWithNSString:(NSString *)name
                        withDAType:(DAType *)type {
  if (![name isEqual:[((NSString *) nil_chk(name)) lowercaseString]]) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Since 0.7 DataAccess objects does no longer accept upper case names"] autorelease];
  id<DataAccess> da = [((id<JavaUtilMap>) nil_chk(map_)) getWithId:name];
  if (da != nil) {
    if (![((DAType *) nil_chk(type)) isEqual:[da getType]]) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$$$@$@", @"Found existing DataAccess object '", name, @"' but types did not match. Requested:", type, @", was:", [da getType])] autorelease];
    return da;
  }
  if ([((DAType *) nil_chk(type)) isInMemory]) {
    if ([type isInteg]) {
      if ([type isStoring]) da = [[[RAMIntDataAccess alloc] initWithNSString:name withNSString:location_ withBoolean:YES withJavaNioByteOrder:byteOrder_] autorelease];
      else da = [[[RAMIntDataAccess alloc] initWithNSString:name withNSString:location_ withBoolean:NO withJavaNioByteOrder:byteOrder_] autorelease];
    }
    else if ([type isStoring]) da = [[[RAMDataAccess alloc] initWithNSString:name withNSString:location_ withBoolean:YES withJavaNioByteOrder:byteOrder_] autorelease];
    else da = [[[RAMDataAccess alloc] initWithNSString:name withNSString:location_ withBoolean:NO withJavaNioByteOrder:byteOrder_] autorelease];
  }
  else if ([type isMMap]) {
    da = [[[MMapDataAccess alloc] initWithNSString:name withNSString:location_ withJavaNioByteOrder:byteOrder_ withBoolean:[type isAllowWrites]] autorelease];
  }
  else {
    da = [[[UnsafeDataAccess alloc] initWithNSString:name withNSString:location_ withJavaNioByteOrder:byteOrder_] autorelease];
  }
  if ([type isSynched]) da = [[[SynchedDAWrapper alloc] initWithDataAccess:da] autorelease];
  [map_ putWithId:name withId:da];
  return da;
}

- (void)clear {
  MMapDataAccess *mmapDA = nil;
  for (id<DataAccess> __strong da in nil_chk([((id<JavaUtilMap>) nil_chk(map_)) values])) {
    if ([da isKindOfClass:[MMapDataAccess class]]) mmapDA = (MMapDataAccess *) check_class_cast(da, [MMapDataAccess class]);
    [self removeDAWithDataAccess:da withNSString:[((id<DataAccess>) nil_chk(da)) getName] withBoolean:NO];
  }
  if (mmapDA != nil) Helper_cleanHack();
  [map_ clear];
}

- (void)removeWithDataAccess:(id<DataAccess>)da {
  [self removeFromMapWithNSString:[((id<DataAccess>) nil_chk(da)) getName]];
  [self removeDAWithDataAccess:da withNSString:[da getName] withBoolean:YES];
}

- (void)removeDAWithDataAccess:(id<DataAccess>)da
                  withNSString:(NSString *)name
                   withBoolean:(jboolean)forceClean {
  if ([da isKindOfClass:[MMapDataAccess class]]) [((MMapDataAccess *) nil_chk(((MMapDataAccess *) check_class_cast(da, [MMapDataAccess class])))) closeWithBoolean:forceClean];
  else [((id<DataAccess>) nil_chk(da)) close];
  if ([((DAType *) nil_chk([((id<DataAccess>) nil_chk(da)) getType])) isStoring]) Helper_removeDirWithJavaIoFile_([[[JavaIoFile alloc] initWithNSString:JreStrcat("$$", location_, name)] autorelease]);
}

- (void)removeFromMapWithNSString:(NSString *)name {
  id<DataAccess> da = [((id<JavaUtilMap>) nil_chk(map_)) removeWithId:name];
  if (da == nil) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$$", @"Couldn't remove dataAccess object:", name)] autorelease];
}

- (DAType *)getDefaultType {
  return defaultType_;
}

- (jboolean)isStoring {
  return [((DAType *) nil_chk(defaultType_)) isStoring];
}

- (id<Directory>)create {
  if ([self isStoring]) [((JavaIoFile *) [[[JavaIoFile alloc] initWithNSString:location_] autorelease]) mkdirs];
  return self;
}

- (id<JavaUtilCollection>)getAll {
  return [((id<JavaUtilMap>) nil_chk(map_)) values];
}

- (NSString *)description {
  return [self getLocation];
}

- (NSString *)getLocation {
  return location_;
}

- (void)dealloc {
  RELEASE_(location_);
  RELEASE_(defaultType_);
  RELEASE_(byteOrder_);
  RELEASE_(map_);
  RELEASE_(types_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(GHDirectory *)other {
  [super copyAllFieldsTo:other];
  GHDirectory_set_location_(other, location_);
  GHDirectory_set_defaultType_(other, defaultType_);
  GHDirectory_set_byteOrder_(other, byteOrder_);
  GHDirectory_set_map_(other, map_);
  GHDirectory_set_types_(other, types_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithNSString:withDAType:", "GHDirectory", NULL, 0x1, NULL },
    { "getByteOrder", NULL, "Ljava.nio.ByteOrder;", 0x1, NULL },
    { "putWithNSString:withDAType:", "put", "Lcom.graphhopper.storage.Directory;", 0x1, NULL },
    { "findWithNSString:", "find", "Lcom.graphhopper.storage.DataAccess;", 0x1, NULL },
    { "findWithNSString:withDAType:", "find", "Lcom.graphhopper.storage.DataAccess;", 0x1, NULL },
    { "clear", NULL, "V", 0x1, NULL },
    { "removeWithDataAccess:", "remove", "V", 0x1, NULL },
    { "removeDAWithDataAccess:withNSString:withBoolean:", "removeDA", "V", 0x0, NULL },
    { "removeFromMapWithNSString:", "removeFromMap", "V", 0x0, NULL },
    { "getDefaultType", NULL, "Lcom.graphhopper.storage.DAType;", 0x1, NULL },
    { "isStoring", NULL, "Z", 0x1, NULL },
    { "create", NULL, "Lcom.graphhopper.storage.Directory;", 0x1, NULL },
    { "getAll", NULL, "Ljava.util.Collection;", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "getLocation", NULL, "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "location_", NULL, 0x14, "Ljava.lang.String;", NULL,  },
    { "defaultType_", NULL, 0x12, "Lcom.graphhopper.storage.DAType;", NULL,  },
    { "byteOrder_", NULL, 0x12, "Ljava.nio.ByteOrder;", NULL,  },
    { "map_", NULL, 0x4, "Ljava.util.Map;", NULL,  },
    { "types_", NULL, 0x4, "Ljava.util.Map;", NULL,  },
  };
  static const J2ObjcClassInfo _GHDirectory = { 1, "GHDirectory", "com.graphhopper.storage", NULL, 0x1, 15, methods, 5, fields, 0, NULL};
  return &_GHDirectory;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GHDirectory)
